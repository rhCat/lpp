"""
L++ Logic Vulnerability Pointer - State Machine Analyzer
=========================================================

Core state machine analysis engine for LVP.
This is the heart of LVP - analyzing logic flows as state machines.

Key Focus Areas:
1. State transitions and gates
2. Ungated transitions (missing guards)
3. Infinite loops (cycles without exit)
4. Exception masking in finally blocks
5. Dead states and unreachable terminals
"""

import ast
import json
import os
from pathlib import Path
from dataclasses import dataclass, field
from typing import Dict, List, Set, Tuple, Optional, Any
from collections import defaultdict


@dataclass
class LogicVulnerability:
    """Represents a logic vulnerability found via state machine analysis."""
    vuln_type: str
    severity: str  # CRITICAL, HIGH, MEDIUM, LOW
    file_path: str
    line_number: int = 0
    description: str = ""
    affected_states: List[str] = field(default_factory=list)
    affected_transitions: List[str] = field(default_factory=list)
    logic_path: str = ""
    code_snippet: str = ""
    recommendation: str = ""
    state_machine_diagram: str = ""

    def to_dict(self) -> dict:
        return {
            "vuln_type": self.vuln_type,
            "severity": self.severity,
            "file_path": self.file_path,
            "line_number": self.line_number,
            "description": self.description,
            "affected_states": self.affected_states,
            "affected_transitions": self.affected_transitions,
            "logic_path": self.logic_path,
            "code_snippet": self.code_snippet,
            "recommendation": self.recommendation,
            "state_machine_diagram": self.state_machine_diagram
        }


class StateMachineAnalyzer:
    """
    Analyzes bone.json state machines for logic vulnerabilities.

    This is the core L++ analysis - treating code as state machines
    and finding flaws in the logic structure.
    """

    def __init__(self, bone: dict, source_path: str):
        self.bone = bone
        self.source_path = source_path
        self.states = bone.get("states", {})
        self.transitions = bone.get("transitions", [])
        self.gates = bone.get("gates", {})
        self.entry_state = bone.get("entry_state", "idle")
        self.terminal_states = set(bone.get("terminal_states", ["complete", "error"]))
        self.meta = bone.get("_lvp_meta", {})

    def analyze(self) -> List[LogicVulnerability]:
        """Run comprehensive state machine analysis."""
        vulns = []
        vulns.extend(self._find_ungated_transitions())
        vulns.extend(self._find_missing_error_paths())
        vulns.extend(self._find_infinite_loops())
        vulns.extend(self._find_dead_states())
        vulns.extend(self._find_unreachable_terminals())
        return vulns

    def _find_ungated_transitions(self) -> List[LogicVulnerability]:
        """Find transitions without guard conditions."""
        vulns = []

        gated = set()
        for gate_id, gate in self.gates.items():
            if 'transitions' in gate:
                gated.update(gate['transitions'])

        for trans in self.transitions:
            trans_id = trans.get("id", "unknown")
            if trans_id not in gated and trans.get("from") != "*":
                from_state = trans.get("from", "")
                to_state = trans.get("to", "")

                # Self-loops without gates are dangerous
                if from_state == to_state:
                    vulns.append(LogicVulnerability(
                        vuln_type="UNGATED_SELF_LOOP",
                        severity="HIGH",
                        file_path=self.source_path,
                        description=f"State '{from_state}' has ungated self-loop",
                        affected_states=[from_state],
                        affected_transitions=[trans_id],
                        logic_path=f"{from_state} -> {to_state} (ungated)",
                        recommendation="Add gate condition or max iteration limit",
                        state_machine_diagram=self._draw_transition(from_state, to_state, "ungated")
                    ))

        return vulns

    def _find_missing_error_paths(self) -> List[LogicVulnerability]:
        """Find states with no path to error state."""
        vulns = []

        if "error" not in self.terminal_states:
            return vulns

        # Build reverse graph
        reverse_graph = defaultdict(set)
        for trans in self.transitions:
            from_s = trans.get("from", "")
            to_s = trans.get("to", "")
            if from_s != "*":
                reverse_graph[to_s].add(from_s)

        # BFS from error to find states that can reach it
        can_reach_error = set()
        queue = ["error"]
        while queue:
            state = queue.pop(0)
            if state in can_reach_error:
                continue
            can_reach_error.add(state)
            queue.extend(reverse_graph[state])

        # Find states that cannot reach error
        for state_id in self.states:
            if state_id not in can_reach_error and state_id not in self.terminal_states:
                vulns.append(LogicVulnerability(
                    vuln_type="NO_ERROR_PATH",
                    severity="MEDIUM",
                    file_path=self.source_path,
                    description=f"State '{state_id}' has no path to error state",
                    affected_states=[state_id],
                    recommendation="Add error transition from this state"
                ))

        return vulns

    def _find_infinite_loops(self) -> List[LogicVulnerability]:
        """Find cyclic transitions without exit conditions."""
        vulns = []

        # Build adjacency graph
        graph = defaultdict(set)
        for trans in self.transitions:
            from_s = trans.get("from", "")
            to_s = trans.get("to", "")
            if from_s != "*":
                graph[from_s].add(to_s)

        # DFS to find cycles
        def find_cycles(start: str, visited: Set[str], path: List[str]) -> List[List[str]]:
            cycles = []
            if start in visited:
                if start in path:
                    cycle_start = path.index(start)
                    cycles.append(path[cycle_start:] + [start])
                return cycles

            visited.add(start)
            path.append(start)

            for next_state in graph[start]:
                cycles.extend(find_cycles(next_state, visited.copy(), path.copy()))

            return cycles

        all_cycles = []
        for state in self.states:
            cycles = find_cycles(state, set(), [])
            all_cycles.extend(cycles)

        # Deduplicate and check exit conditions
        unique_cycles = set()
        for cycle in all_cycles:
            normalized = tuple(sorted(cycle[:-1]))
            unique_cycles.add(normalized)

        for cycle in unique_cycles:
            cycle_list = list(cycle)
            has_exit = self._cycle_has_exit(cycle_list, graph)

            if not has_exit and len(cycle_list) > 0:
                if any(s in ["processing", "execute", "running", "retry", "loop"] for s in cycle_list):
                    vulns.append(LogicVulnerability(
                        vuln_type="INFINITE_LOOP",
                        severity="HIGH",
                        file_path=self.source_path,
                        description="Cyclic state path with no exit condition",
                        affected_states=cycle_list,
                        logic_path=" -> ".join(cycle_list) + f" -> {cycle_list[0]}",
                        recommendation="Add gated exit transition from cycle",
                        state_machine_diagram=self._draw_cycle(cycle_list)
                    ))

        return vulns

    def _cycle_has_exit(self, cycle: List[str], graph: Dict[str, Set[str]]) -> bool:
        """Check if a cycle has an exit transition."""
        for state in cycle:
            for trans in self.transitions:
                if trans.get("from") == state:
                    to_state = trans.get("to")
                    if to_state not in cycle:
                        return True
        return False

    def _find_dead_states(self) -> List[LogicVulnerability]:
        """Find unreachable states."""
        vulns = []

        has_incoming = {self.entry_state}
        for trans in self.transitions:
            to_s = trans.get("to", "")
            has_incoming.add(to_s)
            if trans.get("from") == "*":
                has_incoming.update(self.states.keys())

        for state_id in self.states:
            if state_id not in has_incoming and state_id != self.entry_state:
                vulns.append(LogicVulnerability(
                    vuln_type="DEAD_STATE",
                    severity="LOW",
                    file_path=self.source_path,
                    description=f"State '{state_id}' is unreachable",
                    affected_states=[state_id],
                    recommendation="Remove dead state or add transition to it"
                ))

        return vulns

    def _find_unreachable_terminals(self) -> List[LogicVulnerability]:
        """Find terminal states that cannot be reached."""
        vulns = []

        # BFS from entry
        reachable = set()
        queue = [self.entry_state]

        graph = defaultdict(set)
        for trans in self.transitions:
            from_s = trans.get("from", "")
            to_s = trans.get("to", "")
            if from_s == "*":
                for s in self.states:
                    graph[s].add(to_s)
            else:
                graph[from_s].add(to_s)

        while queue:
            state = queue.pop(0)
            if state in reachable:
                continue
            reachable.add(state)
            queue.extend(graph[state])

        for terminal in self.terminal_states:
            if terminal not in reachable and terminal in self.states:
                vulns.append(LogicVulnerability(
                    vuln_type="UNREACHABLE_TERMINAL",
                    severity="MEDIUM",
                    file_path=self.source_path,
                    description=f"Terminal state '{terminal}' cannot be reached",
                    affected_states=[terminal],
                    recommendation="Add transition path to terminal state"
                ))

        return vulns

    def _draw_transition(self, from_s: str, to_s: str, label: str = "") -> str:
        """Draw ASCII state machine transition."""
        return f"[{from_s}] --{label}--> [{to_s}]"

    def _draw_cycle(self, states: List[str]) -> str:
        """Draw ASCII cycle diagram."""
        if not states:
            return ""
        lines = []
        for i, state in enumerate(states):
            next_state = states[(i + 1) % len(states)]
            lines.append(f"[{state}] --> [{next_state}]")
        return "\n".join(lines)


class SourceCodeAnalyzer(ast.NodeVisitor):
    """
    AST-based analyzer for source code patterns.

    Finds logic vulnerabilities that require source code inspection:
    - Infinite retry loops (@continuous_retry without max_attempts)
    - Infinite while loops (while True with no exit)
    - Exception masking in finally blocks
    - Silent exception swallowing
    """

    def __init__(self, source: str, file_path: str):
        self.source = source
        self.file_path = file_path
        self.lines = source.split('\n')
        self.vulns = []
        self.current_function = None
        self.current_class = None

    def get_line(self, lineno: int) -> str:
        if 0 < lineno <= len(self.lines):
            return self.lines[lineno - 1].strip()
        return ""

    def visit_ClassDef(self, node):
        old_class = self.current_class
        self.current_class = node.name
        self.generic_visit(node)
        self.current_class = old_class

    def visit_FunctionDef(self, node):
        old_func = self.current_function
        self.current_function = node.name
        self._check_function_decorators(node)
        self.generic_visit(node)
        self.current_function = old_func

    visit_AsyncFunctionDef = visit_FunctionDef

    def _check_function_decorators(self, node):
        """Check for problematic decorator patterns."""
        for dec in node.decorator_list:
            dec_name = ""
            if isinstance(dec, ast.Name):
                dec_name = dec.id
            elif isinstance(dec, ast.Call):
                if isinstance(dec.func, ast.Name):
                    dec_name = dec.func.id
                elif isinstance(dec.func, ast.Attribute):
                    dec_name = dec.func.attr

            # Check for retry decorators without max_attempts
            if "retry" in dec_name.lower() and "continuous" in dec_name.lower():
                has_max = False
                if isinstance(dec, ast.Call):
                    for kw in dec.keywords:
                        if kw.arg in ("max_attempts", "max_retries", "retries"):
                            has_max = True
                            break

                if not has_max:
                    self.vulns.append(LogicVulnerability(
                        vuln_type="INFINITE_RETRY_LOOP",
                        severity="HIGH",
                        file_path=self.file_path,
                        line_number=node.lineno,
                        description=f"@{dec_name} without max_attempts - infinite loop on persistent failure",
                        affected_states=["EXECUTE", "RETRY"],
                        logic_path="ENTRY -> EXECUTE -> exception -> RETRY -> EXECUTE -> ... (infinite)",
                        code_snippet=self.get_line(node.lineno),
                        recommendation="Add max_attempts parameter or implement circuit breaker",
                        state_machine_diagram="""
  ┌─────────┐    exception    ┌───────┐    always    ┌─────────┐
  │  ENTRY  │ ──────────────> │ RETRY │ ───────────> │ EXECUTE │
  └─────────┘                 └───────┘              └────┬────┘
                                  ^                       │
                                  └───────────────────────┘
                                     exception (UNGATED!)"""
                    ))

    def visit_While(self, node):
        """Check for while True without exit conditions."""
        is_infinite = False
        if isinstance(node.test, ast.Constant) and node.test.value is True:
            is_infinite = True
        elif isinstance(node.test, ast.NameConstant) and node.test.value is True:
            is_infinite = True

        if is_infinite:
            has_break = any(isinstance(child, ast.Break) for child in ast.walk(node))
            has_return = any(isinstance(child, ast.Return) for child in ast.walk(node))
            has_raise = any(isinstance(child, ast.Raise) for child in ast.walk(node))

            if not has_break and not has_return and not has_raise:
                func_name = self.current_function or "<module>"
                self.vulns.append(LogicVulnerability(
                    vuln_type="INFINITE_WHILE_LOOP",
                    severity="HIGH",
                    file_path=self.file_path,
                    line_number=node.lineno,
                    description=f"'while True' in {func_name} has no break/return/raise",
                    affected_states=["LOOP_BODY"],
                    logic_path="ENTRY -> LOOP -> LOOP -> LOOP -> ... (no exit)",
                    code_snippet=self.get_line(node.lineno),
                    recommendation="Add conditional break or max iteration limit",
                    state_machine_diagram="""
  ┌─────────┐         ┌───────────┐
  │  ENTRY  │ ──────> │ LOOP_BODY │ ──┐
  └─────────┘         └───────────┘   │
                           ^          │
                           └──────────┘
                            (no exit)"""
                ))
            elif not has_break and not has_return:
                func_name = self.current_function or "<module>"
                self.vulns.append(LogicVulnerability(
                    vuln_type="EXCEPTION_ONLY_EXIT",
                    severity="MEDIUM",
                    file_path=self.file_path,
                    line_number=node.lineno,
                    description=f"'while True' in {func_name} only exits via exception",
                    affected_states=["LOOP_BODY", "EXCEPTION"],
                    logic_path="ENTRY -> LOOP -> ... -> exception -> EXIT",
                    code_snippet=self.get_line(node.lineno),
                    recommendation="Add explicit termination condition"
                ))

        self.generic_visit(node)

    def visit_Try(self, node):
        """Check for exception handling issues."""
        # Check for silent swallowing
        for handler in node.handlers:
            if handler.type is None:  # bare except
                if len(handler.body) == 1 and isinstance(handler.body[0], ast.Pass):
                    self.vulns.append(LogicVulnerability(
                        vuln_type="SILENT_EXCEPTION_SWALLOW",
                        severity="MEDIUM",
                        file_path=self.file_path,
                        line_number=handler.lineno,
                        description="Bare 'except: pass' silently swallows ALL exceptions",
                        code_snippet=self.get_line(handler.lineno),
                        recommendation="Catch specific exceptions and log errors",
                        state_machine_diagram="""
  ┌─────┐    any exception    ┌──────┐
  │ TRY │ ──────────────────> │ PASS │  (no transition to ERROR)
  └─────┘                     └──────┘"""
                    ))

            elif isinstance(handler.type, ast.Name) and handler.type.id == "Exception":
                if len(handler.body) == 1 and isinstance(handler.body[0], ast.Pass):
                    self.vulns.append(LogicVulnerability(
                        vuln_type="EXCEPTION_PASS",
                        severity="LOW",
                        file_path=self.file_path,
                        line_number=handler.lineno,
                        description="'except Exception: pass' silently ignores errors",
                        code_snippet=self.get_line(handler.lineno),
                        recommendation="Log exceptions even if continuing"
                    ))

        # Check for exception masking in finally
        if node.finalbody:
            for stmt in node.finalbody:
                if isinstance(stmt, ast.Expr) and isinstance(stmt.value, ast.Await):
                    self.vulns.append(LogicVulnerability(
                        vuln_type="EXCEPTION_MASKING_FINALLY",
                        severity="HIGH",
                        file_path=self.file_path,
                        line_number=stmt.lineno,
                        description="Async call in finally block can mask original exceptions",
                        logic_path="try raises A -> finally raises B -> B masks A",
                        code_snippet=self.get_line(stmt.lineno),
                        recommendation="Wrap finally cleanup in try/except",
                        state_machine_diagram="""
  ┌─────┐    raises A    ┌───────────┐    raises B    ┌───────┐
  │ TRY │ ─────────────> │  FINALLY  │ ─────────────> │ CATCH │
  └─────┘                └───────────┘                └───────┘

  Exception B masks Exception A. Original error is LOST."""
                    ))

        self.generic_visit(node)


def analyze_source_file(file_path: str) -> List[LogicVulnerability]:
    """Analyze a single Python source file."""
    try:
        with open(file_path, 'r') as f:
            source = f.read()

        tree = ast.parse(source)
        analyzer = SourceCodeAnalyzer(source, file_path)
        analyzer.visit(tree)
        return analyzer.vulns

    except SyntaxError as e:
        return [LogicVulnerability(
            vuln_type="PARSE_ERROR",
            severity="LOW",
            file_path=file_path,
            line_number=e.lineno or 0,
            description=f"Syntax error: {e.msg}"
        )]
    except Exception as e:
        return [LogicVulnerability(
            vuln_type="PARSE_ERROR",
            severity="LOW",
            file_path=file_path,
            description=f"Failed to parse: {e}"
        )]


def analyze_bone_file(bone_path: str) -> List[LogicVulnerability]:
    """Analyze a bone.json state machine file."""
    try:
        with open(bone_path) as f:
            bone = json.load(f)

        source_path = bone.get("_lvp_meta", {}).get("source_path", str(bone_path))
        analyzer = StateMachineAnalyzer(bone, source_path)
        return analyzer.analyze()

    except Exception as e:
        return [LogicVulnerability(
            vuln_type="BONE_PARSE_ERROR",
            severity="LOW",
            file_path=bone_path,
            description=f"Failed to analyze bone: {e}"
        )]


def analyze_directory(directory: str, include_source: bool = True, include_bones: bool = True) -> Tuple[List[LogicVulnerability], Dict[str, Any]]:
    """
    Analyze all files in a directory.

    Args:
        directory: Path to analyze
        include_source: Whether to analyze Python source files
        include_bones: Whether to analyze bone.json files

    Returns:
        Tuple of (vulnerabilities list, statistics dict)
    """
    all_vulns = []
    stats = {
        "files_analyzed": 0,
        "source_files": 0,
        "bone_files": 0,
        "by_severity": defaultdict(int),
        "by_type": defaultdict(int),
        "by_file": defaultdict(list)
    }

    for root, dirs, files in os.walk(directory):
        # Skip irrelevant directories
        dirs[:] = [d for d in dirs if d not in ('__pycache__', '.git', 'venv', 'node_modules', '.venv', 'test', 'tests')]

        for filename in files:
            file_path = os.path.join(root, filename)

            # Analyze source files
            if include_source and filename.endswith('.py'):
                vulns = analyze_source_file(file_path)
                all_vulns.extend(vulns)
                stats["source_files"] += 1
                stats["files_analyzed"] += 1
                for v in vulns:
                    stats["by_severity"][v.severity] += 1
                    stats["by_type"][v.vuln_type] += 1
                    stats["by_file"][file_path].append(v)

            # Analyze bone files
            if include_bones and filename.endswith('_bone.json'):
                vulns = analyze_bone_file(file_path)
                all_vulns.extend(vulns)
                stats["bone_files"] += 1
                stats["files_analyzed"] += 1
                for v in vulns:
                    stats["by_severity"][v.severity] += 1
                    stats["by_type"][v.vuln_type] += 1
                    stats["by_file"][file_path].append(v)

    stats["by_severity"] = dict(stats["by_severity"])
    stats["by_type"] = dict(stats["by_type"])
    stats["by_file"] = {k: [vv.to_dict() for vv in v] for k, v in stats["by_file"].items()}

    return all_vulns, stats


# L++ Compute Unit Interface
def analyze_state_machine(params: dict) -> dict:
    """
    L++ Compute Unit: Analyze state machine for logic vulnerabilities.

    This is the main entry point for LVP state machine analysis.

    Args:
        params: Dictionary with:
            - bone_json: State machine bone.json (dict)
            - source_path: Path to source file (str)

    Returns:
        Dictionary with:
            - vulnerabilities: List of vulnerability dicts
            - stats: Analysis statistics
            - error: Error message if any
    """
    bone_json = params.get("bone_json", {})
    source_path = params.get("source_path", "")

    if not bone_json:
        return {"vulnerabilities": [], "stats": {}, "error": "No bone_json provided"}

    try:
        analyzer = StateMachineAnalyzer(bone_json, source_path)
        vulns = analyzer.analyze()

        return {
            "vulnerabilities": [v.to_dict() for v in vulns],
            "stats": {
                "total": len(vulns),
                "by_severity": {
                    "HIGH": len([v for v in vulns if v.severity == "HIGH"]),
                    "MEDIUM": len([v for v in vulns if v.severity == "MEDIUM"]),
                    "LOW": len([v for v in vulns if v.severity == "LOW"])
                }
            },
            "error": None
        }

    except Exception as e:
        return {"vulnerabilities": [], "stats": {}, "error": str(e)}


def analyze_source(params: dict) -> dict:
    """
    L++ Compute Unit: Analyze source code for logic vulnerabilities.

    Args:
        params: Dictionary with:
            - file_path: Path to Python file

    Returns:
        Dictionary with vulnerabilities and stats
    """
    file_path = params.get("file_path", "")

    if not file_path:
        return {"vulnerabilities": [], "stats": {}, "error": "No file_path provided"}

    try:
        vulns = analyze_source_file(file_path)
        return {
            "vulnerabilities": [v.to_dict() for v in vulns],
            "stats": {
                "total": len(vulns),
                "by_severity": {
                    "HIGH": len([v for v in vulns if v.severity == "HIGH"]),
                    "MEDIUM": len([v for v in vulns if v.severity == "MEDIUM"]),
                    "LOW": len([v for v in vulns if v.severity == "LOW"])
                }
            },
            "error": None
        }

    except Exception as e:
        return {"vulnerabilities": [], "stats": {}, "error": str(e)}
