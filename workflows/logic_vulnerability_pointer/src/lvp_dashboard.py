#!/usr/bin/env python3
"""
L++ Logic Vulnerability Pointer - Dashboard Generator
======================================================

Generates comprehensive dashboards for reviewing Python repositories.
Creates both HTML and Markdown reports with:
- State machine analysis results
- Logic vulnerability findings
- File-by-file breakdown
- State machine diagrams
- Test generation

Usage:
    python lvp_dashboard.py /path/to/repo --output /path/to/output

The dashboard shows:
1. Executive summary of all vulnerabilities
2. State machine diagrams for each module
3. Logic flow analysis with gates and transitions
4. Generated test cases for each vulnerability
"""

import argparse
import json
import os
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Tuple
from collections import defaultdict
from dataclasses import dataclass

# Add parent directory for imports
sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent))

from workflows.logic_vulnerability_pointer.src.lvp_state_machine_analyzer import (
    LogicVulnerability,
    StateMachineAnalyzer,
    SourceCodeAnalyzer,
    analyze_source_file,
    analyze_bone_file,
    analyze_directory
)


@dataclass
class ModuleAnalysis:
    """Analysis results for a single module."""
    file_path: str
    bone_json: dict
    source_vulns: List[LogicVulnerability]
    state_vulns: List[LogicVulnerability]
    state_diagram: str
    test_code: str


class LVPDashboard:
    """Generates comprehensive LVP analysis dashboards."""

    def __init__(self, target_dir: str, output_dir: str):
        self.target_dir = target_dir
        self.output_dir = output_dir
        self.bones_dir = os.path.join(output_dir, "bones")
        self.tests_dir = os.path.join(output_dir, "tests")

        os.makedirs(self.bones_dir, exist_ok=True)
        os.makedirs(self.tests_dir, exist_ok=True)

        self.modules: List[ModuleAnalysis] = []
        self.all_vulns: List[LogicVulnerability] = []

    def analyze_repo(self):
        """Run full LVP analysis on repository."""
        print(f"\nAnalyzing repository: {self.target_dir}\n")

        # Find all Python files
        python_files = self._find_python_files(self.target_dir)
        print(f"Found {len(python_files)} Python files")

        # Phase 1: Extract bones and analyze source
        print("\n[Phase 1] Extracting state machines and analyzing source...")

        for i, file_path in enumerate(python_files):
            if (i + 1) % 50 == 0:
                print(f"  Processed {i+1}/{len(python_files)} files...")

            # Source analysis
            source_vulns = analyze_source_file(file_path)

            # Extract bone (if logic_decoder available)
            bone_json = self._extract_bone(file_path)

            # State machine analysis
            state_vulns = []
            if bone_json:
                analyzer = StateMachineAnalyzer(bone_json, file_path)
                state_vulns = analyzer.analyze()

            # Generate state diagram
            state_diagram = self._generate_state_diagram(bone_json) if bone_json else ""

            # Generate test code
            all_vulns = source_vulns + state_vulns
            test_code = self._generate_tests(all_vulns, file_path, bone_json)

            self.modules.append(ModuleAnalysis(
                file_path=file_path,
                bone_json=bone_json,
                source_vulns=source_vulns,
                state_vulns=state_vulns,
                state_diagram=state_diagram,
                test_code=test_code
            ))

            self.all_vulns.extend(all_vulns)

            # Log HIGH severity finds
            high_vulns = [v for v in all_vulns if v.severity == "HIGH"]
            if high_vulns:
                short_path = file_path.split(os.path.basename(self.target_dir) + "/")[-1]
                print(f"  [HIGH] {short_path}: {len(high_vulns)} issues")

        print(f"\nTotal: {len(self.all_vulns)} vulnerabilities found")

    def _find_python_files(self, directory: str) -> List[str]:
        """Find all Python files in directory."""
        files = []
        for root, dirs, filenames in os.walk(directory):
            dirs[:] = [d for d in dirs if d not in ('__pycache__', '.git', 'venv', 'node_modules', '.venv')]
            for filename in filenames:
                if filename.endswith('.py'):
                    files.append(os.path.join(root, filename))
        return files

    def _extract_bone(self, file_path: str) -> dict:
        """Extract bone.json from Python file."""
        try:
            from utils.logic_decoder.src.decoder_compute import (
                loadFile, parseAst, analyzeImports, analyzeFunctions,
                extractConstants, analyzeControlFlow, inferStates,
                inferTransitions, inferActions, generateBlueprint
            )

            # Run decoder pipeline
            load_result = loadFile({"filePath": file_path})
            if load_result.get("error"):
                return {}

            source_code = load_result["sourceCode"]
            ast_result = parseAst({"sourceCode": source_code})
            if ast_result.get("error"):
                return {}

            ast_dict = ast_result["ast"]
            imports = analyzeImports({"ast": ast_dict}).get("imports", [])
            functions = analyzeFunctions({"ast": ast_dict, "imports": imports}).get("functions", [])
            classes = analyzeFunctions({"ast": ast_dict, "imports": imports}).get("classes", [])
            constants = extractConstants({"ast": ast_dict}).get("constants", [])
            control_flow = analyzeControlFlow({"ast": ast_dict, "functions": functions}).get("controlFlow", {})
            states = inferStates({
                "functions": functions, "classes": classes,
                "controlFlow": control_flow, "imports": imports
            }).get("states", [])
            trans_result = inferTransitions({
                "controlFlow": control_flow, "inferredStates": states, "functions": functions
            })
            transitions = trans_result.get("transitions", [])
            gates = trans_result.get("gates", [])
            actions = inferActions({
                "functions": functions, "imports": imports, "controlFlow": control_flow
            }).get("actions", [])

            bp_result = generateBlueprint({
                "filePath": file_path, "inferredStates": states,
                "inferredTransitions": transitions, "inferredGates": gates,
                "inferredActions": actions, "imports": imports,
                "constants": constants, "classes": classes
            })

            bone = bp_result.get("blueprint", {})
            bone["_lvp_meta"] = {
                "source_path": file_path,
                "functions": [f["name"] for f in functions if not f["name"].startswith("_")],
                "classes": [c["name"] for c in classes],
                "source_lines": len(source_code.split("\n"))
            }

            # Save bone
            safe_name = Path(file_path).stem.replace("-", "_")
            bone_path = os.path.join(self.bones_dir, f"{safe_name}_bone.json")
            with open(bone_path, "w") as f:
                json.dump(bone, f, indent=2)

            return bone

        except Exception:
            return {}

    def _generate_state_diagram(self, bone: dict) -> str:
        """Generate ASCII state machine diagram."""
        if not bone:
            return ""

        states = bone.get("states", {})
        transitions = bone.get("transitions", [])
        entry = bone.get("entry_state", "idle")
        terminals = bone.get("terminal_states", [])

        lines = ["State Machine Diagram:", "=" * 40, ""]

        # Entry state
        lines.append(f"  [ENTRY] --> [{entry}]")
        lines.append("")

        # Transitions
        for trans in transitions[:15]:  # Limit for readability
            from_s = trans.get("from", "?")
            to_s = trans.get("to", "?")
            event = trans.get("on_event", "")
            if from_s != "*":
                lines.append(f"  [{from_s}] --{event}--> [{to_s}]")

        lines.append("")

        # Terminals
        for term in terminals:
            lines.append(f"  [{term}] --> [END]")

        return "\n".join(lines)

    def _generate_tests(self, vulns: List[LogicVulnerability], file_path: str, bone: dict) -> str:
        """Generate pytest test cases for vulnerabilities."""
        if not vulns:
            return ""

        safe_name = Path(file_path).stem.replace("-", "_").replace(".", "_")

        tests = [f'''"""
LVP Generated Tests: {Path(file_path).name}
============================================
Auto-generated from state machine analysis.
"""

import pytest
from unittest.mock import MagicMock, patch
''']

        high_vulns = [v for v in vulns if v.severity == "HIGH"]

        for v in high_vulns:
            if v.vuln_type == "INFINITE_RETRY_LOOP":
                tests.append(f'''

class Test{safe_name.title().replace("_", "")}InfiniteRetry:
    """
    LVP Test: {v.vuln_type}
    File: {v.file_path}
    Line: {v.line_number}

    Logic Path: {v.logic_path}
    """

    def test_retry_has_no_termination(self):
        """
        State Machine Analysis:
{v.state_machine_diagram}

        The RETRY -> EXECUTE transition has NO GATE.
        When function always fails, this creates infinite loop.
        """
        # Document the vulnerability
        assert True, "Infinite retry pattern documented at line {v.line_number}"

    def test_no_max_attempts(self):
        """Verify: No max_attempts parameter exists."""
        code = """{v.code_snippet}"""
        assert "max_attempts" not in code.lower()
''')

            elif v.vuln_type == "INFINITE_WHILE_LOOP":
                tests.append(f'''

class Test{safe_name.title().replace("_", "")}InfiniteWhile:
    """
    LVP Test: {v.vuln_type}
    File: {v.file_path}
    Line: {v.line_number}

    Logic Path: {v.logic_path}
    """

    def test_while_true_no_exit(self):
        """
        State Machine:
{v.state_machine_diagram}

        No exit transition from LOOP_BODY state.
        """
        assert True, "Infinite while loop documented at line {v.line_number}"
''')

            elif v.vuln_type == "EXCEPTION_MASKING_FINALLY":
                tests.append(f'''

class Test{safe_name.title().replace("_", "")}ExceptionMasking:
    """
    LVP Test: {v.vuln_type}
    File: {v.file_path}
    Line: {v.line_number}

    Logic Path: {v.logic_path}
    """

    def test_finally_can_mask_exceptions(self):
        """
        State Machine:
{v.state_machine_diagram}

        Exception B replaces Exception A completely.
        """
        original = None
        caught = None

        try:
            try:
                raise ValueError("Original")
            finally:
                raise RuntimeError("Cleanup")
        except Exception as e:
            caught = e

        assert isinstance(caught, RuntimeError)
        assert "Original" not in str(caught)
''')

        return "\n".join(tests)

    def generate_markdown_report(self) -> str:
        """Generate comprehensive Markdown report."""
        by_severity = defaultdict(list)
        by_type = defaultdict(list)
        for v in self.all_vulns:
            by_severity[v.severity].append(v)
            by_type[v.vuln_type].append(v)

        report = f"""# LVP Analysis Report
## {os.path.basename(self.target_dir)}

**Generated:** {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
**Analyzer:** L++ Logic Vulnerability Pointer

---

## Executive Summary

| Metric | Value |
|--------|-------|
| Files Analyzed | {len(self.modules)} |
| Total Vulnerabilities | {len(self.all_vulns)} |
| HIGH Severity | {len(by_severity['HIGH'])} |
| MEDIUM Severity | {len(by_severity['MEDIUM'])} |
| LOW Severity | {len(by_severity['LOW'])} |

### Vulnerability Types

| Type | Count | Severity |
|------|-------|----------|
"""
        for vtype, vlist in sorted(by_type.items(), key=lambda x: -len(x[1])):
            sev = vlist[0].severity if vlist else "?"
            report += f"| {vtype} | {len(vlist)} | {sev} |\n"

        report += """
---

## State Machine Analysis

LVP analyzes code as state machines to find logic flaws:

```
State Machine = {States, Transitions, Gates, Entry, Terminals}

Vulnerability Types:
  - UNGATED TRANSITION: Transition without guard condition
  - INFINITE LOOP: Cycle with no exit transition
  - NO ERROR PATH: State with no path to error handling
  - DEAD STATE: Unreachable state (dead code)
```

---

## HIGH Severity Vulnerabilities

"""
        for i, v in enumerate(by_severity['HIGH'][:20], 1):
            short_path = v.file_path.split(os.path.basename(self.target_dir) + "/")[-1]
            report += f"""
### [{i}] {v.vuln_type}

**File:** `{short_path}:{v.line_number}`

**Description:** {v.description}

**Logic Path:**
```
{v.logic_path}
```

**State Machine:**
```
{v.state_machine_diagram}
```

**Code:**
```python
{v.code_snippet}
```

**Recommendation:** {v.recommendation}

---
"""

        if len(by_severity['HIGH']) > 20:
            report += f"\n*... and {len(by_severity['HIGH']) - 20} more HIGH severity issues*\n"

        report += """
## Root Cause Analysis

### 1. Infinite Retry Loop (@continuous_retry)

```
State Machine:
  ┌─────────┐    exception    ┌───────┐    always    ┌─────────┐
  │  ENTRY  │ ──────────────> │ RETRY │ ───────────> │ EXECUTE │
  └─────────┘                 └───────┘              └────┬────┘
                                  ^                       │
                                  └───────────────────────┘
                                     exception (UNGATED!)
```

The RETRY → EXECUTE transition has **no gate**. It always fires.
When function persistently fails, this creates infinite loop.

**Fix:** Add `max_attempts` guard on RETRY → EXECUTE transition.

### 2. Exception Masking in Finally

```
State Machine:
  ┌─────┐    raises A    ┌───────────┐    raises B    ┌───────┐
  │ TRY │ ─────────────> │  FINALLY  │ ─────────────> │ CATCH │
  └─────┘                └───────────┘                └───────┘
```

Exception B **replaces** Exception A. Original error is lost.

**Fix:** Capture original exception before finally block.

### 3. Silent Exception Swallowing

```
State Machine:
  ┌─────┐    any exception    ┌──────┐
  │ TRY │ ──────────────────> │ PASS │  (no ERROR transition)
  └─────┘                     └──────┘
```

Errors vanish. No logging. No visibility.

**Fix:** Catch specific exceptions, always log.

---

## Files By Risk

| High | Med | File |
|------|-----|------|
"""
        file_risk = defaultdict(lambda: {"high": 0, "med": 0, "low": 0})
        for v in self.all_vulns:
            if v.severity == "HIGH":
                file_risk[v.file_path]["high"] += 1
            elif v.severity == "MEDIUM":
                file_risk[v.file_path]["med"] += 1
            else:
                file_risk[v.file_path]["low"] += 1

        sorted_files = sorted(file_risk.items(), key=lambda x: (-x[1]["high"], -x[1]["med"]))
        for fp, counts in sorted_files[:20]:
            short_path = fp.split(os.path.basename(self.target_dir) + "/")[-1]
            report += f"| {counts['high']} | {counts['med']} | `{short_path}` |\n"

        report += """
---

## Generated Tests

LVP automatically generates pytest test cases from the logic analysis.
See the `tests/` directory for runnable test files.

---

*Generated by L++ Logic Vulnerability Pointer*
"""
        return report

    def generate_html_report(self) -> str:
        """Generate HTML dashboard."""
        by_severity = defaultdict(list)
        by_type = defaultdict(list)
        for v in self.all_vulns:
            by_severity[v.severity].append(v)
            by_type[v.vuln_type].append(v)

        html = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LVP Dashboard - {os.path.basename(self.target_dir)}</title>
    <style>
        :root {{
            --bg: #0d1117;
            --fg: #c9d1d9;
            --card-bg: #161b22;
            --border: #30363d;
            --high: #f85149;
            --med: #f0883e;
            --low: #3fb950;
        }}
        * {{ box-sizing: border-box; margin: 0; padding: 0; }}
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            background: var(--bg);
            color: var(--fg);
            line-height: 1.6;
            padding: 20px;
        }}
        .container {{ max-width: 1400px; margin: 0 auto; }}
        h1, h2, h3 {{ margin-bottom: 1rem; }}
        h1 {{ color: #58a6ff; font-size: 2rem; }}
        h2 {{ color: #8b949e; font-size: 1.5rem; border-bottom: 1px solid var(--border); padding-bottom: 0.5rem; }}

        .summary {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }}
        .card {{
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 20px;
        }}
        .card h3 {{ color: #8b949e; font-size: 0.875rem; text-transform: uppercase; }}
        .card .value {{ font-size: 2.5rem; font-weight: 600; margin-top: 10px; }}
        .high {{ color: var(--high); }}
        .med {{ color: var(--med); }}
        .low {{ color: var(--low); }}

        .vuln-list {{ margin-top: 20px; }}
        .vuln-item {{
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
        }}
        .vuln-item.high {{ border-left: 4px solid var(--high); }}
        .vuln-item.med {{ border-left: 4px solid var(--med); }}
        .vuln-header {{
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }}
        .vuln-type {{ font-weight: 600; color: #58a6ff; }}
        .vuln-severity {{
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
        }}
        .vuln-severity.high {{ background: var(--high); color: white; }}
        .vuln-severity.med {{ background: var(--med); color: white; }}
        .vuln-file {{ font-family: monospace; color: #8b949e; font-size: 0.875rem; }}

        pre {{
            background: #0d1117;
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 15px;
            overflow-x: auto;
            font-size: 0.875rem;
            margin: 10px 0;
        }}
        code {{ font-family: 'SF Mono', Monaco, Consolas, monospace; }}

        .state-diagram {{
            background: #0d1117;
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 15px;
            font-family: monospace;
            white-space: pre;
            overflow-x: auto;
        }}

        table {{
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }}
        th, td {{
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }}
        th {{ background: var(--card-bg); color: #8b949e; font-weight: 600; }}

        .tabs {{ display: flex; gap: 10px; margin-bottom: 20px; }}
        .tab {{
            padding: 8px 16px;
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            color: var(--fg);
        }}
        .tab.active {{ background: #238636; border-color: #238636; }}
    </style>
</head>
<body>
    <div class="container">
        <h1>LVP Analysis Dashboard</h1>
        <p style="color: #8b949e;">Repository: {os.path.basename(self.target_dir)} | Generated: {datetime.now().strftime("%Y-%m-%d %H:%M")}</p>

        <div class="summary">
            <div class="card">
                <h3>Files Analyzed</h3>
                <div class="value">{len(self.modules)}</div>
            </div>
            <div class="card">
                <h3>Total Vulnerabilities</h3>
                <div class="value">{len(self.all_vulns)}</div>
            </div>
            <div class="card">
                <h3>High Severity</h3>
                <div class="value high">{len(by_severity['HIGH'])}</div>
            </div>
            <div class="card">
                <h3>Medium Severity</h3>
                <div class="value med">{len(by_severity['MEDIUM'])}</div>
            </div>
        </div>

        <h2>Vulnerability Types</h2>
        <table>
            <tr><th>Type</th><th>Count</th><th>Severity</th><th>State Machine Pattern</th></tr>
"""
        patterns = {
            "INFINITE_RETRY_LOOP": "RETRY → EXECUTE (ungated loop)",
            "INFINITE_WHILE_LOOP": "LOOP → LOOP (no exit)",
            "EXCEPTION_MASKING_FINALLY": "TRY → FINALLY → CATCH (masks A with B)",
            "SILENT_EXCEPTION_SWALLOW": "TRY → PASS (no ERROR transition)",
            "NO_ERROR_PATH": "STATE → ? (no path to ERROR)",
            "UNGATED_SELF_LOOP": "STATE → STATE (ungated)",
        }
        for vtype, vlist in sorted(by_type.items(), key=lambda x: -len(x[1])):
            sev = vlist[0].severity if vlist else "LOW"
            pattern = patterns.get(vtype, "See details")
            sev_class = "high" if sev == "HIGH" else ("med" if sev == "MEDIUM" else "low")
            html += f"""
            <tr>
                <td><code>{vtype}</code></td>
                <td>{len(vlist)}</td>
                <td><span class="vuln-severity {sev_class}">{sev}</span></td>
                <td><code>{pattern}</code></td>
            </tr>
"""

        html += """
        </table>

        <h2>HIGH Severity Vulnerabilities</h2>
        <div class="vuln-list">
"""
        for v in by_severity['HIGH'][:15]:
            short_path = v.file_path.split(os.path.basename(self.target_dir) + "/")[-1]
            diagram = v.state_machine_diagram.replace("\n", "<br>").replace(" ", "&nbsp;") if v.state_machine_diagram else ""
            html += f"""
            <div class="vuln-item high">
                <div class="vuln-header">
                    <span class="vuln-type">{v.vuln_type}</span>
                    <span class="vuln-severity high">HIGH</span>
                </div>
                <div class="vuln-file">{short_path}:{v.line_number}</div>
                <p style="margin: 10px 0;">{v.description}</p>
                <p style="color: #8b949e;"><strong>Logic Path:</strong> <code>{v.logic_path}</code></p>
                {f'<div class="state-diagram">{diagram}</div>' if diagram else ''}
                <p style="margin-top: 10px; color: #3fb950;"><strong>Fix:</strong> {v.recommendation}</p>
            </div>
"""

        if len(by_severity['HIGH']) > 15:
            html += f'<p style="color: #8b949e;">... and {len(by_severity["HIGH"]) - 15} more HIGH severity issues</p>'

        html += """
        </div>

        <h2>Root Cause Analysis</h2>

        <div class="card" style="margin-bottom: 20px;">
            <h3 style="color: var(--high);">Infinite Retry Loop</h3>
            <div class="state-diagram">
  ┌─────────┐    exception    ┌───────┐    always    ┌─────────┐
  │  ENTRY  │ ──────────────► │ RETRY │ ────────────► │ EXECUTE │
  └─────────┘                 └───────┘              └────┬────┘
                                  ▲                       │
                                  └───────────────────────┘
                                     exception (UNGATED!)
            </div>
            <p style="margin-top: 10px;">The RETRY → EXECUTE transition has <strong>no gate</strong>. On persistent failure, infinite loop.</p>
        </div>

        <div class="card" style="margin-bottom: 20px;">
            <h3 style="color: var(--high);">Exception Masking in Finally</h3>
            <div class="state-diagram">
  ┌─────┐    raises A    ┌───────────┐    raises B    ┌───────┐
  │ TRY │ ─────────────► │  FINALLY  │ ─────────────► │ CATCH │
  └─────┘                └───────────┘                └───────┘

  Exception B REPLACES Exception A. Original error is LOST.
            </div>
            <p style="margin-top: 10px;">Python behavior: finally exception masks try exception.</p>
        </div>

        <h2>Files by Risk</h2>
        <table>
            <tr><th>High</th><th>Med</th><th>File</th></tr>
"""
        file_risk = defaultdict(lambda: {"high": 0, "med": 0})
        for v in self.all_vulns:
            if v.severity == "HIGH":
                file_risk[v.file_path]["high"] += 1
            elif v.severity == "MEDIUM":
                file_risk[v.file_path]["med"] += 1

        sorted_files = sorted(file_risk.items(), key=lambda x: (-x[1]["high"], -x[1]["med"]))[:20]
        for fp, counts in sorted_files:
            short_path = fp.split(os.path.basename(self.target_dir) + "/")[-1]
            html += f"""
            <tr>
                <td class="high">{counts['high']}</td>
                <td class="med">{counts['med']}</td>
                <td><code>{short_path}</code></td>
            </tr>
"""

        html += """
        </table>

        <p style="margin-top: 40px; color: #8b949e; text-align: center;">
            Generated by L++ Logic Vulnerability Pointer
        </p>
    </div>
</body>
</html>
"""
        return html

    def save_reports(self):
        """Save all reports and artifacts."""
        # Markdown report
        md_path = os.path.join(self.output_dir, "LVP_REPORT.md")
        with open(md_path, "w") as f:
            f.write(self.generate_markdown_report())
        print(f"Saved: {md_path}")

        # HTML dashboard
        html_path = os.path.join(self.output_dir, "dashboard.html")
        with open(html_path, "w") as f:
            f.write(self.generate_html_report())
        print(f"Saved: {html_path}")

        # JSON data
        json_path = os.path.join(self.output_dir, "vulnerabilities.json")
        with open(json_path, "w") as f:
            json.dump({
                "summary": {
                    "total": len(self.all_vulns),
                    "high": len([v for v in self.all_vulns if v.severity == "HIGH"]),
                    "medium": len([v for v in self.all_vulns if v.severity == "MEDIUM"]),
                    "low": len([v for v in self.all_vulns if v.severity == "LOW"])
                },
                "vulnerabilities": [v.to_dict() for v in self.all_vulns]
            }, f, indent=2)
        print(f"Saved: {json_path}")

        # Test files
        for module in self.modules:
            if module.test_code:
                safe_name = Path(module.file_path).stem.replace("-", "_")
                test_path = os.path.join(self.tests_dir, f"test_{safe_name}_lvp.py")
                with open(test_path, "w") as f:
                    f.write(module.test_code)

        print(f"Saved {len([m for m in self.modules if m.test_code])} test files to {self.tests_dir}")


def main():
    parser = argparse.ArgumentParser(description="LVP Dashboard Generator")
    parser.add_argument("target", help="Target directory to analyze")
    parser.add_argument("-o", "--output", help="Output directory", default=None)
    args = parser.parse_args()

    if not os.path.isdir(args.target):
        print(f"Error: {args.target} is not a directory")
        sys.exit(1)

    output = args.output or os.path.join(
        os.path.dirname(os.path.dirname(os.path.abspath(__file__))),
        "results",
        f"lvp_{os.path.basename(args.target)}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
    )

    dashboard = LVPDashboard(args.target, output)
    dashboard.analyze_repo()
    dashboard.save_reports()

    print(f"\nDashboard generated at: {output}")
    print(f"Open {os.path.join(output, 'dashboard.html')} in a browser to view.")


if __name__ == "__main__":
    main()
