#!/usr/bin/env python3
"""
L++ Logic Vulnerability Pointer (LVP) - Interactive CLI

Non-Destructive Testing (NDT) for software logic.
Like X-rays for turbine blades, LVP finds "logic cracks" in Python applications.

Usage:
    python interactive.py <target.py>           # Full audit
    python interactive.py <target.py> --xray    # Only extract logic
    python interactive.py <target.py> --threat  # X-Ray + Threat Model
    python interactive.py <target.py> --no-fix  # Skip auto-fix phase
"""

import argparse
import os
import sys
from pathlib import Path

# Add L++ to path
LPP_ROOT = Path(__file__).resolve().parent.parent.parent
sys.path.insert(0, str(LPP_ROOT))

from src.lvp_compute import (
    init, set_target_name, extract_logic, define_invariants,
    generate_tla, run_tlc, analyze_traces, generate_exploits,
    generate_patches, verify_fix_tlaps, generate_report,
    generate_secure_report, capture_error
)


def print_banner():
    """Print LVP banner."""
    print("""
╔═══════════════════════════════════════════════════════════════╗
║   L++ LOGIC VULNERABILITY POINTER (LVP)                       ║
║   Non-Destructive Testing for Software Logic                  ║
╠═══════════════════════════════════════════════════════════════╣
║   Phase 1: X-Ray       - Extract logic blueprint              ║
║   Phase 2: Threat Model - Define safety invariants            ║
║   Phase 3: Stress Test - Find counter-examples (TLC)          ║
║   Phase 4: Exploit Gen - Generate trigger scripts             ║
║   Phase 5: The Fix     - Re-machine with TLAPS immunity       ║
╚═══════════════════════════════════════════════════════════════╝
    """)


def print_phase(num: int, name: str, description: str):
    """Print phase header."""
    print(f"\n{'═' * 60}")
    print(f"  PHASE {num}: {name}")
    print(f"  {description}")
    print(f"{'═' * 60}\n")


def run_audit(target_path: str, xray_only: bool = False, threat_only: bool = False,
              auto_fix: bool = True, verbose: bool = False):
    """Run the LVP security audit."""

    # Phase 0: Initialize
    print("[*] Initializing LVP audit environment...")
    ctx = init({})
    ctx["target_path"] = target_path

    # Set target name
    name_result = set_target_name({"target_path": target_path})
    ctx["target_name"] = name_result["target_name"]

    print(f"[+] Run ID: {ctx['run_id']}")
    print(f"[+] Target: {ctx['target_name']} ({target_path})")
    print(f"[+] Output: {ctx['output_dir']}")

    # Phase 1: X-Ray
    print_phase(1, "X-RAY", "Extracting logic blueprint (the 'Bone')")

    result = extract_logic({
        "target_path": target_path,
        "output_dir": ctx["output_dir"],
        "lpp_root": ctx["lpp_root"]
    })

    if result.get("error"):
        print(f"[!] X-Ray failed: {result['error']}")
        return False

    ctx["bone_json"] = result["bone_json"]
    ctx["bone_path"] = result["bone_path"]

    meta = ctx["bone_json"].get("_lvp_meta", {})
    print(f"[+] Logic blueprint extracted:")
    print(f"    - States: {len(ctx['bone_json'].get('states', {}))}")
    print(f"    - Transitions: {len(ctx['bone_json'].get('transitions', []))}")
    print(f"    - Functions: {len(meta.get('functions', []))}")
    print(f"    - Source lines: {meta.get('source_lines', 0)}")
    print(f"[+] Saved to: {ctx['bone_path']}")

    if xray_only:
        print("\n[*] X-Ray complete. Exiting (--xray mode).")
        return True

    # Phase 2: Threat Model
    print_phase(2, "THREAT MODEL", "Defining safety invariants")

    result = define_invariants({
        "bone_json": ctx["bone_json"],
        "target_name": ctx["target_name"],
        "api_key": ctx.get("api_key", ""),
        "api_base": ctx.get("api_base", ""),
        "model": ctx.get("model", "gpt-4"),
        "output_dir": ctx["output_dir"]
    })

    if result.get("error"):
        print(f"[!] Threat modeling failed: {result['error']}")
        return False

    ctx["invariants"] = result["invariants"]
    ctx["threat_model"] = result["threat_model"]

    print(f"[+] Defined {len(ctx['invariants'])} safety invariants:")
    for inv in ctx["invariants"][:5]:  # Show first 5
        print(f"    - [{inv.get('severity', '?').upper():8}] {inv.get('name', 'Unknown')}")
    if len(ctx["invariants"]) > 5:
        print(f"    ... and {len(ctx['invariants']) - 5} more")

    if threat_only:
        print("\n[*] Threat model complete. Exiting (--threat mode).")
        return True

    # Phase 3: Stress Test
    print_phase(3, "STRESS TEST", "Running TLC model checker")

    result = generate_tla({
        "bone_json": ctx["bone_json"],
        "invariants": ctx["invariants"],
        "output_dir": ctx["output_dir"],
        "lpp_root": ctx["lpp_root"]
    })

    if result.get("error"):
        print(f"[!] TLA+ generation failed: {result['error']}")
        return False

    ctx["tla_spec"] = result["tla_spec"]
    ctx["tla_path"] = result["tla_path"]
    print(f"[+] TLA+ spec generated: {ctx['tla_path']}")

    result = run_tlc({
        "tla_path": ctx["tla_path"],
        "tla_spec": ctx["tla_spec"],
        "invariants": ctx["invariants"],
        "output_dir": ctx["output_dir"],
        "lpp_root": ctx["lpp_root"],
        "bone_json": ctx["bone_json"]
    })

    ctx["tlc_result"] = result["tlc_result"]
    ctx["counter_examples"] = result["counter_examples"]
    ctx["vulnerability_count"] = result["vulnerability_count"]

    status = ctx["tlc_result"].get("status", "unknown")
    print(f"[+] TLC status: {status}")

    if ctx["vulnerability_count"] == 0:
        print("\n[+] No vulnerabilities found! Target passed stress test.")

        result = generate_secure_report({
            "target_name": ctx["target_name"],
            "target_path": target_path,
            "bone_json": ctx["bone_json"],
            "invariants": ctx["invariants"],
            "output_dir": ctx["output_dir"],
            "run_id": ctx["run_id"]
        })

        print(f"\n[+] VERDICT: SECURE")
        print(f"[+] Report saved to: {ctx['output_dir']}")
        return True

    # Vulnerabilities found!
    print(f"\n[!] VULNERABILITIES FOUND: {ctx['vulnerability_count']}")

    # Analyze traces
    result = analyze_traces({
        "counter_examples": ctx["counter_examples"],
        "bone_json": ctx["bone_json"],
        "threat_model": ctx["threat_model"],
        "api_key": ctx.get("api_key", ""),
        "api_base": ctx.get("api_base", ""),
        "model": ctx.get("model", "gpt-4")
    })

    ctx["counter_examples"] = result["counter_examples"]
    ctx["severity_score"] = result["severity_score"]

    print(f"[+] Severity Score: {ctx['severity_score']}/10")

    for ce in ctx["counter_examples"]:
        print(f"\n    [{ce.get('severity', '?').upper():8}] {ce.get('id')}: {ce.get('invariant_name')}")
        print(f"        Attack: {ce.get('attack_vector', 'Unknown')}")

    # Phase 4: Exploit Gen
    print_phase(4, "EXPLOIT GEN", "Generating Python trigger scripts")

    result = generate_exploits({
        "counter_examples": ctx["counter_examples"],
        "bone_json": ctx["bone_json"],
        "target_path": target_path,
        "target_name": ctx["target_name"],
        "output_dir": ctx["output_dir"],
        "api_key": ctx.get("api_key", ""),
        "api_base": ctx.get("api_base", ""),
        "model": ctx.get("model", "gpt-4")
    })

    ctx["exploits"] = result["exploits"]
    ctx["exploit_paths"] = result["exploit_paths"]

    print(f"[+] Generated {len(ctx['exploits'])} PoC scripts:")
    for exp in ctx["exploits"]:
        print(f"    - {exp.get('id')}: {exp.get('path')}")

    if ctx["exploit_paths"]:
        print(f"\n[+] Run all exploits: python {ctx['exploit_paths'][-1]}")

    if not auto_fix:
        print("\n[*] Skipping auto-fix (--no-fix mode).")

        result = generate_report({
            "target_name": ctx["target_name"],
            "target_path": target_path,
            "bone_json": ctx["bone_json"],
            "threat_model": ctx["threat_model"],
            "invariants": ctx["invariants"],
            "counter_examples": ctx["counter_examples"],
            "vulnerability_count": ctx["vulnerability_count"],
            "exploits": ctx["exploits"],
            "patches": [],
            "fix_verified": False,
            "severity_score": ctx["severity_score"],
            "output_dir": ctx["output_dir"],
            "run_id": ctx["run_id"]
        })

        print(f"\n[!] VERDICT: {result['audit_report']['summary']['verdict']}")
        print(f"[+] Report saved to: {ctx['output_dir']}")
        return True

    # Phase 5: The Fix
    print_phase(5, "THE FIX", "Re-machining logic with missing gates")

    result = generate_patches({
        "counter_examples": ctx["counter_examples"],
        "bone_json": ctx["bone_json"],
        "invariants": ctx["invariants"],
        "api_key": ctx.get("api_key", ""),
        "api_base": ctx.get("api_base", ""),
        "model": ctx.get("model", "gpt-4"),
        "output_dir": ctx["output_dir"]
    })

    ctx["patches"] = result["patches"]
    ctx["patched_json"] = result["patched_json"]

    print(f"[+] Generated {len(ctx['patches'])} patches:")
    for patch in ctx["patches"]:
        print(f"    - {patch.get('id')}: {patch.get('description')}")

    # Verify fix
    print("\n[*] Verifying fix with formal proof...")

    result = verify_fix_tlaps({
        "patched_json": ctx["patched_json"],
        "invariants": ctx["invariants"],
        "output_dir": ctx["output_dir"],
        "lpp_root": ctx["lpp_root"]
    })

    ctx["fix_verified"] = result["fix_verified"]

    if ctx["fix_verified"]:
        print("[+] Fix VERIFIED - All invariants now hold!")
    else:
        print("[!] Fix incomplete - Some vulnerabilities remain")

    # Generate final report
    result = generate_report({
        "target_name": ctx["target_name"],
        "target_path": target_path,
        "bone_json": ctx["bone_json"],
        "threat_model": ctx["threat_model"],
        "invariants": ctx["invariants"],
        "counter_examples": ctx["counter_examples"],
        "vulnerability_count": ctx["vulnerability_count"],
        "exploits": ctx["exploits"],
        "patches": ctx["patches"],
        "fix_verified": ctx["fix_verified"],
        "severity_score": ctx["severity_score"],
        "output_dir": ctx["output_dir"],
        "run_id": ctx["run_id"]
    })

    verdict = result["audit_report"]["summary"]["verdict"]

    print(f"\n{'═' * 60}")
    print(f"  LVP AUDIT COMPLETE")
    print(f"{'═' * 60}")
    print(f"\n  VERDICT: {verdict}")
    print(f"  Severity: {ctx['severity_score']}/10")
    print(f"  Vulnerabilities: {ctx['vulnerability_count']}")
    print(f"  Exploits: {len(ctx['exploits'])}")
    print(f"  Patches: {len(ctx['patches'])}")
    print(f"  Fix Verified: {'Yes' if ctx['fix_verified'] else 'No'}")
    print(f"\n  Full report: {ctx['output_dir']}/lvp_report.md")
    print(f"{'═' * 60}\n")

    return True


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="L++ Logic Vulnerability Pointer - NDT for software logic",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python interactive.py myapp.py              # Full security audit
  python interactive.py myapp.py --xray       # Only extract logic blueprint
  python interactive.py myapp.py --threat     # Stop after threat modeling
  python interactive.py myapp.py --no-fix     # Skip auto-fix generation
  python interactive.py myapp.py -v           # Verbose output
        """
    )

    parser.add_argument("target", help="Target Python file to audit")
    parser.add_argument("--xray", action="store_true", help="Only extract logic (Phase 1)")
    parser.add_argument("--threat", action="store_true", help="Stop after threat model (Phase 2)")
    parser.add_argument("--no-fix", action="store_true", help="Skip auto-fix generation")
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose output")

    args = parser.parse_args()

    # Validate target
    if not os.path.exists(args.target):
        print(f"Error: Target not found: {args.target}")
        sys.exit(1)

    print_banner()

    success = run_audit(
        target_path=os.path.abspath(args.target),
        xray_only=args.xray,
        threat_only=args.threat,
        auto_fix=not args.no_fix,
        verbose=args.verbose
    )

    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
