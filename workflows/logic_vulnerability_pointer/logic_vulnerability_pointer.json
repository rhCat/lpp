{
  "$schema": "lpp/v0.2.0",
  "id": "logic_vulnerability_pointer",
  "name": "Logic Vulnerability Pointer (LVP)",
  "version": "1.0.0",
  "description": "Non-Destructive Testing (NDT) for software logic. Like X-rays for turbine blades, LVP finds 'logic cracks' in Python applications by: (1) X-Ray: extracting logic blueprints, (2) Threat Model: defining safety invariants, (3) Stress Test: running TLC to find counter-examples, (4) Exploit Gen: converting traces to trigger scripts, (5) The Fix: re-machining logic with TLAPS immunity seals.",
  "context_schema": {
    "properties": {
      "target_path": {
        "type": "string",
        "description": "Path to target Python file/project to audit"
      },
      "target_name": {
        "type": "string",
        "description": "Name of the target for reports"
      },
      "output_dir": {
        "type": "string",
        "description": "Directory for audit artifacts"
      },
      "run_id": {
        "type": "string",
        "description": "Unique audit run identifier"
      },
      "bone_json": {
        "type": "object",
        "description": "Phase 1: Extracted logic blueprint (the 'Bone')"
      },
      "bone_path": {
        "type": "string",
        "description": "Path to saved bone JSON file"
      },
      "extraction_error": {
        "type": "string",
        "description": "Error during logic extraction"
      },
      "invariants": {
        "type": "array",
        "description": "Phase 2: Safety invariants to verify"
      },
      "threat_model": {
        "type": "object",
        "description": "Threat model with attack vectors and invariants"
      },
      "invariant_count": {
        "type": "number",
        "description": "Number of invariants defined"
      },
      "tla_spec": {
        "type": "string",
        "description": "Phase 3: Generated TLA+ specification"
      },
      "tla_path": {
        "type": "string",
        "description": "Path to TLA+ spec file"
      },
      "tlc_result": {
        "type": "object",
        "description": "TLC model checker result"
      },
      "counter_examples": {
        "type": "array",
        "description": "Counter-example traces found by TLC"
      },
      "vulnerability_count": {
        "type": "number",
        "description": "Number of vulnerabilities found"
      },
      "exploits": {
        "type": "array",
        "description": "Phase 4: Generated exploit/trigger scripts"
      },
      "exploit_paths": {
        "type": "array",
        "description": "Paths to exploit script files"
      },
      "poc_generated": {
        "type": "boolean",
        "description": "True if PoC scripts were generated"
      },
      "patches": {
        "type": "array",
        "description": "Phase 5: Suggested patches"
      },
      "patched_json": {
        "type": "object",
        "description": "Patched logic blueprint with gates"
      },
      "tlaps_proof": {
        "type": "string",
        "description": "TLAPS proof of fix correctness"
      },
      "fix_verified": {
        "type": "boolean",
        "description": "True if fix passed TLAPS verification"
      },
      "audit_report": {
        "type": "object",
        "description": "Final audit report"
      },
      "severity_score": {
        "type": "number",
        "description": "Overall severity score 0-10"
      },
      "phase": {
        "type": "string",
        "description": "Current audit phase: xray|threat|stress|exploit|fix"
      },
      "error": {
        "type": "string",
        "description": "Error message if any"
      },
      "api_key": {
        "type": "string",
        "description": "LLM API key for threat modeling"
      },
      "api_base": {
        "type": "string",
        "description": "LLM API base URL"
      },
      "model": {
        "type": "string",
        "description": "LLM model identifier"
      },
      "lpp_root": {
        "type": "string",
        "description": "Root path of L++ framework"
      },
      "auto_fix": {
        "type": "boolean",
        "description": "Auto-generate fixes if vulnerabilities found"
      }
    }
  },
  "states": {
    "idle": {
      "description": "Awaiting target for security audit"
    },
    "xray": {
      "description": "Phase 1: X-Ray - Extracting logic blueprint from target"
    },
    "threat_modeling": {
      "description": "Phase 2: Threat Model - Defining safety invariants with LLM"
    },
    "stress_testing": {
      "description": "Phase 3: Stress Test - Running TLC model checker"
    },
    "analyzing_traces": {
      "description": "Analyzing counter-example traces for exploitability"
    },
    "exploit_generation": {
      "description": "Phase 4: Exploit Gen - Converting traces to trigger scripts"
    },
    "generating_fix": {
      "description": "Phase 5: The Fix - Re-machining logic with missing gates"
    },
    "verifying_fix": {
      "description": "Verifying fix with TLAPS proof"
    },
    "reporting": {
      "description": "Generating final audit report"
    },
    "complete": {
      "description": "Audit complete - vulnerabilities cataloged"
    },
    "secure": {
      "description": "Target passed all checks - no vulnerabilities found"
    },
    "error": {
      "description": "Audit error occurred"
    }
  },
  "entry_state": "idle",
  "terminal_states": {
    "complete": {},
    "secure": {},
    "error": {}
  },
  "gates": {
    "has_target": {
      "type": "expression",
      "expression": "target_path is not None"
    },
    "no_target": {
      "type": "expression",
      "expression": "target_path is None"
    },
    "has_bone": {
      "type": "expression",
      "expression": "bone_json is not None"
    },
    "no_bone": {
      "type": "expression",
      "expression": "bone_json is None"
    },
    "has_invariants": {
      "type": "expression",
      "expression": "invariants is not None"
    },
    "no_invariants": {
      "type": "expression",
      "expression": "invariants is None"
    },
    "has_tla": {
      "type": "expression",
      "expression": "tla_spec is not None"
    },
    "has_counter_examples": {
      "type": "expression",
      "expression": "counter_examples is not None"
    },
    "no_counter_examples": {
      "type": "expression",
      "expression": "counter_examples is None"
    },
    "has_exploits": {
      "type": "expression",
      "expression": "exploits is not None"
    },
    "has_patches": {
      "type": "expression",
      "expression": "patches is not None"
    },
    "fix_verified": {
      "type": "expression",
      "expression": "fix_verified == True"
    },
    "fix_not_verified": {
      "type": "expression",
      "expression": "fix_verified != True"
    },
    "auto_fix_enabled": {
      "type": "expression",
      "expression": "auto_fix == True"
    },
    "auto_fix_disabled": {
      "type": "expression",
      "expression": "auto_fix != True"
    },
    "has_error": {
      "type": "expression",
      "expression": "error is not None"
    },
    "no_error": {
      "type": "expression",
      "expression": "error is None"
    },
    "high_severity": {
      "type": "expression",
      "expression": "severity_score is not None and severity_score >= 7"
    },
    "low_severity": {
      "type": "expression",
      "expression": "severity_score is None or severity_score < 7"
    }
  },
  "actions": {
    "init": {
      "type": "compute",
      "compute_unit": "lvp:init",
      "input_map": {},
      "output_map": {
        "run_id": "run_id",
        "output_dir": "output_dir",
        "phase": "phase",
        "lpp_root": "lpp_root",
        "api_key": "api_key",
        "api_base": "api_base",
        "model": "model",
        "auto_fix": "auto_fix"
      }
    },
    "set_target": {
      "type": "set",
      "target": "target_path",
      "value_from": "event.payload.target_path"
    },
    "set_target_name": {
      "type": "compute",
      "compute_unit": "lvp:set_target_name",
      "input_map": {
        "target_path": "target_path"
      },
      "output_map": {
        "target_name": "target_name"
      }
    },
    "extract_logic": {
      "type": "compute",
      "compute_unit": "lvp:extract_logic",
      "input_map": {
        "target_path": "target_path",
        "output_dir": "output_dir",
        "lpp_root": "lpp_root"
      },
      "output_map": {
        "bone_json": "bone_json",
        "bone_path": "bone_path",
        "error": "error"
      }
    },
    "set_phase_xray": {
      "type": "set",
      "target": "phase",
      "value": "xray"
    },
    "define_invariants": {
      "type": "compute",
      "compute_unit": "lvp:define_invariants",
      "input_map": {
        "bone_json": "bone_json",
        "target_name": "target_name",
        "api_key": "api_key",
        "api_base": "api_base",
        "model": "model",
        "output_dir": "output_dir"
      },
      "output_map": {
        "invariants": "invariants",
        "threat_model": "threat_model",
        "invariant_count": "invariant_count",
        "error": "error"
      }
    },
    "set_phase_threat": {
      "type": "set",
      "target": "phase",
      "value": "threat"
    },
    "generate_tla": {
      "type": "compute",
      "compute_unit": "lvp:generate_tla",
      "input_map": {
        "bone_json": "bone_json",
        "invariants": "invariants",
        "output_dir": "output_dir",
        "lpp_root": "lpp_root"
      },
      "output_map": {
        "tla_spec": "tla_spec",
        "tla_path": "tla_path",
        "error": "error"
      }
    },
    "run_tlc": {
      "type": "compute",
      "compute_unit": "lvp:run_tlc",
      "input_map": {
        "tla_path": "tla_path",
        "tla_spec": "tla_spec",
        "invariants": "invariants",
        "output_dir": "output_dir",
        "lpp_root": "lpp_root"
      },
      "output_map": {
        "tlc_result": "tlc_result",
        "counter_examples": "counter_examples",
        "vulnerability_count": "vulnerability_count",
        "error": "error"
      }
    },
    "set_phase_stress": {
      "type": "set",
      "target": "phase",
      "value": "stress"
    },
    "analyze_traces": {
      "type": "compute",
      "compute_unit": "lvp:analyze_traces",
      "input_map": {
        "counter_examples": "counter_examples",
        "bone_json": "bone_json",
        "threat_model": "threat_model",
        "api_key": "api_key",
        "api_base": "api_base",
        "model": "model"
      },
      "output_map": {
        "counter_examples": "counter_examples",
        "severity_score": "severity_score",
        "error": "error"
      }
    },
    "generate_exploits": {
      "type": "compute",
      "compute_unit": "lvp:generate_exploits",
      "input_map": {
        "counter_examples": "counter_examples",
        "bone_json": "bone_json",
        "target_path": "target_path",
        "target_name": "target_name",
        "output_dir": "output_dir",
        "api_key": "api_key",
        "api_base": "api_base",
        "model": "model"
      },
      "output_map": {
        "exploits": "exploits",
        "exploit_paths": "exploit_paths",
        "poc_generated": "poc_generated",
        "error": "error"
      }
    },
    "set_phase_exploit": {
      "type": "set",
      "target": "phase",
      "value": "exploit"
    },
    "generate_patches": {
      "type": "compute",
      "compute_unit": "lvp:generate_patches",
      "input_map": {
        "counter_examples": "counter_examples",
        "bone_json": "bone_json",
        "invariants": "invariants",
        "api_key": "api_key",
        "api_base": "api_base",
        "model": "model",
        "output_dir": "output_dir"
      },
      "output_map": {
        "patches": "patches",
        "patched_json": "patched_json",
        "error": "error"
      }
    },
    "set_phase_fix": {
      "type": "set",
      "target": "phase",
      "value": "fix"
    },
    "verify_fix_tlaps": {
      "type": "compute",
      "compute_unit": "lvp:verify_fix_tlaps",
      "input_map": {
        "patched_json": "patched_json",
        "invariants": "invariants",
        "output_dir": "output_dir",
        "lpp_root": "lpp_root"
      },
      "output_map": {
        "tlaps_proof": "tlaps_proof",
        "fix_verified": "fix_verified",
        "error": "error"
      }
    },
    "generate_report": {
      "type": "compute",
      "compute_unit": "lvp:generate_report",
      "input_map": {
        "target_name": "target_name",
        "target_path": "target_path",
        "bone_json": "bone_json",
        "threat_model": "threat_model",
        "invariants": "invariants",
        "counter_examples": "counter_examples",
        "vulnerability_count": "vulnerability_count",
        "exploits": "exploits",
        "patches": "patches",
        "fix_verified": "fix_verified",
        "severity_score": "severity_score",
        "output_dir": "output_dir",
        "run_id": "run_id"
      },
      "output_map": {
        "audit_report": "audit_report",
        "error": "error"
      }
    },
    "generate_secure_report": {
      "type": "compute",
      "compute_unit": "lvp:generate_secure_report",
      "input_map": {
        "target_name": "target_name",
        "target_path": "target_path",
        "bone_json": "bone_json",
        "invariants": "invariants",
        "output_dir": "output_dir",
        "run_id": "run_id"
      },
      "output_map": {
        "audit_report": "audit_report"
      }
    },
    "capture_error": {
      "type": "compute",
      "compute_unit": "lvp:capture_error",
      "input_map": {
        "error": "error",
        "phase": "phase",
        "output_dir": "output_dir"
      },
      "output_map": {
        "audit_report": "audit_report"
      }
    },
    "clear_error": {
      "type": "set",
      "target": "error",
      "value": null
    }
  },
  "transitions": [
    {
      "id": "t_start",
      "from": "idle",
      "to": "idle",
      "on_event": "START",
      "gates": [
        "no_target"
      ],
      "actions": [
        "init"
      ]
    },
    {
      "id": "t_audit",
      "from": "idle",
      "to": "xray",
      "on_event": "AUDIT",
      "gates": [
        "has_target"
      ],
      "actions": [
        "set_target",
        "set_target_name",
        "set_phase_xray",
        "extract_logic"
      ]
    },
    {
      "id": "t_audit_no_target",
      "from": "idle",
      "to": "error",
      "on_event": "AUDIT",
      "gates": [
        "no_target"
      ],
      "actions": []
    },
    {
      "id": "t_xray_done",
      "from": "xray",
      "to": "threat_modeling",
      "on_event": "DONE",
      "gates": [
        "has_bone",
        "no_error"
      ],
      "actions": [
        "set_phase_threat",
        "define_invariants"
      ]
    },
    {
      "id": "t_xray_error",
      "from": "xray",
      "to": "error",
      "on_event": "DONE",
      "gates": [
        "has_error"
      ],
      "actions": [
        "capture_error"
      ]
    },
    {
      "id": "t_threat_done",
      "from": "threat_modeling",
      "to": "stress_testing",
      "on_event": "DONE",
      "gates": [
        "has_invariants",
        "no_error"
      ],
      "actions": [
        "set_phase_stress",
        "generate_tla",
        "run_tlc"
      ]
    },
    {
      "id": "t_threat_error",
      "from": "threat_modeling",
      "to": "error",
      "on_event": "DONE",
      "gates": [
        "has_error"
      ],
      "actions": [
        "capture_error"
      ]
    },
    {
      "id": "t_stress_vuln_found",
      "from": "stress_testing",
      "to": "analyzing_traces",
      "on_event": "DONE",
      "gates": [
        "has_counter_examples",
        "no_error"
      ],
      "actions": [
        "analyze_traces"
      ]
    },
    {
      "id": "t_stress_secure",
      "from": "stress_testing",
      "to": "secure",
      "on_event": "DONE",
      "gates": [
        "no_counter_examples",
        "no_error"
      ],
      "actions": [
        "generate_secure_report"
      ]
    },
    {
      "id": "t_stress_error",
      "from": "stress_testing",
      "to": "error",
      "on_event": "DONE",
      "gates": [
        "has_error"
      ],
      "actions": [
        "capture_error"
      ]
    },
    {
      "id": "t_analyze_done",
      "from": "analyzing_traces",
      "to": "exploit_generation",
      "on_event": "DONE",
      "gates": [
        "no_error"
      ],
      "actions": [
        "set_phase_exploit",
        "generate_exploits"
      ]
    },
    {
      "id": "t_analyze_error",
      "from": "analyzing_traces",
      "to": "error",
      "on_event": "DONE",
      "gates": [
        "has_error"
      ],
      "actions": [
        "capture_error"
      ]
    },
    {
      "id": "t_exploit_to_fix",
      "from": "exploit_generation",
      "to": "generating_fix",
      "on_event": "DONE",
      "gates": [
        "has_exploits",
        "auto_fix_enabled",
        "no_error"
      ],
      "actions": [
        "set_phase_fix",
        "generate_patches"
      ]
    },
    {
      "id": "t_exploit_to_report",
      "from": "exploit_generation",
      "to": "reporting",
      "on_event": "DONE",
      "gates": [
        "has_exploits",
        "auto_fix_disabled",
        "no_error"
      ],
      "actions": [
        "generate_report"
      ]
    },
    {
      "id": "t_exploit_error",
      "from": "exploit_generation",
      "to": "error",
      "on_event": "DONE",
      "gates": [
        "has_error"
      ],
      "actions": [
        "capture_error"
      ]
    },
    {
      "id": "t_fix_verify",
      "from": "generating_fix",
      "to": "verifying_fix",
      "on_event": "DONE",
      "gates": [
        "has_patches",
        "no_error"
      ],
      "actions": [
        "verify_fix_tlaps"
      ]
    },
    {
      "id": "t_fix_error",
      "from": "generating_fix",
      "to": "reporting",
      "on_event": "DONE",
      "gates": [
        "has_error"
      ],
      "actions": [
        "clear_error",
        "generate_report"
      ]
    },
    {
      "id": "t_verify_done",
      "from": "verifying_fix",
      "to": "reporting",
      "on_event": "DONE",
      "gates": [
        "no_error"
      ],
      "actions": [
        "generate_report"
      ]
    },
    {
      "id": "t_verify_error",
      "from": "verifying_fix",
      "to": "reporting",
      "on_event": "DONE",
      "gates": [
        "has_error"
      ],
      "actions": [
        "clear_error",
        "generate_report"
      ]
    },
    {
      "id": "t_report_done",
      "from": "reporting",
      "to": "complete",
      "on_event": "DONE",
      "gates": [
        "no_error"
      ]
    },
    {
      "id": "t_report_error",
      "from": "reporting",
      "to": "error",
      "on_event": "DONE",
      "gates": [
        "has_error"
      ],
      "actions": [
        "capture_error"
      ]
    },
    {
      "id": "t_reset",
      "from": "*",
      "to": "idle",
      "on_event": "RESET"
    },
    {
      "id": "t_error_retry",
      "from": "error",
      "to": "idle",
      "on_event": "RETRY",
      "actions": [
        "clear_error"
      ]
    }
  ],
  "display": {
    "rules": [
      {
        "gate": "has_counter_examples",
        "template": "VULNERABILITIES FOUND: {vulnerability_count} logic cracks detected (Severity: {severity_score}/10)"
      },
      {
        "gate": "has_exploits",
        "template": "EXPLOIT GEN: {exploits} PoC trigger scripts generated"
      },
      {
        "gate": "fix_verified",
        "template": "FIX VERIFIED: TLAPS proof confirms immunity"
      },
      {
        "gate": "no_counter_examples",
        "template": "SECURE: No logic vulnerabilities found - target passed NDT"
      },
      {
        "gate": "has_error",
        "template": "ERROR in phase {phase}: {error}"
      },
      {
        "gate": "has_bone",
        "template": "X-RAY COMPLETE: Logic blueprint extracted"
      },
      {
        "gate": "has_invariants",
        "template": "THREAT MODEL: {invariant_count} safety invariants defined"
      },
      {
        "template": "LVP Ready - Submit target for security audit"
      }
    ]
  }
}