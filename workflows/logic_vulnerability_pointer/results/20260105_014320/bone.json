{
  "$schema": "lpp/v0.1",
  "id": "decoded_lvp_compute",
  "name": "Decoded: lvp_compute",
  "version": "1.0.0",
  "description": "Auto-decoded from /Users/ruihe/mnt/lpp/lpp/workflows/logic_vulnerability_pointer/src/lvp_compute.py",
  "context_schema": {
    "properties": {
      "error": {
        "type": "string"
      },
      "result": {
        "type": "object"
      },
      "THREAT_MODEL_PROMPT": {
        "type": "string",
        "default": "You are a security auditor analyzing a software logic blueprint.\n\nBLUEPRINT:\n{blueprint}\n\nSOURCE METADATA:\n- Functions: {functions}\n- Classes: {classes}\n- Control Patterns: {patterns}\n\nYour task is to identify SAFETY INVARIANTS - properties that must ALWAYS hold true.\nThink about what could go wrong. Consider:\n\n1. AUTHORIZATION BYPASSES: Can privileged actions be reached without proper checks?\n   Example: \"Agent must never reach execute_refund without manager_approval == True\"\n\n2. STATE CORRUPTION: Can the system reach invalid states?\n   Example: \"order_status cannot be 'shipped' while payment_status is 'pending'\"\n\n3. RESOURCE LEAKS: Can resources be allocated without being freed?\n   Example: \"connection_count must eventually return to 0\"\n\n4. INFINITE LOOPS: Can the system get stuck in non-terminal states?\n   Example: \"From any state, complete or error must eventually be reachable\"\n\n5. RACE CONDITIONS: Can concurrent operations cause conflicts?\n   Example: \"balance cannot go negative\"\n\n6. INPUT VALIDATION: Can malicious inputs bypass validation?\n   Example: \"user_input must be sanitized before execute_query\"\n\nOutput your analysis as JSON:\n{{\n  \"invariants\": [\n    {{\n      \"id\": \"INV_001\",\n      \"name\": \"Human-readable name\",\n      \"description\": \"What this invariant protects against\",\n      \"tla_expression\": \"TLA+ expression (e.g., state = \\\"privileged\\\" => approved = TRUE)\",\n      \"severity\": \"critical|high|medium|low\",\n      \"attack_vector\": \"How an attacker might try to violate this\"\n    }}\n  ],\n  \"threat_model\": {{\n    \"assets\": [\"List of valuable assets/operations to protect\"],\n    \"threats\": [\"List of potential threats identified\"],\n    \"attack_surface\": [\"Entry points that could be exploited\"]\n  }}\n}}\n\nGenerate at least 5 invariants, focusing on the most critical security properties first.\n"
      },
      "EXPLOIT_TEMPLATE": {
        "type": "string",
        "default": "#!/usr/bin/env python3\n\"\"\"\nLVP Exploit PoC: {exploit_id}\nTarget: {target_name}\nVulnerability: {vulnerability}\nSeverity: {severity}\n\nThis script demonstrates the logic vulnerability by triggering\nthe exact sequence of events that violates the safety invariant.\n\nDISCLAIMER: This is a Proof-of-Concept for authorized security testing only.\n\"\"\"\n\nimport sys\nimport json\nfrom pathlib import Path\n\n# Add target to path\nsys.path.insert(0, str(Path(__file__).parent.parent))\n\n{imports}\n\nclass ExploitPoC:\n    \"\"\"\n    Proof of Concept for: {vulnerability}\n\n    Attack Vector: {attack_vector}\n    \"\"\"\n\n    def __init__(self):\n        self.name = \"{exploit_id}\"\n        self.target = \"{target_name}\"\n        self.steps_executed = []\n\n    def setup(self):\n        \"\"\"Initialize the target in a known state.\"\"\"\n        print(f\"[*] Setting up exploit: {{self.name}}\")\n        {setup_code}\n\n    def execute(self):\n        \"\"\"\n        Execute the attack sequence.\n\n        Trace:\n{trace_comment}\n        \"\"\"\n        print(f\"[*] Executing attack sequence...\")\n\n{attack_code}\n\n        print(f\"[+] Attack sequence complete\")\n        return self.verify()\n\n    def verify(self):\n        \"\"\"Verify the invariant was violated.\"\"\"\n        print(f\"[*] Verifying vulnerability...\")\n        {verify_code}\n\n    def cleanup(self):\n        \"\"\"Clean up after exploit.\"\"\"\n        print(f\"[*] Cleaning up...\")\n        {cleanup_code}\n\n    def run(self):\n        \"\"\"Run the complete PoC.\"\"\"\n        print(\"=\" * 60)\n        print(f\"LVP Exploit PoC: {{self.name}}\")\n        print(f\"Target: {{self.target}}\")\n        print(\"=\" * 60)\n\n        try:\n            self.setup()\n            result = self.execute()\n            if result:\n                print(f\"[+] VULNERABLE: Invariant violation confirmed\")\n            else:\n                print(f\"[-] NOT VULNERABLE: Invariant held\")\n            return result\n        except Exception as e:\n            print(f\"[!] Exploit failed: {{e}}\")\n            return False\n        finally:\n            self.cleanup()\n\n\nif __name__ == \"__main__\":\n    poc = ExploitPoC()\n    success = poc.run()\n    sys.exit(0 if success else 1)\n"
      },
      "COMPUTE_REGISTRY": {
        "type": "object",
        "default": {
          "lvp:init": "$init",
          "lvp:set_target_name": "$set_target_name",
          "lvp:extract_logic": "$extract_logic",
          "lvp:define_invariants": "$define_invariants",
          "lvp:generate_tla": "$generate_tla",
          "lvp:run_tlc": "$run_tlc",
          "lvp:analyze_traces": "$analyze_traces",
          "lvp:generate_exploits": "$generate_exploits",
          "lvp:generate_patches": "$generate_patches",
          "lvp:verify_fix_tlaps": "$verify_fix_tlaps",
          "lvp:generate_report": "$generate_report",
          "lvp:generate_secure_report": "$generate_secure_report",
          "lvp:capture_error": "$capture_error"
        }
      }
    }
  },
  "states": {
    "idle": {
      "name": "Idle",
      "description": "Initial state"
    },
    "initializing": {
      "name": "Initializing",
      "description": "From function: init"
    },
    "loading": {
      "name": "Loading",
      "description": "From function: set_target_name"
    },
    "analyzing": {
      "name": "Analyzing",
      "description": "From function: extract_logic"
    },
    "define-invariants": {
      "name": "Define Invariants",
      "description": "From function: define_invariants"
    },
    "generating": {
      "name": "Generating",
      "description": "From function: generate_tla"
    },
    "processing": {
      "name": "Processing",
      "description": "From function: run_tlc"
    },
    "validating": {
      "name": "Validating",
      "description": "From function: verify_fix_tlaps"
    },
    "error": {
      "name": "Error",
      "description": "From function: capture_error"
    },
    "complete": {
      "name": "Complete",
      "description": "Terminal state"
    }
  },
  "transitions": [
    {
      "id": "t0",
      "from": "idle",
      "to": "initializing",
      "on_event": "IDLE_DONE"
    },
    {
      "id": "t1",
      "from": "initializing",
      "to": "loading",
      "on_event": "INITIALIZING_DONE"
    },
    {
      "id": "t2",
      "from": "loading",
      "to": "analyzing",
      "on_event": "LOADING_DONE"
    },
    {
      "id": "t3",
      "from": "analyzing",
      "to": "define-invariants",
      "on_event": "ANALYZING_DONE"
    },
    {
      "id": "t4",
      "from": "define-invariants",
      "to": "generating",
      "on_event": "DEFINE-INVARIANTS_DONE"
    },
    {
      "id": "t5",
      "from": "generating",
      "to": "processing",
      "on_event": "GENERATING_DONE"
    },
    {
      "id": "t6",
      "from": "processing",
      "to": "validating",
      "on_event": "PROCESSING_DONE"
    },
    {
      "id": "t7",
      "from": "validating",
      "to": "error",
      "on_event": "VALIDATING_DONE"
    },
    {
      "id": "t8",
      "from": "error",
      "to": "complete",
      "on_event": "ERROR_DONE"
    },
    {
      "id": "t9",
      "from": "idle",
      "to": "error",
      "on_event": "ERROR",
      "gates": [
        "g0"
      ]
    },
    {
      "id": "t10",
      "from": "initializing",
      "to": "error",
      "on_event": "ERROR",
      "gates": [
        "g0"
      ]
    },
    {
      "id": "t11",
      "from": "loading",
      "to": "error",
      "on_event": "ERROR",
      "gates": [
        "g0"
      ]
    },
    {
      "id": "t12",
      "from": "analyzing",
      "to": "error",
      "on_event": "ERROR",
      "gates": [
        "g0"
      ]
    },
    {
      "id": "t13",
      "from": "define-invariants",
      "to": "error",
      "on_event": "ERROR",
      "gates": [
        "g0"
      ]
    },
    {
      "id": "t14",
      "from": "generating",
      "to": "error",
      "on_event": "ERROR",
      "gates": [
        "g0"
      ]
    },
    {
      "id": "t15",
      "from": "processing",
      "to": "error",
      "on_event": "ERROR",
      "gates": [
        "g0"
      ]
    },
    {
      "id": "t16",
      "from": "validating",
      "to": "error",
      "on_event": "ERROR",
      "gates": [
        "g0"
      ]
    },
    {
      "id": "t17",
      "from": "*",
      "to": "idle",
      "on_event": "RESET"
    }
  ],
  "gates": {
    "g0": {
      "type": "expression",
      "expression": "error is not None"
    }
  },
  "actions": {
    "a0": {
      "type": "compute",
      "compute_unit": "impl:datetime.now.strftime",
      "description": "Inferred from function:init"
    },
    "a1": {
      "type": "compute",
      "compute_unit": "impl:datetime.now",
      "description": "Inferred from function:init"
    },
    "a2": {
      "type": "compute",
      "compute_unit": "impl:os.environ.get",
      "description": "Inferred from function:init"
    },
    "a3": {
      "type": "compute",
      "compute_unit": "impl:Path.resolve",
      "description": "Inferred from function:init"
    },
    "a4": {
      "type": "compute",
      "compute_unit": "impl:Path",
      "description": "Inferred from function:init"
    },
    "a5": {
      "type": "compute",
      "compute_unit": "impl:{'_type': 'BinOp', 'left': {'_type': 'BinOp', 'left': {'_type': 'Name', 'id': 'parent', 'ctx': {'_type': 'Load'}, 'lineno': 47}, 'op': {'_type': 'Div'}, 'right': {'_type': 'Constant', 'value': 'src', 'kind': None, 'lineno': 47}, 'lineno': 47}, 'op': {'_type': 'Div'}, 'right': {'_type': 'Constant', 'value': 'frame_py', 'kind': None, 'lineno': 47}, 'lineno': 47}.exists",
      "description": "Inferred from function:init"
    },
    "a6": {
      "type": "compute",
      "compute_unit": "impl:str",
      "description": "Inferred from function:init"
    },
    "a7": {
      "type": "compute",
      "compute_unit": "impl:os.path.join",
      "description": "Inferred from function:init"
    },
    "a8": {
      "type": "compute",
      "compute_unit": "impl:os.makedirs",
      "description": "Inferred from function:init"
    },
    "a14": {
      "type": "compute",
      "compute_unit": "impl:params.get",
      "description": "Inferred from function:set_target_name"
    },
    "a16": {
      "type": "compute",
      "compute_unit": "impl:re.sub",
      "description": "Inferred from function:set_target_name"
    },
    "a20": {
      "type": "compute",
      "compute_unit": "impl:os.path.exists",
      "description": "Inferred from function:extract_logic"
    },
    "a21": {
      "type": "compute",
      "compute_unit": "impl:sys.path.insert",
      "description": "Inferred from function:extract_logic"
    },
    "a22": {
      "type": "compute",
      "compute_unit": "impl:loadFile",
      "description": "Inferred from function:extract_logic"
    },
    "a23": {
      "type": "compute",
      "compute_unit": "impl:load_result.get",
      "description": "Inferred from function:extract_logic"
    },
    "a24": {
      "type": "compute",
      "compute_unit": "impl:parseAst",
      "description": "Inferred from function:extract_logic"
    },
    "a25": {
      "type": "compute",
      "compute_unit": "impl:ast_result.get",
      "description": "Inferred from function:extract_logic"
    },
    "a26": {
      "type": "compute",
      "compute_unit": "impl:analyzeImports",
      "description": "Inferred from function:extract_logic"
    },
    "a27": {
      "type": "compute",
      "compute_unit": "impl:imports_result.get",
      "description": "Inferred from function:extract_logic"
    },
    "a28": {
      "type": "compute",
      "compute_unit": "impl:analyzeFunctions",
      "description": "Inferred from function:extract_logic"
    }
  },
  "entry_state": "idle",
  "terminal_states": [
    "complete",
    "error"
  ],
  "_lvp_meta": {
    "source_path": "/Users/ruihe/mnt/lpp/lpp/workflows/logic_vulnerability_pointer/src/lvp_compute.py",
    "functions": [
      "init",
      "set_target_name",
      "extract_logic",
      "define_invariants",
      "generate_tla",
      "run_tlc",
      "analyze_traces",
      "generate_exploits",
      "generate_patches",
      "verify_fix_tlaps",
      "generate_report",
      "generate_secure_report",
      "capture_error"
    ],
    "classes": [],
    "imports": [
      "ast",
      "json",
      "os",
      "re",
      "subprocess",
      "sys",
      "tempfile",
      "datetime",
      "pathlib",
      "typing",
      "typing",
      "typing",
      "typing",
      "typing",
      "openai",
      "utils.logic_decoder.src.decoder_compute",
      "utils.logic_decoder.src.decoder_compute",
      "utils.logic_decoder.src.decoder_compute",
      "utils.logic_decoder.src.decoder_compute",
      "utils.logic_decoder.src.decoder_compute",
      "utils.logic_decoder.src.decoder_compute",
      "utils.logic_decoder.src.decoder_compute",
      "utils.logic_decoder.src.decoder_compute",
      "utils.logic_decoder.src.decoder_compute",
      "utils.logic_decoder.src.decoder_compute",
      "src.frame_py.tla_validator",
      "src.frame_py.tla_validator"
    ],
    "control_patterns": {
      "errorHandling": 1
    },
    "source_lines": 1595
  }
}