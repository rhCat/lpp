"""
Compute Unit Tests for lpp_canvas

Tests for the Python compute functions (feature implementation).
Generated by L++ Comprehensive Test Generator.
"""

import pytest
import sys
from pathlib import Path
from typing import Any, Dict

# Add project root to path
PROJECT_ROOT = Path(__file__).parent.parent.parent
sys.path.insert(0, str(PROJECT_ROOT))

# Import compute functions from discovered module
try:
    from workflows.lpp_canvas.src.canvas_compute import init_new, load_blueprint, select_node, apply_edit, delete_node, add_state, add_transition, add_gate, add_action, run_tlc, analyze_paths, init_simulation, sim_step, sim_dispatch, compute_clusters, start_review, add_note, add_audit, llm_query, apply_llm, generate_outputs, save_blueprint, clear_all
    COMPUTE_AVAILABLE = True
except ImportError as e:
    COMPUTE_AVAILABLE = False
    IMPORT_ERROR = str(e)


# =============================================================================
# Compute Unit Test Fixtures
# =============================================================================

@pytest.fixture
def mock_context():
    """Create a mock context with default values."""
    return {
        "blueprint": {},
        "blueprint_path": "",
        "blueprint_json": "",
        "is_dirty": False,
        "mode": "",
        "llm_enabled": False,
        "api_key": "",
        "api_base": "",
        "model": "",
        "prompt": "",
        "llm_response": "",
        "suggestions": [],
        "selected_node": "",
        "selected_type": "",
        "node_data": {},
        "edit_buffer": {},
        "tlc_result": {},
        "tlc_errors": [],
        "tlc_passed": False,
        "paths": [],
        "path_count": 0,
        "states_list": [],
        "state_count": 0,
        "reachability": {},
        "deadlocks": [],
        "sim_state": "",
        "sim_context": {},
        "sim_history": [],
        "sim_available_events": [],
        "sim_step_count": 0,
        "clusters": [],
        "dependencies": {},
        "sorted_states": [],
        "audit_log": [],
        "review_notes": [],
        "review_status": "",
        "coverage": {},
        "graph_html": "",
        "mermaid": "",
        "error": "",
    }


# =============================================================================
# Tests for compute unit: canvas:init_new
# =============================================================================

class TestCompute_InitNew:
    """Tests for canvas:init_new compute function."""

    def test_init_new_input_contract(self, mock_context):
        """Test that init_new validates required inputs."""
        inputs = {
        }

        # Verify inputs structure
        assert inputs is not None

        # Call actual compute function if available
        if COMPUTE_AVAILABLE:
            result = init_new(inputs)
            assert result is not None
            assert isinstance(result, dict)

    def test_init_new_output_contract(self, mock_context):
        """Test that init_new returns expected output fields."""
        expected_outputs = ['blueprint', 'blueprint_json', 'is_dirty', 'mode']

        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
        }

        result = init_new(inputs)
        assert result is not None

        # Verify expected outputs are present
        for field in expected_outputs:
            assert field in result, f"Missing output field: {field}"

    def test_init_new_error_handling(self, mock_context):
        """Test that init_new handles errors gracefully."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        # Test with empty inputs
        invalid_inputs = {}

        try:
            result = init_new(invalid_inputs)
            # Should either return error dict or handle gracefully
            if result is not None:
                assert isinstance(result, dict)
        except (KeyError, TypeError, ValueError):
            # Expected - function requires inputs
            pass


# =============================================================================
# Tests for compute unit: canvas:load_blueprint
# =============================================================================

class TestCompute_LoadBlueprint:
    """Tests for canvas:load_blueprint compute function."""

    def test_load_blueprint_input_contract(self, mock_context):
        """Test that load_blueprint validates required inputs."""
        inputs = {
            "path": mock_context.get("blueprint_path"),
        }

        # Verify inputs structure
        assert inputs is not None
        assert "path" in inputs

        # Call actual compute function if available
        if COMPUTE_AVAILABLE:
            result = load_blueprint(inputs)
            assert result is not None
            assert isinstance(result, dict)

    def test_load_blueprint_output_contract(self, mock_context):
        """Test that load_blueprint returns expected output fields."""
        expected_outputs = ['blueprint', 'blueprint_json', 'error']

        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "path": mock_context.get("blueprint_path"),
        }

        result = load_blueprint(inputs)
        assert result is not None

        # Verify expected outputs are present
        for field in expected_outputs:
            assert field in result, f"Missing output field: {field}"

    def test_load_blueprint_error_handling(self, mock_context):
        """Test that load_blueprint handles errors gracefully."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        # Test with empty inputs
        invalid_inputs = {}

        try:
            result = load_blueprint(invalid_inputs)
            # Should either return error dict or handle gracefully
            if result is not None:
                assert isinstance(result, dict)
        except (KeyError, TypeError, ValueError):
            # Expected - function requires inputs
            pass

    def test_load_blueprint_path_null(self, mock_context):
        """Test load_blueprint with null path."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "path": None,
        }

        try:
            result = load_blueprint(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - path is required
            pass


# =============================================================================
# Tests for compute unit: canvas:select_node
# =============================================================================

class TestCompute_SelectNode:
    """Tests for canvas:select_node compute function."""

    def test_select_node_input_contract(self, mock_context):
        """Test that select_node validates required inputs."""
        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "node_id": mock_context.get("selected_node"),
            "node_type": mock_context.get("selected_type"),
        }

        # Verify inputs structure
        assert inputs is not None
        assert "blueprint" in inputs
        assert "node_id" in inputs
        assert "node_type" in inputs

        # Call actual compute function if available
        if COMPUTE_AVAILABLE:
            result = select_node(inputs)
            assert result is not None
            assert isinstance(result, dict)

    def test_select_node_output_contract(self, mock_context):
        """Test that select_node returns expected output fields."""
        expected_outputs = ['node_data', 'edit_buffer']

        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "node_id": mock_context.get("selected_node"),
            "node_type": mock_context.get("selected_type"),
        }

        result = select_node(inputs)
        assert result is not None

        # Verify expected outputs are present
        for field in expected_outputs:
            assert field in result, f"Missing output field: {field}"

    def test_select_node_error_handling(self, mock_context):
        """Test that select_node handles errors gracefully."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        # Test with empty inputs
        invalid_inputs = {}

        try:
            result = select_node(invalid_inputs)
            # Should either return error dict or handle gracefully
            if result is not None:
                assert isinstance(result, dict)
        except (KeyError, TypeError, ValueError):
            # Expected - function requires inputs
            pass

    def test_select_node_blueprint_null(self, mock_context):
        """Test select_node with null blueprint."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": None,
            "node_id": mock_context.get("selected_node"),
            "node_type": mock_context.get("selected_type"),
        }

        try:
            result = select_node(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - blueprint is required
            pass

    def test_select_node_node_id_null(self, mock_context):
        """Test select_node with null node_id."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "node_id": None,
            "node_type": mock_context.get("selected_type"),
        }

        try:
            result = select_node(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - node_id is required
            pass

    def test_select_node_node_type_null(self, mock_context):
        """Test select_node with null node_type."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "node_id": mock_context.get("selected_node"),
            "node_type": None,
        }

        try:
            result = select_node(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - node_type is required
            pass


# =============================================================================
# Tests for compute unit: canvas:apply_edit
# =============================================================================

class TestCompute_ApplyEdit:
    """Tests for canvas:apply_edit compute function."""

    def test_apply_edit_input_contract(self, mock_context):
        """Test that apply_edit validates required inputs."""
        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "node_id": mock_context.get("selected_node"),
            "node_type": mock_context.get("selected_type"),
            "edit_buffer": mock_context.get("edit_buffer"),
        }

        # Verify inputs structure
        assert inputs is not None
        assert "blueprint" in inputs
        assert "node_id" in inputs
        assert "node_type" in inputs
        assert "edit_buffer" in inputs

        # Call actual compute function if available
        if COMPUTE_AVAILABLE:
            result = apply_edit(inputs)
            assert result is not None
            assert isinstance(result, dict)

    def test_apply_edit_output_contract(self, mock_context):
        """Test that apply_edit returns expected output fields."""
        expected_outputs = ['blueprint', 'blueprint_json', 'is_dirty']

        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "node_id": mock_context.get("selected_node"),
            "node_type": mock_context.get("selected_type"),
            "edit_buffer": mock_context.get("edit_buffer"),
        }

        result = apply_edit(inputs)
        assert result is not None

        # Verify expected outputs are present
        for field in expected_outputs:
            assert field in result, f"Missing output field: {field}"

    def test_apply_edit_error_handling(self, mock_context):
        """Test that apply_edit handles errors gracefully."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        # Test with empty inputs
        invalid_inputs = {}

        try:
            result = apply_edit(invalid_inputs)
            # Should either return error dict or handle gracefully
            if result is not None:
                assert isinstance(result, dict)
        except (KeyError, TypeError, ValueError):
            # Expected - function requires inputs
            pass

    def test_apply_edit_blueprint_null(self, mock_context):
        """Test apply_edit with null blueprint."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": None,
            "node_id": mock_context.get("selected_node"),
            "node_type": mock_context.get("selected_type"),
            "edit_buffer": mock_context.get("edit_buffer"),
        }

        try:
            result = apply_edit(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - blueprint is required
            pass

    def test_apply_edit_node_id_null(self, mock_context):
        """Test apply_edit with null node_id."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "node_id": None,
            "node_type": mock_context.get("selected_type"),
            "edit_buffer": mock_context.get("edit_buffer"),
        }

        try:
            result = apply_edit(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - node_id is required
            pass

    def test_apply_edit_node_type_null(self, mock_context):
        """Test apply_edit with null node_type."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "node_id": mock_context.get("selected_node"),
            "node_type": None,
            "edit_buffer": mock_context.get("edit_buffer"),
        }

        try:
            result = apply_edit(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - node_type is required
            pass

    def test_apply_edit_edit_buffer_null(self, mock_context):
        """Test apply_edit with null edit_buffer."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "node_id": mock_context.get("selected_node"),
            "node_type": mock_context.get("selected_type"),
            "edit_buffer": None,
        }

        try:
            result = apply_edit(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - edit_buffer is required
            pass


# =============================================================================
# Tests for compute unit: canvas:delete_node
# =============================================================================

class TestCompute_DeleteNode:
    """Tests for canvas:delete_node compute function."""

    def test_delete_node_input_contract(self, mock_context):
        """Test that delete_node validates required inputs."""
        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "node_id": mock_context.get("selected_node"),
            "node_type": mock_context.get("selected_type"),
        }

        # Verify inputs structure
        assert inputs is not None
        assert "blueprint" in inputs
        assert "node_id" in inputs
        assert "node_type" in inputs

        # Call actual compute function if available
        if COMPUTE_AVAILABLE:
            result = delete_node(inputs)
            assert result is not None
            assert isinstance(result, dict)

    def test_delete_node_output_contract(self, mock_context):
        """Test that delete_node returns expected output fields."""
        expected_outputs = ['blueprint', 'blueprint_json', 'is_dirty']

        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "node_id": mock_context.get("selected_node"),
            "node_type": mock_context.get("selected_type"),
        }

        result = delete_node(inputs)
        assert result is not None

        # Verify expected outputs are present
        for field in expected_outputs:
            assert field in result, f"Missing output field: {field}"

    def test_delete_node_error_handling(self, mock_context):
        """Test that delete_node handles errors gracefully."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        # Test with empty inputs
        invalid_inputs = {}

        try:
            result = delete_node(invalid_inputs)
            # Should either return error dict or handle gracefully
            if result is not None:
                assert isinstance(result, dict)
        except (KeyError, TypeError, ValueError):
            # Expected - function requires inputs
            pass

    def test_delete_node_blueprint_null(self, mock_context):
        """Test delete_node with null blueprint."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": None,
            "node_id": mock_context.get("selected_node"),
            "node_type": mock_context.get("selected_type"),
        }

        try:
            result = delete_node(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - blueprint is required
            pass

    def test_delete_node_node_id_null(self, mock_context):
        """Test delete_node with null node_id."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "node_id": None,
            "node_type": mock_context.get("selected_type"),
        }

        try:
            result = delete_node(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - node_id is required
            pass

    def test_delete_node_node_type_null(self, mock_context):
        """Test delete_node with null node_type."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "node_id": mock_context.get("selected_node"),
            "node_type": None,
        }

        try:
            result = delete_node(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - node_type is required
            pass


# =============================================================================
# Tests for compute unit: canvas:add_state
# =============================================================================

class TestCompute_AddState:
    """Tests for canvas:add_state compute function."""

    def test_add_state_input_contract(self, mock_context):
        """Test that add_state validates required inputs."""
        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "state_data": mock_context.get("edit_buffer"),
        }

        # Verify inputs structure
        assert inputs is not None
        assert "blueprint" in inputs
        assert "state_data" in inputs

        # Call actual compute function if available
        if COMPUTE_AVAILABLE:
            result = add_state(inputs)
            assert result is not None
            assert isinstance(result, dict)

    def test_add_state_output_contract(self, mock_context):
        """Test that add_state returns expected output fields."""
        expected_outputs = ['blueprint', 'blueprint_json', 'is_dirty']

        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "state_data": mock_context.get("edit_buffer"),
        }

        result = add_state(inputs)
        assert result is not None

        # Verify expected outputs are present
        for field in expected_outputs:
            assert field in result, f"Missing output field: {field}"

    def test_add_state_error_handling(self, mock_context):
        """Test that add_state handles errors gracefully."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        # Test with empty inputs
        invalid_inputs = {}

        try:
            result = add_state(invalid_inputs)
            # Should either return error dict or handle gracefully
            if result is not None:
                assert isinstance(result, dict)
        except (KeyError, TypeError, ValueError):
            # Expected - function requires inputs
            pass

    def test_add_state_blueprint_null(self, mock_context):
        """Test add_state with null blueprint."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": None,
            "state_data": mock_context.get("edit_buffer"),
        }

        try:
            result = add_state(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - blueprint is required
            pass

    def test_add_state_state_data_null(self, mock_context):
        """Test add_state with null state_data."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "state_data": None,
        }

        try:
            result = add_state(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - state_data is required
            pass


# =============================================================================
# Tests for compute unit: canvas:add_transition
# =============================================================================

class TestCompute_AddTransition:
    """Tests for canvas:add_transition compute function."""

    def test_add_transition_input_contract(self, mock_context):
        """Test that add_transition validates required inputs."""
        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "transition_data": mock_context.get("edit_buffer"),
        }

        # Verify inputs structure
        assert inputs is not None
        assert "blueprint" in inputs
        assert "transition_data" in inputs

        # Call actual compute function if available
        if COMPUTE_AVAILABLE:
            result = add_transition(inputs)
            assert result is not None
            assert isinstance(result, dict)

    def test_add_transition_output_contract(self, mock_context):
        """Test that add_transition returns expected output fields."""
        expected_outputs = ['blueprint', 'blueprint_json', 'is_dirty']

        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "transition_data": mock_context.get("edit_buffer"),
        }

        result = add_transition(inputs)
        assert result is not None

        # Verify expected outputs are present
        for field in expected_outputs:
            assert field in result, f"Missing output field: {field}"

    def test_add_transition_error_handling(self, mock_context):
        """Test that add_transition handles errors gracefully."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        # Test with empty inputs
        invalid_inputs = {}

        try:
            result = add_transition(invalid_inputs)
            # Should either return error dict or handle gracefully
            if result is not None:
                assert isinstance(result, dict)
        except (KeyError, TypeError, ValueError):
            # Expected - function requires inputs
            pass

    def test_add_transition_blueprint_null(self, mock_context):
        """Test add_transition with null blueprint."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": None,
            "transition_data": mock_context.get("edit_buffer"),
        }

        try:
            result = add_transition(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - blueprint is required
            pass

    def test_add_transition_transition_data_null(self, mock_context):
        """Test add_transition with null transition_data."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "transition_data": None,
        }

        try:
            result = add_transition(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - transition_data is required
            pass


# =============================================================================
# Tests for compute unit: canvas:add_gate
# =============================================================================

class TestCompute_AddGate:
    """Tests for canvas:add_gate compute function."""

    def test_add_gate_input_contract(self, mock_context):
        """Test that add_gate validates required inputs."""
        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "gate_data": mock_context.get("edit_buffer"),
        }

        # Verify inputs structure
        assert inputs is not None
        assert "blueprint" in inputs
        assert "gate_data" in inputs

        # Call actual compute function if available
        if COMPUTE_AVAILABLE:
            result = add_gate(inputs)
            assert result is not None
            assert isinstance(result, dict)

    def test_add_gate_output_contract(self, mock_context):
        """Test that add_gate returns expected output fields."""
        expected_outputs = ['blueprint', 'blueprint_json', 'is_dirty']

        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "gate_data": mock_context.get("edit_buffer"),
        }

        result = add_gate(inputs)
        assert result is not None

        # Verify expected outputs are present
        for field in expected_outputs:
            assert field in result, f"Missing output field: {field}"

    def test_add_gate_error_handling(self, mock_context):
        """Test that add_gate handles errors gracefully."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        # Test with empty inputs
        invalid_inputs = {}

        try:
            result = add_gate(invalid_inputs)
            # Should either return error dict or handle gracefully
            if result is not None:
                assert isinstance(result, dict)
        except (KeyError, TypeError, ValueError):
            # Expected - function requires inputs
            pass

    def test_add_gate_blueprint_null(self, mock_context):
        """Test add_gate with null blueprint."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": None,
            "gate_data": mock_context.get("edit_buffer"),
        }

        try:
            result = add_gate(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - blueprint is required
            pass

    def test_add_gate_gate_data_null(self, mock_context):
        """Test add_gate with null gate_data."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "gate_data": None,
        }

        try:
            result = add_gate(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - gate_data is required
            pass


# =============================================================================
# Tests for compute unit: canvas:add_action
# =============================================================================

class TestCompute_AddAction:
    """Tests for canvas:add_action compute function."""

    def test_add_action_input_contract(self, mock_context):
        """Test that add_action validates required inputs."""
        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "action_data": mock_context.get("edit_buffer"),
        }

        # Verify inputs structure
        assert inputs is not None
        assert "blueprint" in inputs
        assert "action_data" in inputs

        # Call actual compute function if available
        if COMPUTE_AVAILABLE:
            result = add_action(inputs)
            assert result is not None
            assert isinstance(result, dict)

    def test_add_action_output_contract(self, mock_context):
        """Test that add_action returns expected output fields."""
        expected_outputs = ['blueprint', 'blueprint_json', 'is_dirty']

        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "action_data": mock_context.get("edit_buffer"),
        }

        result = add_action(inputs)
        assert result is not None

        # Verify expected outputs are present
        for field in expected_outputs:
            assert field in result, f"Missing output field: {field}"

    def test_add_action_error_handling(self, mock_context):
        """Test that add_action handles errors gracefully."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        # Test with empty inputs
        invalid_inputs = {}

        try:
            result = add_action(invalid_inputs)
            # Should either return error dict or handle gracefully
            if result is not None:
                assert isinstance(result, dict)
        except (KeyError, TypeError, ValueError):
            # Expected - function requires inputs
            pass

    def test_add_action_blueprint_null(self, mock_context):
        """Test add_action with null blueprint."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": None,
            "action_data": mock_context.get("edit_buffer"),
        }

        try:
            result = add_action(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - blueprint is required
            pass

    def test_add_action_action_data_null(self, mock_context):
        """Test add_action with null action_data."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "action_data": None,
        }

        try:
            result = add_action(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - action_data is required
            pass


# =============================================================================
# Tests for compute unit: canvas:run_tlc
# =============================================================================

class TestCompute_RunTlc:
    """Tests for canvas:run_tlc compute function."""

    def test_run_tlc_input_contract(self, mock_context):
        """Test that run_tlc validates required inputs."""
        inputs = {
            "blueprint": mock_context.get("blueprint"),
        }

        # Verify inputs structure
        assert inputs is not None
        assert "blueprint" in inputs

        # Call actual compute function if available
        if COMPUTE_AVAILABLE:
            result = run_tlc(inputs)
            assert result is not None
            assert isinstance(result, dict)

    def test_run_tlc_output_contract(self, mock_context):
        """Test that run_tlc returns expected output fields."""
        expected_outputs = ['tlc_result', 'tlc_errors', 'tlc_passed', 'error']

        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
        }

        result = run_tlc(inputs)
        assert result is not None

        # Verify expected outputs are present
        for field in expected_outputs:
            assert field in result, f"Missing output field: {field}"

    def test_run_tlc_error_handling(self, mock_context):
        """Test that run_tlc handles errors gracefully."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        # Test with empty inputs
        invalid_inputs = {}

        try:
            result = run_tlc(invalid_inputs)
            # Should either return error dict or handle gracefully
            if result is not None:
                assert isinstance(result, dict)
        except (KeyError, TypeError, ValueError):
            # Expected - function requires inputs
            pass

    def test_run_tlc_blueprint_null(self, mock_context):
        """Test run_tlc with null blueprint."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": None,
        }

        try:
            result = run_tlc(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - blueprint is required
            pass


# =============================================================================
# Tests for compute unit: canvas:analyze_paths
# =============================================================================

class TestCompute_AnalyzePaths:
    """Tests for canvas:analyze_paths compute function."""

    def test_analyze_paths_input_contract(self, mock_context):
        """Test that analyze_paths validates required inputs."""
        inputs = {
            "blueprint": mock_context.get("blueprint"),
        }

        # Verify inputs structure
        assert inputs is not None
        assert "blueprint" in inputs

        # Call actual compute function if available
        if COMPUTE_AVAILABLE:
            result = analyze_paths(inputs)
            assert result is not None
            assert isinstance(result, dict)

    def test_analyze_paths_output_contract(self, mock_context):
        """Test that analyze_paths returns expected output fields."""
        expected_outputs = ['paths', 'path_count', 'states_list', 'state_count', 'reachability', 'deadlocks']

        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
        }

        result = analyze_paths(inputs)
        assert result is not None

        # Verify expected outputs are present
        for field in expected_outputs:
            assert field in result, f"Missing output field: {field}"

    def test_analyze_paths_error_handling(self, mock_context):
        """Test that analyze_paths handles errors gracefully."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        # Test with empty inputs
        invalid_inputs = {}

        try:
            result = analyze_paths(invalid_inputs)
            # Should either return error dict or handle gracefully
            if result is not None:
                assert isinstance(result, dict)
        except (KeyError, TypeError, ValueError):
            # Expected - function requires inputs
            pass

    def test_analyze_paths_blueprint_null(self, mock_context):
        """Test analyze_paths with null blueprint."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": None,
        }

        try:
            result = analyze_paths(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - blueprint is required
            pass


# =============================================================================
# Tests for compute unit: canvas:init_simulation
# =============================================================================

class TestCompute_InitSimulation:
    """Tests for canvas:init_simulation compute function."""

    def test_init_simulation_input_contract(self, mock_context):
        """Test that init_simulation validates required inputs."""
        inputs = {
            "blueprint": mock_context.get("blueprint"),
        }

        # Verify inputs structure
        assert inputs is not None
        assert "blueprint" in inputs

        # Call actual compute function if available
        if COMPUTE_AVAILABLE:
            result = init_simulation(inputs)
            assert result is not None
            assert isinstance(result, dict)

    def test_init_simulation_output_contract(self, mock_context):
        """Test that init_simulation returns expected output fields."""
        expected_outputs = ['sim_state', 'sim_context', 'sim_history', 'sim_available_events', 'sim_step_count']

        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
        }

        result = init_simulation(inputs)
        assert result is not None

        # Verify expected outputs are present
        for field in expected_outputs:
            assert field in result, f"Missing output field: {field}"

    def test_init_simulation_error_handling(self, mock_context):
        """Test that init_simulation handles errors gracefully."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        # Test with empty inputs
        invalid_inputs = {}

        try:
            result = init_simulation(invalid_inputs)
            # Should either return error dict or handle gracefully
            if result is not None:
                assert isinstance(result, dict)
        except (KeyError, TypeError, ValueError):
            # Expected - function requires inputs
            pass

    def test_init_simulation_blueprint_null(self, mock_context):
        """Test init_simulation with null blueprint."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": None,
        }

        try:
            result = init_simulation(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - blueprint is required
            pass


# =============================================================================
# Tests for compute unit: canvas:sim_step
# =============================================================================

class TestCompute_SimStep:
    """Tests for canvas:sim_step compute function."""

    def test_sim_step_input_contract(self, mock_context):
        """Test that sim_step validates required inputs."""
        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "sim_state": mock_context.get("sim_state"),
            "sim_context": mock_context.get("sim_context"),
            "sim_history": mock_context.get("sim_history"),
            "event": mock_context.get("prompt"),
        }

        # Verify inputs structure
        assert inputs is not None
        assert "blueprint" in inputs
        assert "sim_state" in inputs
        assert "sim_context" in inputs
        assert "sim_history" in inputs
        assert "event" in inputs

        # Call actual compute function if available
        if COMPUTE_AVAILABLE:
            result = sim_step(inputs)
            assert result is not None
            assert isinstance(result, dict)

    def test_sim_step_output_contract(self, mock_context):
        """Test that sim_step returns expected output fields."""
        expected_outputs = ['sim_state', 'sim_context', 'sim_history', 'sim_available_events', 'sim_step_count']

        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "sim_state": mock_context.get("sim_state"),
            "sim_context": mock_context.get("sim_context"),
            "sim_history": mock_context.get("sim_history"),
            "event": mock_context.get("prompt"),
        }

        result = sim_step(inputs)
        assert result is not None

        # Verify expected outputs are present
        for field in expected_outputs:
            assert field in result, f"Missing output field: {field}"

    def test_sim_step_error_handling(self, mock_context):
        """Test that sim_step handles errors gracefully."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        # Test with empty inputs
        invalid_inputs = {}

        try:
            result = sim_step(invalid_inputs)
            # Should either return error dict or handle gracefully
            if result is not None:
                assert isinstance(result, dict)
        except (KeyError, TypeError, ValueError):
            # Expected - function requires inputs
            pass

    def test_sim_step_blueprint_null(self, mock_context):
        """Test sim_step with null blueprint."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": None,
            "sim_state": mock_context.get("sim_state"),
            "sim_context": mock_context.get("sim_context"),
            "sim_history": mock_context.get("sim_history"),
            "event": mock_context.get("prompt"),
        }

        try:
            result = sim_step(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - blueprint is required
            pass

    def test_sim_step_sim_state_null(self, mock_context):
        """Test sim_step with null sim_state."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "sim_state": None,
            "sim_context": mock_context.get("sim_context"),
            "sim_history": mock_context.get("sim_history"),
            "event": mock_context.get("prompt"),
        }

        try:
            result = sim_step(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - sim_state is required
            pass

    def test_sim_step_sim_context_null(self, mock_context):
        """Test sim_step with null sim_context."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "sim_state": mock_context.get("sim_state"),
            "sim_context": None,
            "sim_history": mock_context.get("sim_history"),
            "event": mock_context.get("prompt"),
        }

        try:
            result = sim_step(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - sim_context is required
            pass

    def test_sim_step_sim_history_null(self, mock_context):
        """Test sim_step with null sim_history."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "sim_state": mock_context.get("sim_state"),
            "sim_context": mock_context.get("sim_context"),
            "sim_history": None,
            "event": mock_context.get("prompt"),
        }

        try:
            result = sim_step(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - sim_history is required
            pass

    def test_sim_step_event_null(self, mock_context):
        """Test sim_step with null event."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "sim_state": mock_context.get("sim_state"),
            "sim_context": mock_context.get("sim_context"),
            "sim_history": mock_context.get("sim_history"),
            "event": None,
        }

        try:
            result = sim_step(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - event is required
            pass


# =============================================================================
# Tests for compute unit: canvas:sim_dispatch
# =============================================================================

class TestCompute_SimDispatch:
    """Tests for canvas:sim_dispatch compute function."""

    def test_sim_dispatch_input_contract(self, mock_context):
        """Test that sim_dispatch validates required inputs."""
        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "sim_state": mock_context.get("sim_state"),
            "sim_context": mock_context.get("sim_context"),
            "event": mock_context.get("prompt"),
            "payload": mock_context.get("edit_buffer"),
        }

        # Verify inputs structure
        assert inputs is not None
        assert "blueprint" in inputs
        assert "sim_state" in inputs
        assert "sim_context" in inputs
        assert "event" in inputs
        assert "payload" in inputs

        # Call actual compute function if available
        if COMPUTE_AVAILABLE:
            result = sim_dispatch(inputs)
            assert result is not None
            assert isinstance(result, dict)

    def test_sim_dispatch_output_contract(self, mock_context):
        """Test that sim_dispatch returns expected output fields."""
        expected_outputs = ['sim_state', 'sim_context', 'sim_history', 'sim_available_events', 'sim_step_count']

        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "sim_state": mock_context.get("sim_state"),
            "sim_context": mock_context.get("sim_context"),
            "event": mock_context.get("prompt"),
            "payload": mock_context.get("edit_buffer"),
        }

        result = sim_dispatch(inputs)
        assert result is not None

        # Verify expected outputs are present
        for field in expected_outputs:
            assert field in result, f"Missing output field: {field}"

    def test_sim_dispatch_error_handling(self, mock_context):
        """Test that sim_dispatch handles errors gracefully."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        # Test with empty inputs
        invalid_inputs = {}

        try:
            result = sim_dispatch(invalid_inputs)
            # Should either return error dict or handle gracefully
            if result is not None:
                assert isinstance(result, dict)
        except (KeyError, TypeError, ValueError):
            # Expected - function requires inputs
            pass

    def test_sim_dispatch_blueprint_null(self, mock_context):
        """Test sim_dispatch with null blueprint."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": None,
            "sim_state": mock_context.get("sim_state"),
            "sim_context": mock_context.get("sim_context"),
            "event": mock_context.get("prompt"),
            "payload": mock_context.get("edit_buffer"),
        }

        try:
            result = sim_dispatch(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - blueprint is required
            pass

    def test_sim_dispatch_sim_state_null(self, mock_context):
        """Test sim_dispatch with null sim_state."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "sim_state": None,
            "sim_context": mock_context.get("sim_context"),
            "event": mock_context.get("prompt"),
            "payload": mock_context.get("edit_buffer"),
        }

        try:
            result = sim_dispatch(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - sim_state is required
            pass

    def test_sim_dispatch_sim_context_null(self, mock_context):
        """Test sim_dispatch with null sim_context."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "sim_state": mock_context.get("sim_state"),
            "sim_context": None,
            "event": mock_context.get("prompt"),
            "payload": mock_context.get("edit_buffer"),
        }

        try:
            result = sim_dispatch(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - sim_context is required
            pass

    def test_sim_dispatch_event_null(self, mock_context):
        """Test sim_dispatch with null event."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "sim_state": mock_context.get("sim_state"),
            "sim_context": mock_context.get("sim_context"),
            "event": None,
            "payload": mock_context.get("edit_buffer"),
        }

        try:
            result = sim_dispatch(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - event is required
            pass

    def test_sim_dispatch_payload_null(self, mock_context):
        """Test sim_dispatch with null payload."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "sim_state": mock_context.get("sim_state"),
            "sim_context": mock_context.get("sim_context"),
            "event": mock_context.get("prompt"),
            "payload": None,
        }

        try:
            result = sim_dispatch(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - payload is required
            pass


# =============================================================================
# Tests for compute unit: canvas:init_simulation
# =============================================================================

class TestCompute_InitSimulation:
    """Tests for canvas:init_simulation compute function."""

    def test_init_simulation_input_contract(self, mock_context):
        """Test that init_simulation validates required inputs."""
        inputs = {
            "blueprint": mock_context.get("blueprint"),
        }

        # Verify inputs structure
        assert inputs is not None
        assert "blueprint" in inputs

        # Call actual compute function if available
        if COMPUTE_AVAILABLE:
            result = init_simulation(inputs)
            assert result is not None
            assert isinstance(result, dict)

    def test_init_simulation_output_contract(self, mock_context):
        """Test that init_simulation returns expected output fields."""
        expected_outputs = ['sim_state', 'sim_context', 'sim_history', 'sim_available_events', 'sim_step_count']

        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
        }

        result = init_simulation(inputs)
        assert result is not None

        # Verify expected outputs are present
        for field in expected_outputs:
            assert field in result, f"Missing output field: {field}"

    def test_init_simulation_error_handling(self, mock_context):
        """Test that init_simulation handles errors gracefully."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        # Test with empty inputs
        invalid_inputs = {}

        try:
            result = init_simulation(invalid_inputs)
            # Should either return error dict or handle gracefully
            if result is not None:
                assert isinstance(result, dict)
        except (KeyError, TypeError, ValueError):
            # Expected - function requires inputs
            pass

    def test_init_simulation_blueprint_null(self, mock_context):
        """Test init_simulation with null blueprint."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": None,
        }

        try:
            result = init_simulation(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - blueprint is required
            pass


# =============================================================================
# Tests for compute unit: canvas:compute_clusters
# =============================================================================

class TestCompute_ComputeClusters:
    """Tests for canvas:compute_clusters compute function."""

    def test_compute_clusters_input_contract(self, mock_context):
        """Test that compute_clusters validates required inputs."""
        inputs = {
            "blueprint": mock_context.get("blueprint"),
        }

        # Verify inputs structure
        assert inputs is not None
        assert "blueprint" in inputs

        # Call actual compute function if available
        if COMPUTE_AVAILABLE:
            result = compute_clusters(inputs)
            assert result is not None
            assert isinstance(result, dict)

    def test_compute_clusters_output_contract(self, mock_context):
        """Test that compute_clusters returns expected output fields."""
        expected_outputs = ['clusters', 'dependencies', 'sorted_states']

        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
        }

        result = compute_clusters(inputs)
        assert result is not None

        # Verify expected outputs are present
        for field in expected_outputs:
            assert field in result, f"Missing output field: {field}"

    def test_compute_clusters_error_handling(self, mock_context):
        """Test that compute_clusters handles errors gracefully."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        # Test with empty inputs
        invalid_inputs = {}

        try:
            result = compute_clusters(invalid_inputs)
            # Should either return error dict or handle gracefully
            if result is not None:
                assert isinstance(result, dict)
        except (KeyError, TypeError, ValueError):
            # Expected - function requires inputs
            pass

    def test_compute_clusters_blueprint_null(self, mock_context):
        """Test compute_clusters with null blueprint."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": None,
        }

        try:
            result = compute_clusters(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - blueprint is required
            pass


# =============================================================================
# Tests for compute unit: canvas:start_review
# =============================================================================

class TestCompute_StartReview:
    """Tests for canvas:start_review compute function."""

    def test_start_review_input_contract(self, mock_context):
        """Test that start_review validates required inputs."""
        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "review_notes": mock_context.get("review_notes"),
        }

        # Verify inputs structure
        assert inputs is not None
        assert "blueprint" in inputs
        assert "review_notes" in inputs

        # Call actual compute function if available
        if COMPUTE_AVAILABLE:
            result = start_review(inputs)
            assert result is not None
            assert isinstance(result, dict)

    def test_start_review_output_contract(self, mock_context):
        """Test that start_review returns expected output fields."""
        expected_outputs = ['review_notes', 'review_status', 'coverage']

        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "review_notes": mock_context.get("review_notes"),
        }

        result = start_review(inputs)
        assert result is not None

        # Verify expected outputs are present
        for field in expected_outputs:
            assert field in result, f"Missing output field: {field}"

    def test_start_review_error_handling(self, mock_context):
        """Test that start_review handles errors gracefully."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        # Test with empty inputs
        invalid_inputs = {}

        try:
            result = start_review(invalid_inputs)
            # Should either return error dict or handle gracefully
            if result is not None:
                assert isinstance(result, dict)
        except (KeyError, TypeError, ValueError):
            # Expected - function requires inputs
            pass

    def test_start_review_blueprint_null(self, mock_context):
        """Test start_review with null blueprint."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": None,
            "review_notes": mock_context.get("review_notes"),
        }

        try:
            result = start_review(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - blueprint is required
            pass

    def test_start_review_review_notes_null(self, mock_context):
        """Test start_review with null review_notes."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "review_notes": None,
        }

        try:
            result = start_review(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - review_notes is required
            pass


# =============================================================================
# Tests for compute unit: canvas:add_note
# =============================================================================

class TestCompute_AddNote:
    """Tests for canvas:add_note compute function."""

    def test_add_note_input_contract(self, mock_context):
        """Test that add_note validates required inputs."""
        inputs = {
            "review_notes": mock_context.get("review_notes"),
            "note": mock_context.get("prompt"),
            "node_id": mock_context.get("selected_node"),
        }

        # Verify inputs structure
        assert inputs is not None
        assert "review_notes" in inputs
        assert "note" in inputs
        assert "node_id" in inputs

        # Call actual compute function if available
        if COMPUTE_AVAILABLE:
            result = add_note(inputs)
            assert result is not None
            assert isinstance(result, dict)

    def test_add_note_output_contract(self, mock_context):
        """Test that add_note returns expected output fields."""
        expected_outputs = ['review_notes']

        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "review_notes": mock_context.get("review_notes"),
            "note": mock_context.get("prompt"),
            "node_id": mock_context.get("selected_node"),
        }

        result = add_note(inputs)
        assert result is not None

        # Verify expected outputs are present
        for field in expected_outputs:
            assert field in result, f"Missing output field: {field}"

    def test_add_note_error_handling(self, mock_context):
        """Test that add_note handles errors gracefully."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        # Test with empty inputs
        invalid_inputs = {}

        try:
            result = add_note(invalid_inputs)
            # Should either return error dict or handle gracefully
            if result is not None:
                assert isinstance(result, dict)
        except (KeyError, TypeError, ValueError):
            # Expected - function requires inputs
            pass

    def test_add_note_review_notes_null(self, mock_context):
        """Test add_note with null review_notes."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "review_notes": None,
            "note": mock_context.get("prompt"),
            "node_id": mock_context.get("selected_node"),
        }

        try:
            result = add_note(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - review_notes is required
            pass

    def test_add_note_note_null(self, mock_context):
        """Test add_note with null note."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "review_notes": mock_context.get("review_notes"),
            "note": None,
            "node_id": mock_context.get("selected_node"),
        }

        try:
            result = add_note(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - note is required
            pass

    def test_add_note_node_id_null(self, mock_context):
        """Test add_note with null node_id."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "review_notes": mock_context.get("review_notes"),
            "note": mock_context.get("prompt"),
            "node_id": None,
        }

        try:
            result = add_note(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - node_id is required
            pass


# =============================================================================
# Tests for compute unit: canvas:add_audit
# =============================================================================

class TestCompute_AddAudit:
    """Tests for canvas:add_audit compute function."""

    def test_add_audit_input_contract(self, mock_context):
        """Test that add_audit validates required inputs."""
        inputs = {
            "audit_log": mock_context.get("audit_log"),
            "action": mock_context.get("mode"),
            "node_id": mock_context.get("selected_node"),
            "node_type": mock_context.get("selected_type"),
        }

        # Verify inputs structure
        assert inputs is not None
        assert "audit_log" in inputs
        assert "action" in inputs
        assert "node_id" in inputs
        assert "node_type" in inputs

        # Call actual compute function if available
        if COMPUTE_AVAILABLE:
            result = add_audit(inputs)
            assert result is not None
            assert isinstance(result, dict)

    def test_add_audit_output_contract(self, mock_context):
        """Test that add_audit returns expected output fields."""
        expected_outputs = ['audit_log']

        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "audit_log": mock_context.get("audit_log"),
            "action": mock_context.get("mode"),
            "node_id": mock_context.get("selected_node"),
            "node_type": mock_context.get("selected_type"),
        }

        result = add_audit(inputs)
        assert result is not None

        # Verify expected outputs are present
        for field in expected_outputs:
            assert field in result, f"Missing output field: {field}"

    def test_add_audit_error_handling(self, mock_context):
        """Test that add_audit handles errors gracefully."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        # Test with empty inputs
        invalid_inputs = {}

        try:
            result = add_audit(invalid_inputs)
            # Should either return error dict or handle gracefully
            if result is not None:
                assert isinstance(result, dict)
        except (KeyError, TypeError, ValueError):
            # Expected - function requires inputs
            pass

    def test_add_audit_audit_log_null(self, mock_context):
        """Test add_audit with null audit_log."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "audit_log": None,
            "action": mock_context.get("mode"),
            "node_id": mock_context.get("selected_node"),
            "node_type": mock_context.get("selected_type"),
        }

        try:
            result = add_audit(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - audit_log is required
            pass

    def test_add_audit_action_null(self, mock_context):
        """Test add_audit with null action."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "audit_log": mock_context.get("audit_log"),
            "action": None,
            "node_id": mock_context.get("selected_node"),
            "node_type": mock_context.get("selected_type"),
        }

        try:
            result = add_audit(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - action is required
            pass

    def test_add_audit_node_id_null(self, mock_context):
        """Test add_audit with null node_id."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "audit_log": mock_context.get("audit_log"),
            "action": mock_context.get("mode"),
            "node_id": None,
            "node_type": mock_context.get("selected_type"),
        }

        try:
            result = add_audit(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - node_id is required
            pass

    def test_add_audit_node_type_null(self, mock_context):
        """Test add_audit with null node_type."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "audit_log": mock_context.get("audit_log"),
            "action": mock_context.get("mode"),
            "node_id": mock_context.get("selected_node"),
            "node_type": None,
        }

        try:
            result = add_audit(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - node_type is required
            pass


# =============================================================================
# Tests for compute unit: canvas:llm_query
# =============================================================================

class TestCompute_LlmQuery:
    """Tests for canvas:llm_query compute function."""

    def test_llm_query_input_contract(self, mock_context):
        """Test that llm_query validates required inputs."""
        inputs = {
            "api_key": mock_context.get("api_key"),
            "api_base": mock_context.get("api_base"),
            "model": mock_context.get("model"),
            "blueprint": mock_context.get("blueprint"),
            "prompt": mock_context.get("prompt"),
            "mode": mock_context.get("mode"),
            "selected_node": mock_context.get("selected_node"),
        }

        # Verify inputs structure
        assert inputs is not None
        assert "api_key" in inputs
        assert "api_base" in inputs
        assert "model" in inputs
        assert "blueprint" in inputs
        assert "prompt" in inputs
        assert "mode" in inputs
        assert "selected_node" in inputs

        # Call actual compute function if available
        if COMPUTE_AVAILABLE:
            result = llm_query(inputs)
            assert result is not None
            assert isinstance(result, dict)

    def test_llm_query_output_contract(self, mock_context):
        """Test that llm_query returns expected output fields."""
        expected_outputs = ['llm_response', 'suggestions', 'error']

        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "api_key": mock_context.get("api_key"),
            "api_base": mock_context.get("api_base"),
            "model": mock_context.get("model"),
            "blueprint": mock_context.get("blueprint"),
            "prompt": mock_context.get("prompt"),
            "mode": mock_context.get("mode"),
            "selected_node": mock_context.get("selected_node"),
        }

        result = llm_query(inputs)
        assert result is not None

        # Verify expected outputs are present
        for field in expected_outputs:
            assert field in result, f"Missing output field: {field}"

    def test_llm_query_error_handling(self, mock_context):
        """Test that llm_query handles errors gracefully."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        # Test with empty inputs
        invalid_inputs = {}

        try:
            result = llm_query(invalid_inputs)
            # Should either return error dict or handle gracefully
            if result is not None:
                assert isinstance(result, dict)
        except (KeyError, TypeError, ValueError):
            # Expected - function requires inputs
            pass

    def test_llm_query_api_key_null(self, mock_context):
        """Test llm_query with null api_key."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "api_key": None,
            "api_base": mock_context.get("api_base"),
            "model": mock_context.get("model"),
            "blueprint": mock_context.get("blueprint"),
            "prompt": mock_context.get("prompt"),
            "mode": mock_context.get("mode"),
            "selected_node": mock_context.get("selected_node"),
        }

        try:
            result = llm_query(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - api_key is required
            pass

    def test_llm_query_api_base_null(self, mock_context):
        """Test llm_query with null api_base."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "api_key": mock_context.get("api_key"),
            "api_base": None,
            "model": mock_context.get("model"),
            "blueprint": mock_context.get("blueprint"),
            "prompt": mock_context.get("prompt"),
            "mode": mock_context.get("mode"),
            "selected_node": mock_context.get("selected_node"),
        }

        try:
            result = llm_query(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - api_base is required
            pass

    def test_llm_query_model_null(self, mock_context):
        """Test llm_query with null model."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "api_key": mock_context.get("api_key"),
            "api_base": mock_context.get("api_base"),
            "model": None,
            "blueprint": mock_context.get("blueprint"),
            "prompt": mock_context.get("prompt"),
            "mode": mock_context.get("mode"),
            "selected_node": mock_context.get("selected_node"),
        }

        try:
            result = llm_query(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - model is required
            pass

    def test_llm_query_blueprint_null(self, mock_context):
        """Test llm_query with null blueprint."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "api_key": mock_context.get("api_key"),
            "api_base": mock_context.get("api_base"),
            "model": mock_context.get("model"),
            "blueprint": None,
            "prompt": mock_context.get("prompt"),
            "mode": mock_context.get("mode"),
            "selected_node": mock_context.get("selected_node"),
        }

        try:
            result = llm_query(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - blueprint is required
            pass

    def test_llm_query_prompt_null(self, mock_context):
        """Test llm_query with null prompt."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "api_key": mock_context.get("api_key"),
            "api_base": mock_context.get("api_base"),
            "model": mock_context.get("model"),
            "blueprint": mock_context.get("blueprint"),
            "prompt": None,
            "mode": mock_context.get("mode"),
            "selected_node": mock_context.get("selected_node"),
        }

        try:
            result = llm_query(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - prompt is required
            pass

    def test_llm_query_mode_null(self, mock_context):
        """Test llm_query with null mode."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "api_key": mock_context.get("api_key"),
            "api_base": mock_context.get("api_base"),
            "model": mock_context.get("model"),
            "blueprint": mock_context.get("blueprint"),
            "prompt": mock_context.get("prompt"),
            "mode": None,
            "selected_node": mock_context.get("selected_node"),
        }

        try:
            result = llm_query(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - mode is required
            pass

    def test_llm_query_selected_node_null(self, mock_context):
        """Test llm_query with null selected_node."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "api_key": mock_context.get("api_key"),
            "api_base": mock_context.get("api_base"),
            "model": mock_context.get("model"),
            "blueprint": mock_context.get("blueprint"),
            "prompt": mock_context.get("prompt"),
            "mode": mock_context.get("mode"),
            "selected_node": None,
        }

        try:
            result = llm_query(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - selected_node is required
            pass


# =============================================================================
# Tests for compute unit: canvas:apply_llm
# =============================================================================

class TestCompute_ApplyLlm:
    """Tests for canvas:apply_llm compute function."""

    def test_apply_llm_input_contract(self, mock_context):
        """Test that apply_llm validates required inputs."""
        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "suggestions": mock_context.get("suggestions"),
        }

        # Verify inputs structure
        assert inputs is not None
        assert "blueprint" in inputs
        assert "suggestions" in inputs

        # Call actual compute function if available
        if COMPUTE_AVAILABLE:
            result = apply_llm(inputs)
            assert result is not None
            assert isinstance(result, dict)

    def test_apply_llm_output_contract(self, mock_context):
        """Test that apply_llm returns expected output fields."""
        expected_outputs = ['blueprint', 'blueprint_json', 'is_dirty']

        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "suggestions": mock_context.get("suggestions"),
        }

        result = apply_llm(inputs)
        assert result is not None

        # Verify expected outputs are present
        for field in expected_outputs:
            assert field in result, f"Missing output field: {field}"

    def test_apply_llm_error_handling(self, mock_context):
        """Test that apply_llm handles errors gracefully."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        # Test with empty inputs
        invalid_inputs = {}

        try:
            result = apply_llm(invalid_inputs)
            # Should either return error dict or handle gracefully
            if result is not None:
                assert isinstance(result, dict)
        except (KeyError, TypeError, ValueError):
            # Expected - function requires inputs
            pass

    def test_apply_llm_blueprint_null(self, mock_context):
        """Test apply_llm with null blueprint."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": None,
            "suggestions": mock_context.get("suggestions"),
        }

        try:
            result = apply_llm(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - blueprint is required
            pass

    def test_apply_llm_suggestions_null(self, mock_context):
        """Test apply_llm with null suggestions."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "suggestions": None,
        }

        try:
            result = apply_llm(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - suggestions is required
            pass


# =============================================================================
# Tests for compute unit: canvas:generate_outputs
# =============================================================================

class TestCompute_GenerateOutputs:
    """Tests for canvas:generate_outputs compute function."""

    def test_generate_outputs_input_contract(self, mock_context):
        """Test that generate_outputs validates required inputs."""
        inputs = {
            "blueprint": mock_context.get("blueprint"),
        }

        # Verify inputs structure
        assert inputs is not None
        assert "blueprint" in inputs

        # Call actual compute function if available
        if COMPUTE_AVAILABLE:
            result = generate_outputs(inputs)
            assert result is not None
            assert isinstance(result, dict)

    def test_generate_outputs_output_contract(self, mock_context):
        """Test that generate_outputs returns expected output fields."""
        expected_outputs = ['graph_html', 'mermaid']

        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
        }

        result = generate_outputs(inputs)
        assert result is not None

        # Verify expected outputs are present
        for field in expected_outputs:
            assert field in result, f"Missing output field: {field}"

    def test_generate_outputs_error_handling(self, mock_context):
        """Test that generate_outputs handles errors gracefully."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        # Test with empty inputs
        invalid_inputs = {}

        try:
            result = generate_outputs(invalid_inputs)
            # Should either return error dict or handle gracefully
            if result is not None:
                assert isinstance(result, dict)
        except (KeyError, TypeError, ValueError):
            # Expected - function requires inputs
            pass

    def test_generate_outputs_blueprint_null(self, mock_context):
        """Test generate_outputs with null blueprint."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": None,
        }

        try:
            result = generate_outputs(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - blueprint is required
            pass


# =============================================================================
# Tests for compute unit: canvas:save_blueprint
# =============================================================================

class TestCompute_SaveBlueprint:
    """Tests for canvas:save_blueprint compute function."""

    def test_save_blueprint_input_contract(self, mock_context):
        """Test that save_blueprint validates required inputs."""
        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "path": mock_context.get("blueprint_path"),
        }

        # Verify inputs structure
        assert inputs is not None
        assert "blueprint" in inputs
        assert "path" in inputs

        # Call actual compute function if available
        if COMPUTE_AVAILABLE:
            result = save_blueprint(inputs)
            assert result is not None
            assert isinstance(result, dict)

    def test_save_blueprint_output_contract(self, mock_context):
        """Test that save_blueprint returns expected output fields."""
        expected_outputs = ['error']

        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "path": mock_context.get("blueprint_path"),
        }

        result = save_blueprint(inputs)
        assert result is not None

        # Verify expected outputs are present
        for field in expected_outputs:
            assert field in result, f"Missing output field: {field}"

    def test_save_blueprint_error_handling(self, mock_context):
        """Test that save_blueprint handles errors gracefully."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        # Test with empty inputs
        invalid_inputs = {}

        try:
            result = save_blueprint(invalid_inputs)
            # Should either return error dict or handle gracefully
            if result is not None:
                assert isinstance(result, dict)
        except (KeyError, TypeError, ValueError):
            # Expected - function requires inputs
            pass

    def test_save_blueprint_blueprint_null(self, mock_context):
        """Test save_blueprint with null blueprint."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": None,
            "path": mock_context.get("blueprint_path"),
        }

        try:
            result = save_blueprint(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - blueprint is required
            pass

    def test_save_blueprint_path_null(self, mock_context):
        """Test save_blueprint with null path."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
            "blueprint": mock_context.get("blueprint"),
            "path": None,
        }

        try:
            result = save_blueprint(inputs)
            # Function should handle null gracefully
            assert result is not None
        except (KeyError, TypeError, ValueError, AttributeError):
            # Expected - path is required
            pass


# =============================================================================
# Tests for compute unit: canvas:clear_all
# =============================================================================

class TestCompute_ClearAll:
    """Tests for canvas:clear_all compute function."""

    def test_clear_all_input_contract(self, mock_context):
        """Test that clear_all validates required inputs."""
        inputs = {
        }

        # Verify inputs structure
        assert inputs is not None

        # Call actual compute function if available
        if COMPUTE_AVAILABLE:
            result = clear_all(inputs)
            assert result is not None
            assert isinstance(result, dict)

    def test_clear_all_output_contract(self, mock_context):
        """Test that clear_all returns expected output fields."""
        expected_outputs = ['blueprint', 'blueprint_json', 'is_dirty', 'error']

        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        inputs = {
        }

        result = clear_all(inputs)
        assert result is not None

        # Verify expected outputs are present
        for field in expected_outputs:
            assert field in result, f"Missing output field: {field}"

    def test_clear_all_error_handling(self, mock_context):
        """Test that clear_all handles errors gracefully."""
        if not COMPUTE_AVAILABLE:
            pytest.skip(f"Compute module not available: {IMPORT_ERROR}")

        # Test with empty inputs
        invalid_inputs = {}

        try:
            result = clear_all(invalid_inputs)
            # Should either return error dict or handle gracefully
            if result is not None:
                assert isinstance(result, dict)
        except (KeyError, TypeError, ValueError):
            # Expected - function requires inputs
            pass

