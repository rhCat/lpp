stateDiagram-v2
    %% L++ State Diagram: Skill Contractor
    [*] --> idle
    idle --> idle : START
    idle --> planning : SUBMIT [target is not None and len(...]
    planning --> executing : DONE [plan is not None && error is None]
    executing --> parsing : DONE [raw_output is not None and ... && error is None]
    parsing --> correcting : DONE [parsed_output is not None a... && corrections is not None and... && step_index + 1 < step_count]
    parsing --> stepping : DONE [parsed_output is not None a... && corrections is None or len(... && step_index + 1 < step_count]
    parsing --> correcting : DONE [parsed_output is not None a... && corrections is not None and... && step_index + 1 >= step_count && is_lpp_target == True && phase == "blueprint"]
    parsing --> validating : DONE [parsed_output is not None a... && corrections is None or len(... && step_index + 1 >= step_count && is_lpp_target == True && phase == "blueprint"]
    parsing --> correcting : DONE [parsed_output is not None a... && corrections is not None and... && step_index + 1 >= step_count && is_lpp_target == True && phase == "implementation"]
    parsing --> validating : DONE [parsed_output is not None a... && corrections is None or len(... && step_index + 1 >= step_count && is_lpp_target == True && phase == "implementation"]
    parsing --> correcting : DONE [parsed_output is not None a... && corrections is not None and... && step_index + 1 >= step_count && is_lpp_target != True]
    parsing --> evaluating : DONE [parsed_output is not None a... && corrections is None or len(... && step_index + 1 >= step_count && is_lpp_target != True]
    correcting --> stepping : DONE [corrections_approved == True && step_index + 1 < step_count]
    correcting --> validating : DONE [corrections_approved == True && step_index + 1 >= step_count && is_lpp_target == True && phase == "blueprint"]
    correcting --> validating : DONE [corrections_approved == True && step_index + 1 >= step_count && is_lpp_target == True && phase == "implementation"]
    correcting --> evaluating : DONE [corrections_approved == True && step_index + 1 >= step_count && is_lpp_target != True]
    parsing --> executing : DONE [parse_error is not None && (repair_attempts is None or...]
    stepping --> executing : DONE [step_index + 1 < step_count && error is None]
    stepping --> validating : DONE [step_index + 1 >= step_count && error is None && is_lpp_target == True && phase == "blueprint"]
    stepping --> validating : DONE [step_index + 1 >= step_count && error is None && is_lpp_target == True && phase == "implementation"]
    stepping --> evaluating : DONE [step_index + 1 >= step_count && error is None && is_lpp_target != True]
    validating --> planning : DONE [blueprint_validated is not ... && error is None && phase == "blueprint"]
    validating --> eval_interactive : DONE [lpp_validated is not None a... && error is None && phase == "implementation"]
    eval_interactive --> evaluating : DONE [interactive_valid is not No... && error is None]
    eval_interactive --> refining : DONE [interactive_valid is None o... && iteration < max_iterations]
    eval_interactive --> evaluating : DONE [interactive_valid is None o... && iteration >= max_iterations]
    validating --> refining : DONE [blueprint_validated is None... && iteration < max_iterations && phase == "blueprint"]
    validating --> refining : DONE [is_lpp_target == True and (... && iteration < max_iterations && phase == "implementation"]
    validating --> evaluating : DONE [is_lpp_target == True and (... && iteration >= max_iterations]
    evaluating --> complete : DONE [is_satisfied == True && is_lpp_target != True or lp... && error is None]
    evaluating --> refining : DONE [is_satisfied == True && is_lpp_target == True and (... && iteration < max_iterations && error is None]
    evaluating --> refining : DONE [is_satisfied == False or is... && iteration < max_iterations && error is None]
    evaluating --> complete : DONE [iteration >= max_iterations && is_lpp_target != True or lp...]
    refining --> planning : DONE [error is None]
    reviewing --> evaluating : DONE [failed_steps is not None an...]
    reviewing --> stepping : DONE [review_decision == "skip" && step_index + 1 < step_count]
    reviewing --> evaluating : DONE [review_decision == "skip" && step_index + 1 >= step_count]
    reviewing --> refining : DONE [review_decision == "replan" && iteration < max_iterations]
    reviewing --> evaluating : DONE [review_decision == "replan" && iteration >= max_iterations]
    reviewing --> stepping : DONE [review_decision is None or ... && step_index + 1 < step_count]
    reviewing --> evaluating : DONE [review_decision is None or ... && step_index + 1 >= step_count]
    reviewing --> refining : DONE [plan is None or step_count ... && iteration < max_iterations]
    reviewing --> complete : DONE [plan is None or step_count ... && iteration >= max_iterations]
    planning --> idle : RESET
    executing --> idle : RESET
    parsing --> idle : RESET
    correcting --> idle : RESET
    evaluating --> idle : RESET
    stepping --> idle : RESET
    validating --> idle : RESET
    complete --> idle : RESET
    refining --> idle : RESET
    eval_interactive --> idle : RESET
    reviewing --> idle : RESET
    complete --> [*]