<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<title>Function Graph: coverage_analyzer</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
body { font-family: 'Segoe UI', Arial, sans-serif; margin: 0; padding: 20px; background: #0f0f23; color: #eee; }
h1 { color: #00d4ff; margin-bottom: 5px; font-size: 24px; }
.subtitle { color: #888; margin-bottom: 15px; font-size: 14px; }
#container { display: flex; gap: 20px; height: calc(100vh - 120px); }
#graph { flex: 1; position: relative; }
#sidebar { width: 350px; background: #1a1a2e; padding: 15px; border-radius: 8px; overflow-y: auto; }
svg { background: #16213e; border-radius: 8px; width: 100%; height: 100%; }

/* Node styles */
.node { cursor: pointer; }
.node-module { fill: #2a2a4a; stroke-width: 3; }
.node-function { fill: #3a3a5a; stroke-width: 2; }
.node-dependency { fill: #1a1a3a; stroke: #666; stroke-width: 1; stroke-dasharray: 4; }
.node-label { font-size: 11px; fill: #fff; pointer-events: none; font-weight: 500; }
.node-sublabel { font-size: 9px; fill: #888; pointer-events: none; }

/* Edge styles */
.edge { fill: none; stroke-opacity: 0.6; }
.edge-internal { stroke: #4ecdc4; stroke-width: 2; }
.edge-external { stroke: #f39c12; stroke-width: 1.5; stroke-dasharray: 4; }
.edge-local { stroke: #9b59b6; stroke-width: 2; }
.edge-label { font-size: 8px; fill: #666; pointer-events: none; }

/* Highlight styles */
.highlight { stroke-width: 3 !important; stroke-opacity: 1 !important; }
.dim { opacity: 0.2; }

/* Controls */
.controls { display: flex; gap: 8px; margin-bottom: 10px; flex-wrap: wrap; }
.controls button { background: #3a3a5a; color: #fff; border: 1px solid #555; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; }
.controls button:hover { background: #4a4a6a; }
.controls button.active { background: #00d4ff; color: #000; border-color: #00d4ff; }

/* Module legend */
.module-legend { margin-top: 15px; }
.module-item { display: flex; align-items: center; gap: 8px; padding: 5px 0; cursor: pointer; }
.module-item:hover { background: #2a2a4a; }
.module-dot { width: 12px; height: 12px; border-radius: 3px; }
.module-name { font-size: 12px; }

/* Info panel */
h3 { color: #00d4ff; margin: 15px 0 8px 0; font-size: 14px; border-bottom: 1px solid #333; padding-bottom: 5px; }
.info-section { font-size: 12px; line-height: 1.6; }
.info-label { color: #888; }
.info-value { color: #fff; }

/* Source code panel */
.source-panel { margin-top: 10px; }
.source-code { background: #0d0d1a; border: 1px solid #333; border-radius: 4px; padding: 10px; font-family: 'Consolas', 'Monaco', monospace; font-size: 11px; line-height: 1.4; overflow-x: auto; max-height: 300px; overflow-y: auto; white-space: pre; color: #b8b8b8; }
.source-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
.source-toggle { background: #3a3a5a; color: #fff; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 10px; }
.source-toggle:hover { background: #4a4a6a; }
.docstring { color: #6a9955; font-style: italic; }
.metric { display: flex; justify-content: space-between; padding: 3px 0; }
.metric-bar { height: 4px; background: #333; border-radius: 2px; margin-top: 2px; }
.metric-fill { height: 100%; border-radius: 2px; }

/* Edge list */
.edge-list { max-height: 200px; overflow-y: auto; }
.edge-item { padding: 4px 0; border-bottom: 1px solid #333; font-size: 11px; }
.edge-item .from { color: #4ecdc4; }
.edge-item .to { color: #f39c12; }
.edge-item .type { color: #666; font-size: 10px; }

/* Tooltip */
#tooltip { position: absolute; background: #1a1a2e; border: 1px solid #00d4ff; padding: 10px; border-radius: 4px; pointer-events: none; display: none; max-width: 300px; z-index: 100; font-size: 11px; }
</style>
</head>
<body>
<h1>Function Graph: coverage_analyzer</h1>
<div class="subtitle">Stackable function dependency visualization • Drag nodes to rearrange • Click to inspect</div>

<div class="controls">
  <button onclick="resetView()">Reset View</button>
  <button onclick="fitToView()">Fit</button>
  <button onclick="toggleLayout('force')" id="btn-force" class="active">Force</button>
  <button onclick="toggleLayout('horizontal')" id="btn-horizontal">Horizontal</button>
  <button onclick="toggleLayout('vertical')" id="btn-vertical">Vertical</button>
  <span style="margin-left: 10px; color: #666">|</span>
  <button onclick="toggleEdgeType('internal')" id="btn-internal" class="active">Internal</button>
  <button onclick="toggleEdgeType('external')" id="btn-external" class="active">External</button>
  <button onclick="toggleEdgeType('local')" id="btn-local" class="active">Local</button>
</div>

<div id="container">
  <div id="graph"><svg></svg></div>
  <div id="sidebar">
    <h3>Modules</h3>
    <div class="module-legend" id="module-legend"></div>

    <h3>Selected Node</h3>
    <div class="info-section" id="node-info">Click a node to see details</div>

    <h3>Source Code</h3>
    <div class="source-panel" id="source-panel">
      <div id="source-content" style="color:#666;font-size:11px">Click a function to view source</div>
    </div>

    <h3>Connections</h3>
    <div class="edge-list" id="edge-list"></div>
  </div>
</div>
<div id="tooltip"></div>

<script>
const nodes = [{"id": "coverage_compute", "type": "module", "label": "coverage_compute", "metrics": {"fanIn": 18, "fanOut": 5, "instability": 0.217, "internalEdges": 6, "externalCallCount": 11, "localCallCount": 0, "callsByCategory": {"stdlib": 10, "pip": 1}, "localDependencies": []}, "moduleColor": "#00d4ff", "moduleName": "coverage_compute"}, {"id": "coverage_compute.load_blueprint", "type": "function", "label": "load_blueprint", "direction": "inbound", "parent": "coverage_compute", "line": 21, "endLine": 78, "signature": "(params) -> Dict[]", "docstring": "Load an L++ blueprint from a JSON file.", "source": "def load_blueprint(params: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Load an L++ blueprint from a JSON file.\"\"\"\n    path = params.get(\"path\")\n    if not path:\n        return {\"blueprint\": None, \"path\": None, \"error\": \"No path provided\"}\n\n    try:\n        path = Path(path)\n        if not path.exists():\n            return {\"blueprint\": None, \"path\": None,\n                    \"error\": f\"File not found: {path}\"}\n\n        with open(path) as f:\n            raw = json.load(f)\n\n        loader = BlueprintLoader(raw)\n        blueprint, loadError = loader.load()\n\n        if loadError:\n            return {\"blueprint\": None, \"path\": None, \"error\": loadError}\n\n        # Convert to dict structure for processing\n        bpData = {\n            \"id\": blueprint.id,\n            \"name\": blueprint.name,\n            \"version\": blueprint.version,\n            \"description\": blueprint.description,\n            \"states\": {\n                sid: {\"description\": s.description}\n                for sid, s in blueprint.states.items()\n            },\n            \"transitions\": [\n                {\n                    \"id\": t.id,\n                    \"from\": t.from_state,\n                    \"to\": t.to_state,\n                    \"on_event\": t.on_event,\n                    \"gates\": list(t.gates),\n                    \"actions\": list(t.actions)\n                }\n                for t in blueprint.transitions\n            ],\n            \"gates\": {\n                gid: {\"type\": \"expression\", \"expression\": g.expression}\n                for gid, g in blueprint.gates.items()\n            },\n            \"actions\": {\n                aid: {\"type\": a.type.value}\n                for aid, a in blueprint.actions.items()\n            },\n            \"entry_state\": blueprint.entry_state,\n            \"terminal_states\": list(blueprint.terminal_states)\n        }\n\n        return {\"blueprint\": bpData, \"path\": str(path), \"error\": None}\n\n    except Exception as e:\n        return {\"blueprint\": None, \"path\": None, \"error\": str(e)}", "args": ["params"], "returns": "Dict[]", "moduleColor": "#00d4ff", "moduleName": "coverage_compute"}, {"id": "coverage_compute.init_coverage", "type": "function", "label": "init_coverage", "direction": "inbound", "parent": "coverage_compute", "line": 85, "endLine": 132, "signature": "(params) -> Dict[]", "docstring": "Initialize coverage tracking for a blueprint.", "source": "def init_coverage(params: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Initialize coverage tracking for a blueprint.\"\"\"\n    bp = params.get(\"blueprint\")\n    if not bp:\n        return {\n            \"coverage_data\": None,\n            \"state_hits\": {},\n            \"transition_hits\": {},\n            \"gate_hits\": {},\n            \"action_hits\": {},\n            \"event_hits\": {}\n        }\n\n    # Initialize state hits (all states start at 0)\n    stateHits = {sid: 0 for sid in bp[\"states\"]}\n\n    # Initialize transition hits\n    transHits = {t[\"id\"]: 0 for t in bp[\"transitions\"]}\n\n    # Initialize gate hits with true/false breakdown\n    gateHits = {\n        gid: {\"total\": 0, \"true\": 0, \"false\": 0}\n        for gid in bp.get(\"gates\", {})\n    }\n\n    # Initialize action hits\n    actionHits = {aid: 0 for aid in bp.get(\"actions\", {})}\n\n    # Initialize event hits (from transitions)\n    events = set()\n    for t in bp[\"transitions\"]:\n        events.add(t[\"on_event\"])\n    eventHits = {evt: 0 for evt in events}\n\n    coverageData = {\n        \"initialized_at\": datetime.now().isoformat(),\n        \"blueprint_id\": bp[\"id\"],\n        \"blueprint_version\": bp[\"version\"]\n    }\n\n    return {\n        \"coverage_data\": coverageData,\n        \"state_hits\": stateHits,\n        \"transition_hits\": transHits,\n        \"gate_hits\": gateHits,\n        \"action_hits\": actionHits,\n        \"event_hits\": eventHits\n    }", "args": ["params"], "returns": "Dict[]", "moduleColor": "#00d4ff", "moduleName": "coverage_compute"}, {"id": "coverage_compute.record_state", "type": "function", "label": "record_state", "direction": "inbound", "parent": "coverage_compute", "line": 139, "endLine": 149, "signature": "(params) -> Dict[]", "docstring": "Record a state visit.", "source": "def record_state(params: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Record a state visit.\"\"\"\n    stateHits = params.get(\"state_hits\", {}).copy()\n    stateId = params.get(\"state_id\")\n\n    if stateId and stateId in stateHits:\n        stateHits[stateId] = stateHits.get(stateId, 0) + 1\n    elif stateId:\n        stateHits[stateId] = 1\n\n    return {\"state_hits\": stateHits}", "args": ["params"], "returns": "Dict[]", "moduleColor": "#00d4ff", "moduleName": "coverage_compute"}, {"id": "coverage_compute.record_transition", "type": "function", "label": "record_transition", "direction": "inbound", "parent": "coverage_compute", "line": 152, "endLine": 162, "signature": "(params) -> Dict[]", "docstring": "Record a transition being taken.", "source": "def record_transition(params: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Record a transition being taken.\"\"\"\n    transHits = params.get(\"transition_hits\", {}).copy()\n    transId = params.get(\"transition_id\")\n\n    if transId and transId in transHits:\n        transHits[transId] = transHits.get(transId, 0) + 1\n    elif transId:\n        transHits[transId] = 1\n\n    return {\"transition_hits\": transHits}", "args": ["params"], "returns": "Dict[]", "moduleColor": "#00d4ff", "moduleName": "coverage_compute"}, {"id": "coverage_compute.record_gate", "type": "function", "label": "record_gate", "direction": "inbound", "parent": "coverage_compute", "line": 165, "endLine": 181, "signature": "(params) -> Dict[]", "docstring": "Record a gate evaluation with its result.", "source": "def record_gate(params: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Record a gate evaluation with its result.\"\"\"\n    gateHits = params.get(\"gate_hits\", {}).copy()\n    gateId = params.get(\"gate_id\")\n    result = params.get(\"result\", True)\n\n    if gateId:\n        if gateId not in gateHits:\n            gateHits[gateId] = {\"total\": 0, \"true\": 0, \"false\": 0}\n\n        gateHits[gateId][\"total\"] += 1\n        if result:\n            gateHits[gateId][\"true\"] += 1\n        else:\n            gateHits[gateId][\"false\"] += 1\n\n    return {\"gate_hits\": gateHits}", "args": ["params"], "returns": "Dict[]", "moduleColor": "#00d4ff", "moduleName": "coverage_compute"}, {"id": "coverage_compute.record_action", "type": "function", "label": "record_action", "direction": "inbound", "parent": "coverage_compute", "line": 184, "endLine": 194, "signature": "(params) -> Dict[]", "docstring": "Record an action execution.", "source": "def record_action(params: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Record an action execution.\"\"\"\n    actionHits = params.get(\"action_hits\", {}).copy()\n    actionId = params.get(\"action_id\")\n\n    if actionId and actionId in actionHits:\n        actionHits[actionId] = actionHits.get(actionId, 0) + 1\n    elif actionId:\n        actionHits[actionId] = 1\n\n    return {\"action_hits\": actionHits}", "args": ["params"], "returns": "Dict[]", "moduleColor": "#00d4ff", "moduleName": "coverage_compute"}, {"id": "coverage_compute.record_event", "type": "function", "label": "record_event", "direction": "inbound", "parent": "coverage_compute", "line": 197, "endLine": 207, "signature": "(params) -> Dict[]", "docstring": "Record an event being dispatched.", "source": "def record_event(params: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Record an event being dispatched.\"\"\"\n    eventHits = params.get(\"event_hits\", {}).copy()\n    eventName = params.get(\"event_name\")\n\n    if eventName and eventName in eventHits:\n        eventHits[eventName] = eventHits.get(eventName, 0) + 1\n    elif eventName:\n        eventHits[eventName] = 1\n\n    return {\"event_hits\": eventHits}", "args": ["params"], "returns": "Dict[]", "moduleColor": "#00d4ff", "moduleName": "coverage_compute"}, {"id": "coverage_compute.import_trace", "type": "function", "label": "import_trace", "direction": "inbound", "parent": "coverage_compute", "line": 214, "endLine": 308, "signature": "(params) -> Dict[]", "docstring": "Import trace data from a file and update coverage.", "source": "def import_trace(params: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Import trace data from a file and update coverage.\"\"\"\n    path = params.get(\"path\")\n    stateHits = params.get(\"state_hits\", {}).copy()\n    transHits = params.get(\"transition_hits\", {}).copy()\n    gateHits = params.get(\"gate_hits\", {}).copy()\n    actionHits = params.get(\"action_hits\", {}).copy()\n    eventHits = params.get(\"event_hits\", {}).copy()\n\n    if not path:\n        return {\n            \"trace_data\": None,\n            \"state_hits\": stateHits,\n            \"transition_hits\": transHits,\n            \"gate_hits\": gateHits,\n            \"action_hits\": actionHits,\n            \"event_hits\": eventHits,\n            \"error\": \"No path provided\"\n        }\n\n    try:\n        tracePath = Path(path)\n        if not tracePath.exists():\n            return {\n                \"trace_data\": None,\n                \"state_hits\": stateHits,\n                \"transition_hits\": transHits,\n                \"gate_hits\": gateHits,\n                \"action_hits\": actionHits,\n                \"event_hits\": eventHits,\n                \"error\": f\"Trace file not found: {path}\"\n            }\n\n        with open(tracePath) as f:\n            traceData = json.load(f)\n\n        # Process trace entries\n        entries = traceData if isinstance(traceData, list) else traceData.get(\n            \"entries\", traceData.get(\"trace\", []))\n\n        for entry in entries:\n            entryType = entry.get(\"type\", \"\")\n\n            if entryType == \"state\" or \"state\" in entry:\n                sid = entry.get(\"state_id\", entry.get(\"state\"))\n                if sid:\n                    stateHits[sid] = stateHits.get(sid, 0) + 1\n\n            if entryType == \"transition\" or \"transition_id\" in entry:\n                tid = entry.get(\"transition_id\", entry.get(\"transition\"))\n                if tid:\n                    transHits[tid] = transHits.get(tid, 0) + 1\n\n            if entryType == \"gate\" or \"gate_id\" in entry:\n                gid = entry.get(\"gate_id\", entry.get(\"gate\"))\n                result = entry.get(\"result\", True)\n                if gid:\n                    if gid not in gateHits:\n                        gateHits[gid] = {\"total\": 0, \"true\": 0, \"false\": 0}\n                    gateHits[gid][\"total\"] += 1\n                    if result:\n                        gateHits[gid][\"true\"] += 1\n                    else:\n                        gateHits[gid][\"false\"] += 1\n\n            if entryType == \"action\" or \"action_id\" in entry:\n                aid = entry.get(\"action_id\", entry.get(\"action\"))\n                if aid:\n                    actionHits[aid] = actionHits.get(aid, 0) + 1\n\n            if entryType == \"event\" or \"event\" in entry:\n                evt = entry.get(\"event_name\", entry.get(\"event\"))\n                if evt:\n                    eventHits[evt] = eventHits.get(evt, 0) + 1\n\n        return {\n            \"trace_data\": entries,\n            \"state_hits\": stateHits,\n            \"transition_hits\": transHits,\n            \"gate_hits\": gateHits,\n            \"action_hits\": actionHits,\n            \"event_hits\": eventHits,\n            \"error\": None\n        }\n\n    except Exception as e:\n        return {\n            \"trace_data\": None,\n            \"state_hits\": stateHits,\n            \"transition_hits\": transHits,\n            \"gate_hits\": gateHits,\n            \"action_hits\": actionHits,\n            \"event_hits\": eventHits,\n            \"error\": str(e)\n        }", "args": ["params"], "returns": "Dict[]", "moduleColor": "#00d4ff", "moduleName": "coverage_compute"}, {"id": "coverage_compute.compute_metrics", "type": "function", "label": "compute_metrics", "direction": "inbound", "parent": "coverage_compute", "line": 315, "endLine": 425, "signature": "(params) -> Dict[]", "docstring": "Compute coverage metrics from hit data.", "source": "def compute_metrics(params: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Compute coverage metrics from hit data.\"\"\"\n    bp = params.get(\"blueprint\")\n    stateHits = params.get(\"state_hits\", {})\n    transHits = params.get(\"transition_hits\", {})\n    gateHits = params.get(\"gate_hits\", {})\n    actionHits = params.get(\"action_hits\", {})\n    eventHits = params.get(\"event_hits\", {})\n\n    if not bp:\n        return {\"metrics\": None}\n\n    # State coverage\n    totalStates = len(bp[\"states\"])\n    coveredStates = sum(1 for h in stateHits.values() if h > 0)\n    statePct = (coveredStates / totalStates * 100) if totalStates else 0\n\n    # Transition coverage\n    totalTrans = len(bp[\"transitions\"])\n    coveredTrans = sum(1 for h in transHits.values() if h > 0)\n    transPct = (coveredTrans / totalTrans * 100) if totalTrans else 0\n\n    # Gate coverage (evaluated at least once)\n    totalGates = len(bp.get(\"gates\", {}))\n    coveredGates = sum(1 for g in gateHits.values() if g.get(\"total\", 0) > 0)\n    gatePct = (coveredGates / totalGates * 100) if totalGates else 0\n\n    # Gate branch coverage (both true and false branches)\n    branchTotal = totalGates * 2  # Each gate has 2 branches\n    branchCovered = sum(\n        (1 if g.get(\"true\", 0) > 0 else 0) + (1 if g.get(\"false\", 0) > 0 else 0)\n        for g in gateHits.values()\n    )\n    branchPct = (branchCovered / branchTotal * 100) if branchTotal else 0\n\n    # Action coverage\n    totalActions = len(bp.get(\"actions\", {}))\n    coveredActions = sum(1 for h in actionHits.values() if h > 0)\n    actionPct = (coveredActions / totalActions * 100) if totalActions else 0\n\n    # Event coverage\n    allEvents = set(t[\"on_event\"] for t in bp[\"transitions\"])\n    totalEvents = len(allEvents)\n    coveredEvents = sum(1 for e, h in eventHits.items() if h > 0 and e in allEvents)\n    eventPct = (coveredEvents / totalEvents * 100) if totalEvents else 0\n\n    # Overall coverage (weighted average)\n    weights = {\n        \"state\": 0.25,\n        \"transition\": 0.35,\n        \"gate\": 0.20,\n        \"action\": 0.15,\n        \"event\": 0.05\n    }\n    overallPct = (\n        statePct * weights[\"state\"] +\n        transPct * weights[\"transition\"] +\n        gatePct * weights[\"gate\"] +\n        actionPct * weights[\"action\"] +\n        eventPct * weights[\"event\"]\n    )\n\n    metrics = {\n        \"computed_at\": datetime.now().isoformat(),\n        \"blueprint_id\": bp[\"id\"],\n        \"overall_percentage\": round(overallPct, 1),\n        \"state_coverage\": {\n            \"total\": totalStates,\n            \"covered\": coveredStates,\n            \"percentage\": round(statePct, 1),\n            \"uncovered\": [s for s, h in stateHits.items() if h == 0]\n        },\n        \"state_percentage\": round(statePct, 1),\n        \"transition_coverage\": {\n            \"total\": totalTrans,\n            \"covered\": coveredTrans,\n            \"percentage\": round(transPct, 1),\n            \"uncovered\": [t for t, h in transHits.items() if h == 0]\n        },\n        \"transition_percentage\": round(transPct, 1),\n        \"gate_coverage\": {\n            \"total\": totalGates,\n            \"covered\": coveredGates,\n            \"percentage\": round(gatePct, 1),\n            \"branch_coverage\": round(branchPct, 1),\n            \"uncovered\": [g for g, h in gateHits.items() if h.get(\"total\", 0) == 0],\n            \"missing_true\": [g for g, h in gateHits.items() if h.get(\"true\", 0) == 0],\n            \"missing_false\": [g for g, h in gateHits.items() if h.get(\"false\", 0) == 0]\n        },\n        \"action_coverage\": {\n            \"total\": totalActions,\n            \"covered\": coveredActions,\n            \"percentage\": round(actionPct, 1),\n            \"uncovered\": [a for a, h in actionHits.items() if h == 0]\n        },\n        \"event_coverage\": {\n            \"total\": totalEvents,\n            \"covered\": coveredEvents,\n            \"percentage\": round(eventPct, 1),\n            \"uncovered\": [e for e in allEvents if eventHits.get(e, 0) == 0]\n        },\n        \"hit_counts\": {\n            \"states\": dict(stateHits),\n            \"transitions\": dict(transHits),\n            \"gates\": {g: h.get(\"total\", 0) for g, h in gateHits.items()},\n            \"actions\": dict(actionHits),\n            \"events\": dict(eventHits)\n        }\n    }\n\n    return {\"metrics\": metrics}", "args": ["params"], "returns": "Dict[]", "moduleColor": "#00d4ff", "moduleName": "coverage_compute"}, {"id": "coverage_compute.generate_summary", "type": "function", "label": "generate_summary", "direction": "inbound", "parent": "coverage_compute", "line": 432, "endLine": 469, "signature": "(params) -> Dict[]", "docstring": "Generate a summary coverage report.", "source": "def generate_summary(params: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Generate a summary coverage report.\"\"\"\n    bp = params.get(\"blueprint\")\n    metrics = params.get(\"metrics\")\n\n    if not bp or not metrics:\n        return {\"report\": \"No metrics available\"}\n\n    lines = [\n        \"=\" * 60,\n        f\"  COVERAGE SUMMARY: {bp['name']}\",\n        \"=\" * 60,\n        \"\",\n        f\"  Overall Coverage: {metrics['overall_percentage']}%\",\n        \"\",\n        \"  Component Breakdown:\",\n        f\"    States:      {metrics['state_coverage']['covered']:3d}/\"\n        f\"{metrics['state_coverage']['total']:3d}  \"\n        f\"({metrics['state_coverage']['percentage']:5.1f}%)\",\n        f\"    Transitions: {metrics['transition_coverage']['covered']:3d}/\"\n        f\"{metrics['transition_coverage']['total']:3d}  \"\n        f\"({metrics['transition_coverage']['percentage']:5.1f}%)\",\n        f\"    Gates:       {metrics['gate_coverage']['covered']:3d}/\"\n        f\"{metrics['gate_coverage']['total']:3d}  \"\n        f\"({metrics['gate_coverage']['percentage']:5.1f}%)\",\n        f\"    Actions:     {metrics['action_coverage']['covered']:3d}/\"\n        f\"{metrics['action_coverage']['total']:3d}  \"\n        f\"({metrics['action_coverage']['percentage']:5.1f}%)\",\n        f\"    Events:      {metrics['event_coverage']['covered']:3d}/\"\n        f\"{metrics['event_coverage']['total']:3d}  \"\n        f\"({metrics['event_coverage']['percentage']:5.1f}%)\",\n        \"\",\n        f\"  Gate Branch Coverage: {metrics['gate_coverage']['branch_coverage']}%\",\n        \"\",\n        \"=\" * 60\n    ]\n\n    return {\"report\": \"\\n\".join(lines)}", "args": ["params"], "returns": "Dict[]", "moduleColor": "#00d4ff", "moduleName": "coverage_compute"}, {"id": "coverage_compute.generate_detailed", "type": "function", "label": "generate_detailed", "direction": "inbound", "parent": "coverage_compute", "line": 472, "endLine": 541, "signature": "(params) -> Dict[]", "docstring": "Generate a detailed coverage report with hit counts.", "source": "def generate_detailed(params: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Generate a detailed coverage report with hit counts.\"\"\"\n    bp = params.get(\"blueprint\")\n    metrics = params.get(\"metrics\")\n    stateHits = params.get(\"state_hits\", {})\n    transHits = params.get(\"transition_hits\", {})\n    gateHits = params.get(\"gate_hits\", {})\n    actionHits = params.get(\"action_hits\", {})\n\n    if not bp or not metrics:\n        return {\"report\": \"No metrics available\"}\n\n    lines = [\n        \"=\" * 70,\n        f\"  DETAILED COVERAGE REPORT: {bp['name']}\",\n        \"=\" * 70,\n        \"\",\n        \"  STATES\",\n        \"  \" + \"-\" * 66,\n    ]\n\n    for sid, hits in sorted(stateHits.items()):\n        status = \"[X]\" if hits > 0 else \"[ ]\"\n        desc = bp[\"states\"].get(sid, {}).get(\"description\", \"\")[:40]\n        lines.append(f\"    {status} {sid:25} hits={hits:4d}  {desc}\")\n\n    lines.extend([\n        \"\",\n        \"  TRANSITIONS\",\n        \"  \" + \"-\" * 66,\n    ])\n\n    for trans in bp[\"transitions\"]:\n        tid = trans[\"id\"]\n        hits = transHits.get(tid, 0)\n        status = \"[X]\" if hits > 0 else \"[ ]\"\n        arrow = f\"{trans['from']} --[{trans['on_event']}]--> {trans['to']}\"\n        lines.append(f\"    {status} {tid:20} hits={hits:4d}  {arrow[:35]}\")\n\n    lines.extend([\n        \"\",\n        \"  GATES\",\n        \"  \" + \"-\" * 66,\n    ])\n\n    for gid, data in sorted(gateHits.items()):\n        total = data.get(\"total\", 0)\n        trueHits = data.get(\"true\", 0)\n        falseHits = data.get(\"false\", 0)\n        status = \"[X]\" if total > 0 else \"[ ]\"\n        branchInfo = f\"T={trueHits}, F={falseHits}\"\n        lines.append(f\"    {status} {gid:25} hits={total:4d}  ({branchInfo})\")\n\n    lines.extend([\n        \"\",\n        \"  ACTIONS\",\n        \"  \" + \"-\" * 66,\n    ])\n\n    for aid, hits in sorted(actionHits.items()):\n        status = \"[X]\" if hits > 0 else \"[ ]\"\n        atype = bp.get(\"actions\", {}).get(aid, {}).get(\"type\", \"?\")\n        lines.append(f\"    {status} {aid:30} hits={hits:4d}  type={atype}\")\n\n    lines.extend([\n        \"\",\n        \"=\" * 70\n    ])\n\n    return {\"report\": \"\\n\".join(lines)}", "args": ["params"], "returns": "Dict[]", "moduleColor": "#00d4ff", "moduleName": "coverage_compute"}, {"id": "coverage_compute.generate_gap_report", "type": "function", "label": "generate_gap_report", "direction": "inbound", "parent": "coverage_compute", "line": 544, "endLine": 641, "signature": "(params) -> Dict[]", "docstring": "Generate a gap analysis report with suggestions.", "source": "def generate_gap_report(params: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Generate a gap analysis report with suggestions.\"\"\"\n    bp = params.get(\"blueprint\")\n    metrics = params.get(\"metrics\")\n    stateHits = params.get(\"state_hits\", {})\n    transHits = params.get(\"transition_hits\", {})\n    gateHits = params.get(\"gate_hits\", {})\n    actionHits = params.get(\"action_hits\", {})\n\n    if not bp or not metrics:\n        return {\"report\": \"No metrics available\"}\n\n    lines = [\n        \"=\" * 70,\n        f\"  COVERAGE GAP ANALYSIS: {bp['name']}\",\n        \"=\" * 70,\n        \"\",\n    ]\n\n    # Uncovered states\n    uncoveredStates = [s for s, h in stateHits.items() if h == 0]\n    if uncoveredStates:\n        lines.append(\"  UNCOVERED STATES\")\n        lines.append(\"  \" + \"-\" * 66)\n        for sid in uncoveredStates:\n            # Find how to reach this state\n            incomingTrans = [t for t in bp[\"transitions\"]\n                            if t[\"to\"] == sid and t[\"from\"] != \"*\"]\n            if incomingTrans:\n                suggestion = (f\"Try: dispatch('{incomingTrans[0]['on_event']}') \"\n                            f\"from state '{incomingTrans[0]['from']}'\")\n            else:\n                suggestion = \"No incoming transitions found\"\n            lines.append(f\"    - {sid}\")\n            lines.append(f\"      Suggestion: {suggestion}\")\n        lines.append(\"\")\n\n    # Uncovered transitions\n    uncoveredTrans = [t for t, h in transHits.items() if h == 0]\n    if uncoveredTrans:\n        lines.append(\"  UNCOVERED TRANSITIONS\")\n        lines.append(\"  \" + \"-\" * 66)\n        for tid in uncoveredTrans:\n            trans = next((t for t in bp[\"transitions\"] if t[\"id\"] == tid), None)\n            if trans:\n                gates = trans.get(\"gates\", [])\n                gateInfo = f\" (gates: {', '.join(gates)})\" if gates else \"\"\n                lines.append(f\"    - {tid}\")\n                lines.append(f\"      Path: {trans['from']} --[{trans['on_event']}]--> \"\n                           f\"{trans['to']}{gateInfo}\")\n                if gates:\n                    lines.append(f\"      Suggestion: Ensure gates pass: {gates}\")\n        lines.append(\"\")\n\n    # Gates missing branch coverage\n    missingTrue = [g for g, h in gateHits.items() if h.get(\"true\", 0) == 0]\n    missingFalse = [g for g, h in gateHits.items() if h.get(\"false\", 0) == 0]\n\n    if missingTrue or missingFalse:\n        lines.append(\"  INCOMPLETE GATE BRANCH COVERAGE\")\n        lines.append(\"  \" + \"-\" * 66)\n        for gid in set(missingTrue + missingFalse):\n            expr = bp.get(\"gates\", {}).get(gid, {}).get(\"expression\", \"?\")\n            branches = []\n            if gid in missingTrue:\n                branches.append(\"true\")\n            if gid in missingFalse:\n                branches.append(\"false\")\n            lines.append(f\"    - {gid}: missing {', '.join(branches)} branch\")\n            lines.append(f\"      Expression: {expr[:50]}\")\n        lines.append(\"\")\n\n    # Uncovered actions\n    uncoveredActions = [a for a, h in actionHits.items() if h == 0]\n    if uncoveredActions:\n        lines.append(\"  UNCOVERED ACTIONS\")\n        lines.append(\"  \" + \"-\" * 66)\n        for aid in uncoveredActions:\n            # Find which transitions use this action\n            usingTrans = [t[\"id\"] for t in bp[\"transitions\"]\n                         if aid in t.get(\"actions\", [])]\n            lines.append(f\"    - {aid}\")\n            if usingTrans:\n                lines.append(f\"      Used by: {', '.join(usingTrans[:3])}\")\n            else:\n                lines.append(\"      Warning: Action not used by any transition\")\n        lines.append(\"\")\n\n    if not any([uncoveredStates, uncoveredTrans, missingTrue, missingFalse,\n                uncoveredActions]):\n        lines.append(\"  No coverage gaps found! 100% coverage achieved.\")\n        lines.append(\"\")\n\n    lines.extend([\n        \"=\" * 70\n    ])\n\n    return {\"report\": \"\\n\".join(lines)}", "args": ["params"], "returns": "Dict[]", "moduleColor": "#00d4ff", "moduleName": "coverage_compute"}, {"id": "coverage_compute.export_html", "type": "function", "label": "export_html", "direction": "inbound", "parent": "coverage_compute", "line": 648, "endLine": 805, "signature": "(params) -> Dict[]", "docstring": "Generate an interactive HTML coverage report.", "source": "def export_html(params: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Generate an interactive HTML coverage report.\"\"\"\n    bp = params.get(\"blueprint\")\n    metrics = params.get(\"metrics\")\n    stateHits = params.get(\"state_hits\", {})\n    transHits = params.get(\"transition_hits\", {})\n    gateHits = params.get(\"gate_hits\", {})\n    actionHits = params.get(\"action_hits\", {})\n    outPath = params.get(\"path\")\n\n    if not bp or not metrics:\n        return {\"html\": None, \"path\": None}\n\n    # Color coding function\n    def covColor(pct):\n        if pct >= 80:\n            return \"#4caf50\"  # green\n        elif pct >= 50:\n            return \"#ff9800\"  # orange\n        else:\n            return \"#f44336\"  # red\n\n    def hitColor(hits):\n        if hits > 0:\n            return \"#e8f5e9\"  # light green\n        else:\n            return \"#ffebee\"  # light red\n\n    overallColor = covColor(metrics[\"overall_percentage\"])\n\n    html = f\"\"\"<!DOCTYPE html>\n<html>\n<head>\n    <title>Coverage Report: {bp['name']}</title>\n    <style>\n        body {{ font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 20px; }}\n        h1 {{ color: #333; }}\n        .summary {{ background: #f5f5f5; padding: 20px; border-radius: 8px; margin-bottom: 20px; }}\n        .overall {{ font-size: 48px; font-weight: bold; color: {overallColor}; }}\n        .metrics {{ display: flex; gap: 20px; flex-wrap: wrap; }}\n        .metric {{ background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); min-width: 150px; }}\n        .metric-value {{ font-size: 24px; font-weight: bold; }}\n        .metric-label {{ color: #666; font-size: 12px; text-transform: uppercase; }}\n        table {{ border-collapse: collapse; width: 100%; margin: 20px 0; }}\n        th, td {{ padding: 10px; text-align: left; border-bottom: 1px solid #ddd; }}\n        th {{ background: #f5f5f5; }}\n        .hit {{ background: #e8f5e9; }}\n        .miss {{ background: #ffebee; }}\n        .section {{ margin: 30px 0; }}\n        .bar {{ height: 20px; border-radius: 10px; background: #eee; overflow: hidden; }}\n        .bar-fill {{ height: 100%; transition: width 0.3s; }}\n    </style>\n</head>\n<body>\n    <h1>Coverage Report: {bp['name']}</h1>\n    <p>Generated: {metrics['computed_at']}</p>\n\n    <div class=\"summary\">\n        <div class=\"overall\">{metrics['overall_percentage']}%</div>\n        <div>Overall Coverage</div>\n    </div>\n\n    <div class=\"metrics\">\n        <div class=\"metric\">\n            <div class=\"metric-value\" style=\"color: {covColor(metrics['state_coverage']['percentage'])}\">{metrics['state_coverage']['percentage']}%</div>\n            <div class=\"metric-label\">State Coverage</div>\n            <div>{metrics['state_coverage']['covered']}/{metrics['state_coverage']['total']}</div>\n        </div>\n        <div class=\"metric\">\n            <div class=\"metric-value\" style=\"color: {covColor(metrics['transition_coverage']['percentage'])}\">{metrics['transition_coverage']['percentage']}%</div>\n            <div class=\"metric-label\">Transition Coverage</div>\n            <div>{metrics['transition_coverage']['covered']}/{metrics['transition_coverage']['total']}</div>\n        </div>\n        <div class=\"metric\">\n            <div class=\"metric-value\" style=\"color: {covColor(metrics['gate_coverage']['percentage'])}\">{metrics['gate_coverage']['percentage']}%</div>\n            <div class=\"metric-label\">Gate Coverage</div>\n            <div>{metrics['gate_coverage']['covered']}/{metrics['gate_coverage']['total']}</div>\n        </div>\n        <div class=\"metric\">\n            <div class=\"metric-value\" style=\"color: {covColor(metrics['action_coverage']['percentage'])}\">{metrics['action_coverage']['percentage']}%</div>\n            <div class=\"metric-label\">Action Coverage</div>\n            <div>{metrics['action_coverage']['covered']}/{metrics['action_coverage']['total']}</div>\n        </div>\n    </div>\n\n    <div class=\"section\">\n        <h2>States</h2>\n        <table>\n            <tr><th>State</th><th>Hits</th><th>Description</th></tr>\n\"\"\"\n\n    for sid, hits in sorted(stateHits.items()):\n        cls = \"hit\" if hits > 0 else \"miss\"\n        desc = bp[\"states\"].get(sid, {}).get(\"description\", \"\")\n        html += f'            <tr class=\"{cls}\"><td>{sid}</td><td>{hits}</td><td>{desc}</td></tr>\\n'\n\n    html += \"\"\"        </table>\n    </div>\n\n    <div class=\"section\">\n        <h2>Transitions</h2>\n        <table>\n            <tr><th>ID</th><th>From</th><th>Event</th><th>To</th><th>Hits</th></tr>\n\"\"\"\n\n    for trans in bp[\"transitions\"]:\n        tid = trans[\"id\"]\n        hits = transHits.get(tid, 0)\n        cls = \"hit\" if hits > 0 else \"miss\"\n        html += f'            <tr class=\"{cls}\"><td>{tid}</td><td>{trans[\"from\"]}</td><td>{trans[\"on_event\"]}</td><td>{trans[\"to\"]}</td><td>{hits}</td></tr>\\n'\n\n    html += \"\"\"        </table>\n    </div>\n\n    <div class=\"section\">\n        <h2>Gates</h2>\n        <table>\n            <tr><th>Gate</th><th>Total Hits</th><th>True</th><th>False</th><th>Expression</th></tr>\n\"\"\"\n\n    for gid, data in sorted(gateHits.items()):\n        total = data.get(\"total\", 0)\n        cls = \"hit\" if total > 0 else \"miss\"\n        expr = bp.get(\"gates\", {}).get(gid, {}).get(\"expression\", \"\")[:50]\n        html += f'            <tr class=\"{cls}\"><td>{gid}</td><td>{total}</td><td>{data.get(\"true\", 0)}</td><td>{data.get(\"false\", 0)}</td><td>{expr}</td></tr>\\n'\n\n    html += \"\"\"        </table>\n    </div>\n\n    <div class=\"section\">\n        <h2>Actions</h2>\n        <table>\n            <tr><th>Action</th><th>Hits</th><th>Type</th></tr>\n\"\"\"\n\n    for aid, hits in sorted(actionHits.items()):\n        cls = \"hit\" if hits > 0 else \"miss\"\n        atype = bp.get(\"actions\", {}).get(aid, {}).get(\"type\", \"?\")\n        html += f'            <tr class=\"{cls}\"><td>{aid}</td><td>{hits}</td><td>{atype}</td></tr>\\n'\n\n    html += \"\"\"        </table>\n    </div>\n</body>\n</html>\"\"\"\n\n    # Write to file if path provided\n    if outPath:\n        try:\n            outFile = Path(outPath)\n            if not outFile.suffix:\n                outFile = outFile.with_suffix(\".html\")\n            outFile.parent.mkdir(parents=True, exist_ok=True)\n            outFile.write_text(html)\n            return {\"html\": html, \"path\": str(outFile)}\n        except Exception as e:\n            return {\"html\": html, \"path\": None, \"error\": str(e)}\n\n    return {\"html\": html, \"path\": None}", "args": ["params"], "returns": "Dict[]", "moduleColor": "#00d4ff", "moduleName": "coverage_compute"}, {"id": "coverage_compute.export_json", "type": "function", "label": "export_json", "direction": "inbound", "parent": "coverage_compute", "line": 808, "endLine": 853, "signature": "(params) -> Dict[]", "docstring": "Export coverage data as JSON.", "source": "def export_json(params: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Export coverage data as JSON.\"\"\"\n    bp = params.get(\"blueprint\")\n    metrics = params.get(\"metrics\")\n    stateHits = params.get(\"state_hits\", {})\n    transHits = params.get(\"transition_hits\", {})\n    gateHits = params.get(\"gate_hits\", {})\n    actionHits = params.get(\"action_hits\", {})\n    eventHits = params.get(\"event_hits\", {})\n    outPath = params.get(\"path\")\n\n    if not bp or not metrics:\n        return {\"json\": None, \"path\": None}\n\n    data = {\n        \"coverage_report\": {\n            \"blueprint_id\": bp[\"id\"],\n            \"blueprint_name\": bp[\"name\"],\n            \"blueprint_version\": bp[\"version\"],\n            \"generated_at\": datetime.now().isoformat(),\n            \"metrics\": metrics,\n            \"raw_data\": {\n                \"state_hits\": stateHits,\n                \"transition_hits\": transHits,\n                \"gate_hits\": gateHits,\n                \"action_hits\": actionHits,\n                \"event_hits\": eventHits\n            }\n        }\n    }\n\n    jsonStr = json.dumps(data, indent=2)\n\n    # Write to file if path provided\n    if outPath:\n        try:\n            outFile = Path(outPath)\n            if not outFile.suffix:\n                outFile = outFile.with_suffix(\".json\")\n            outFile.parent.mkdir(parents=True, exist_ok=True)\n            outFile.write_text(jsonStr)\n            return {\"json\": jsonStr, \"path\": str(outFile)}\n        except Exception as e:\n            return {\"json\": jsonStr, \"path\": None, \"error\": str(e)}\n\n    return {\"json\": jsonStr, \"path\": None}", "args": ["params"], "returns": "Dict[]", "moduleColor": "#00d4ff", "moduleName": "coverage_compute"}, {"id": "coverage_compute.reset_coverage", "type": "function", "label": "reset_coverage", "direction": "inbound", "parent": "coverage_compute", "line": 860, "endLine": 872, "signature": "(params) -> Dict[]", "docstring": "Reset coverage data while keeping blueprint loaded.", "source": "def reset_coverage(params: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Reset coverage data while keeping blueprint loaded.\"\"\"\n    bp = params.get(\"blueprint\")\n    result = init_coverage({\"blueprint\": bp})\n    result.update({\n        \"metrics\": None,\n        \"summary_report\": None,\n        \"detailed_report\": None,\n        \"gap_report\": None,\n        \"html_report\": None,\n        \"json_report\": None\n    })\n    return result", "args": ["params"], "returns": "Dict[]", "moduleColor": "#00d4ff", "moduleName": "coverage_compute"}, {"id": "coverage_compute.clear_all", "type": "function", "label": "clear_all", "direction": "inbound", "parent": "coverage_compute", "line": 875, "endLine": 894, "signature": "(params) -> Dict[]", "docstring": "Clear all state including blueprint.", "source": "def clear_all(params: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Clear all state including blueprint.\"\"\"\n    return {\n        \"blueprint\": None,\n        \"blueprint_path\": None,\n        \"coverage_data\": None,\n        \"state_hits\": {},\n        \"transition_hits\": {},\n        \"gate_hits\": {},\n        \"action_hits\": {},\n        \"event_hits\": {},\n        \"metrics\": None,\n        \"summary_report\": None,\n        \"detailed_report\": None,\n        \"gap_report\": None,\n        \"html_report\": None,\n        \"json_report\": None,\n        \"trace_data\": None,\n        \"error\": None\n    }", "args": ["params"], "returns": "Dict[]", "moduleColor": "#00d4ff", "moduleName": "coverage_compute"}, {"id": "coverage_compute.covColor", "type": "function", "label": "covColor", "direction": "inbound", "parent": "coverage_compute", "line": 662, "endLine": 668, "signature": "(pct)", "docstring": null, "source": "    def covColor(pct):\n        if pct >= 80:\n            return \"#4caf50\"  # green\n        elif pct >= 50:\n            return \"#ff9800\"  # orange\n        else:\n            return \"#f44336\"  # red", "args": ["pct"], "returns": null, "moduleColor": "#00d4ff", "moduleName": "coverage_compute"}, {"id": "coverage_compute.hitColor", "type": "function", "label": "hitColor", "direction": "inbound", "parent": "coverage_compute", "line": 670, "endLine": 674, "signature": "(hits)", "docstring": null, "source": "    def hitColor(hits):\n        if hits > 0:\n            return \"#e8f5e9\"  # light green\n        else:\n            return \"#ffebee\"  # light red", "args": ["hits"], "returns": null, "moduleColor": "#00d4ff", "moduleName": "coverage_compute"}, {"id": "json", "type": "dependency", "label": "json", "direction": "outbound", "category": "stdlib", "moduleColor": "#00d4ff", "moduleName": "coverage_compute"}, {"id": "datetime", "type": "dependency", "label": "datetime", "direction": "outbound", "category": "stdlib", "moduleColor": "#00d4ff", "moduleName": "coverage_compute"}, {"id": "pathlib", "type": "dependency", "label": "pathlib", "direction": "outbound", "category": "stdlib", "moduleColor": "#00d4ff", "moduleName": "coverage_compute"}, {"id": "typing", "type": "dependency", "label": "typing", "direction": "outbound", "category": "stdlib", "moduleColor": "#00d4ff", "moduleName": "coverage_compute"}, {"id": "frame_py.loader", "type": "dependency", "label": "loader", "direction": "outbound", "category": "pip", "moduleColor": "#00d4ff", "moduleName": "coverage_compute"}];
const edges = [{"from": "coverage_compute.export_html", "to": "coverage_compute.covColor", "type": "internal", "line": 676}, {"from": "coverage_compute.export_html", "to": "coverage_compute.covColor", "type": "internal", "line": 712}, {"from": "coverage_compute.export_html", "to": "coverage_compute.covColor", "type": "internal", "line": 717}, {"from": "coverage_compute.export_html", "to": "coverage_compute.covColor", "type": "internal", "line": 722}, {"from": "coverage_compute.export_html", "to": "coverage_compute.covColor", "type": "internal", "line": 727}, {"from": "coverage_compute.reset_coverage", "to": "coverage_compute.init_coverage", "type": "internal", "line": 863}, {"from": "coverage_compute.load_blueprint", "to": "pathlib", "type": "external", "category": "stdlib", "line": 28}, {"from": "coverage_compute.load_blueprint", "to": "json", "type": "external", "category": "stdlib", "line": 34}, {"from": "coverage_compute.load_blueprint", "to": "frame_py", "type": "external", "category": "pip", "line": 36}, {"from": "coverage_compute.init_coverage", "to": "datetime", "type": "external", "category": "stdlib", "line": 120}, {"from": "coverage_compute.import_trace", "to": "pathlib", "type": "external", "category": "stdlib", "line": 235}, {"from": "coverage_compute.import_trace", "to": "json", "type": "external", "category": "stdlib", "line": 248}, {"from": "coverage_compute.compute_metrics", "to": "datetime", "type": "external", "category": "stdlib", "line": 378}, {"from": "coverage_compute.export_html", "to": "pathlib", "type": "external", "category": "stdlib", "line": 796}, {"from": "coverage_compute.export_json", "to": "datetime", "type": "external", "category": "stdlib", "line": 827}, {"from": "coverage_compute.export_json", "to": "json", "type": "external", "category": "stdlib", "line": 839}, {"from": "coverage_compute.export_json", "to": "pathlib", "type": "external", "category": "stdlib", "line": 844}];
const moduleColors = {"coverage_compute": "#00d4ff"};

// Edge type visibility
const edgeVisibility = { internal: true, external: true, local: true };
let currentLayout = 'force';

// Create node lookup
const nodeById = {};
nodes.forEach(n => nodeById[n.id] = n);

// Setup SVG
const container = document.getElementById('graph');
const width = container.clientWidth;
const height = container.clientHeight || 600;

const svg = d3.select("svg").attr("viewBox", [0, 0, width, height]);
const g = svg.append("g");

// Zoom behavior
const zoom = d3.zoom()
    .scaleExtent([0.1, 4])
    .filter(e => !e.target.closest('.node'))
    .on("zoom", e => g.attr("transform", e.transform));
svg.call(zoom);

// Arrow markers
const defs = svg.append("defs");
["internal", "external", "local"].forEach(type => {
    const color = type === "internal" ? "#4ecdc4" : type === "external" ? "#f39c12" : "#9b59b6";
    defs.append("marker")
        .attr("id", `arrow-${type}`)
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 20)
        .attr("refY", 0)
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M0,-4L10,0L0,4")
        .attr("fill", color);
});

// Build module legend
const legendDiv = document.getElementById('module-legend');
Object.entries(moduleColors).forEach(([mod, color]) => {
    const item = document.createElement('div');
    item.className = 'module-item';
    item.innerHTML = `<div class="module-dot" style="background:${color}"></div><span class="module-name">${mod}</span>`;
    item.onclick = () => highlightModule(mod);
    legendDiv.appendChild(item);
});

// Process edges - resolve node references
const processedEdges = edges.map(e => ({
    ...e,
    source: nodeById[e.from] || { id: e.from, x: 0, y: 0 },
    target: nodeById[e.to] || { id: e.to, x: 0, y: 0 }
})).filter(e => e.source && e.target);

// Force simulation
const simulation = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(processedEdges).id(d => d.id).distance(80).strength(0.5))
    .force("charge", d3.forceManyBody().strength(-300))
    .force("center", d3.forceCenter(width / 2, height / 2))
    .force("collision", d3.forceCollide().radius(40));

// Draw edges
const edge = g.append("g").selectAll("path")
    .data(processedEdges)
    .join("path")
    .attr("class", d => `edge edge-${d.type || 'internal'}`)
    .attr("marker-end", d => `url(#arrow-${d.type || 'internal'})`);

// Node size based on type
function nodeSize(d) {
    if (d.type === 'module') return { w: 120, h: 40 };
    if (d.type === 'function' || d.type === 'async_function') return { w: 100, h: 30 };
    if (d.type === 'class') return { w: 110, h: 35 };
    return { w: 80, h: 25 };  // dependency
}

// Draw nodes
const node = g.append("g").selectAll("g")
    .data(nodes)
    .join("g")
    .attr("class", "node")
    .call(d3.drag()
        .on("start", dragStart)
        .on("drag", dragging)
        .on("end", dragEnd));

node.append("rect")
    .attr("class", d => `node-${d.type === 'dependency' ? 'dependency' : d.type === 'module' ? 'module' : 'function'}`)
    .attr("width", d => nodeSize(d).w)
    .attr("height", d => nodeSize(d).h)
    .attr("x", d => -nodeSize(d).w / 2)
    .attr("y", d => -nodeSize(d).h / 2)
    .attr("rx", 6)
    .attr("stroke", d => d.moduleColor || "#666");

node.append("text")
    .attr("class", "node-label")
    .attr("text-anchor", "middle")
    .attr("dy", d => d.signature ? -3 : 4)
    .text(d => d.label || d.id);

node.filter(d => d.signature).append("text")
    .attr("class", "node-sublabel")
    .attr("text-anchor", "middle")
    .attr("dy", 10)
    .text(d => d.signature.length > 20 ? d.signature.slice(0, 18) + ".." : d.signature);

// Tooltip
const tooltip = d3.select("#tooltip");
node.on("mouseover", (e, d) => {
    let html = `<b>${d.label || d.id}</b>`;
    if (d.type) html += `<br><span style="color:#888">${d.type}</span>`;
    if (d.signature) html += `<br><code>${d.signature}</code>`;
    if (d.direction) html += `<br>Direction: ${d.direction}`;
    tooltip.style("display", "block").html(html);
})
.on("mousemove", e => {
    tooltip.style("left", (e.pageX + 15) + "px").style("top", (e.pageY - 10) + "px");
})
.on("mouseout", () => tooltip.style("display", "none"));

// Click to select
node.on("click", (e, d) => {
    e.stopPropagation();
    selectNode(d);
});

svg.on("click", () => clearSelection());

// Update positions
simulation.on("tick", () => {
    edge.attr("d", d => {
        if (!d.source || !d.target) return "";
        const dx = d.target.x - d.source.x;
        const dy = d.target.y - d.source.y;
        const dr = Math.sqrt(dx * dx + dy * dy) * 1.5;
        return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
    });
    node.attr("transform", d => `translate(${d.x},${d.y})`);
});

// Drag functions
function dragStart(e, d) {
    if (!e.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
}
function dragging(e, d) {
    d.fx = e.x;
    d.fy = e.y;
}
function dragEnd(e, d) {
    if (!e.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
}

// Selection functions
let selectedNode = null;

function selectNode(d) {
    selectedNode = d;
    
    // Highlight node
    node.classed("dim", n => n.id !== d.id && !isConnected(d, n));
    node.select("rect").attr("stroke-width", n => n.id === d.id ? 4 : 2);
    
    // Highlight edges
    edge.classed("dim", e => e.source.id !== d.id && e.target.id !== d.id);
    edge.classed("highlight", e => e.source.id === d.id || e.target.id === d.id);
    
    // Update info panel
    updateNodeInfo(d);
    updateEdgeList(d);
}

function clearSelection() {
    selectedNode = null;
    node.classed("dim", false);
    node.select("rect").attr("stroke-width", 2);
    edge.classed("dim", false).classed("highlight", false);
    document.getElementById('node-info').innerHTML = 'Click a node to see details';
    document.getElementById('edge-list').innerHTML = '';
}

function isConnected(a, b) {
    return processedEdges.some(e => 
        (e.source.id === a.id && e.target.id === b.id) ||
        (e.source.id === b.id && e.target.id === a.id)
    );
}

function updateNodeInfo(d) {
    let html = `<div class="metric"><span class="info-label">ID:</span><span class="info-value">${d.id}</span></div>`;
    html += `<div class="metric"><span class="info-label">Type:</span><span class="info-value">${d.type}</span></div>`;
    if (d.moduleName) html += `<div class="metric"><span class="info-label">Module:</span><span class="info-value">${d.moduleName}</span></div>`;
    if (d.line) html += `<div class="metric"><span class="info-label">Line:</span><span class="info-value">${d.line}${d.endLine ? '-' + d.endLine : ''}</span></div>`;
    if (d.signature) html += `<div class="metric"><span class="info-label">Signature:</span><span class="info-value" style="font-family:monospace">${d.signature}</span></div>`;
    if (d.direction) html += `<div class="metric"><span class="info-label">Direction:</span><span class="info-value">${d.direction}</span></div>`;
    if (d.category) html += `<div class="metric"><span class="info-label">Category:</span><span class="info-value">${d.category}</span></div>`;

    if (d.metrics) {
        html += `<div style="margin-top:10px"><b>Coupling Metrics</b></div>`;
        html += `<div class="metric"><span class="info-label">Fan-In:</span><span class="info-value">${d.metrics.fanIn}</span></div>`;
        html += `<div class="metric"><span class="info-label">Fan-Out:</span><span class="info-value">${d.metrics.fanOut}</span></div>`;
        html += `<div class="metric"><span class="info-label">Instability:</span><span class="info-value">${(d.metrics.instability * 100).toFixed(1)}%</span></div>`;
        html += `<div class="metric-bar"><div class="metric-fill" style="width:${d.metrics.instability * 100}%;background:${d.metrics.instability > 0.5 ? '#ff6b6b' : '#4ecdc4'}"></div></div>`;
        html += `<div class="metric"><span class="info-label">Internal Edges:</span><span class="info-value">${d.metrics.internalEdges}</span></div>`;
    }

    document.getElementById('node-info').innerHTML = html;

    // Update source code panel
    updateSourcePanel(d);
}

function escapeHtml(str) {
    if (!str) return '';
    return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function updateSourcePanel(d) {
    const panel = document.getElementById('source-content');

    if (d.source) {
        let sourceHtml = '';
        if (d.docstring) {
            sourceHtml += `<div class="docstring" style="margin-bottom:8px;padding:5px;background:#1a1a2a;border-radius:3px">${escapeHtml(d.docstring)}</div>`;
        }
        sourceHtml += `<div class="source-code">${escapeHtml(d.source)}</div>`;
        panel.innerHTML = sourceHtml;
    } else if (d.type === 'module') {
        panel.innerHTML = `<div style="color:#888;font-size:11px">Module: ${d.label}<br>Click a function to view its source code.</div>`;
    } else if (d.type === 'dependency') {
        panel.innerHTML = `<div style="color:#888;font-size:11px">External dependency: ${d.label}<br>Category: ${d.category || 'unknown'}</div>`;
    } else {
        panel.innerHTML = `<div style="color:#666;font-size:11px">No source available for this node</div>`;
    }
}

function updateEdgeList(d) {
    const outgoing = processedEdges.filter(e => e.source.id === d.id);
    const incoming = processedEdges.filter(e => e.target.id === d.id);
    
    let html = '';
    if (outgoing.length) {
        html += '<div style="color:#4ecdc4;font-weight:bold;margin-bottom:5px">Outgoing →</div>';
        outgoing.forEach(e => {
            html += `<div class="edge-item">→ <span class="to">${e.target.id || e.to}</span> <span class="type">[${e.type}]</span></div>`;
        });
    }
    if (incoming.length) {
        html += '<div style="color:#f39c12;font-weight:bold;margin:10px 0 5px 0">← Incoming</div>';
        incoming.forEach(e => {
            html += `<div class="edge-item">← <span class="from">${e.source.id || e.from}</span> <span class="type">[${e.type}]</span></div>`;
        });
    }
    if (!outgoing.length && !incoming.length) {
        html = '<div style="color:#666">No connections</div>';
    }
    
    document.getElementById('edge-list').innerHTML = html;
}

function highlightModule(modName) {
    node.classed("dim", n => n.moduleName !== modName && n.type !== 'dependency');
    edge.classed("dim", e => {
        const srcMod = nodeById[e.source.id]?.moduleName;
        const tgtMod = nodeById[e.target.id]?.moduleName;
        return srcMod !== modName && tgtMod !== modName;
    });
}

// Layout functions
function toggleLayout(layout) {
    currentLayout = layout;
    document.querySelectorAll('.controls button').forEach(b => {
        if (b.id.startsWith('btn-') && ['force', 'horizontal', 'vertical'].includes(b.id.replace('btn-', ''))) {
            b.classList.toggle('active', b.id === `btn-${layout}`);
        }
    });
    
    if (layout === 'force') {
        simulation.alpha(1).restart();
    } else {
        simulation.stop();
        layoutNodes(layout);
    }
}

function layoutNodes(layout) {
    const modules = [...new Set(nodes.filter(n => n.type === 'module').map(n => n.id))];
    const padding = 50;
    
    if (layout === 'horizontal') {
        // Group by module, spread horizontally
        modules.forEach((mod, mi) => {
            const modNodes = nodes.filter(n => n.moduleName === mod || n.id === mod);
            const x = padding + mi * (width - padding * 2) / Math.max(modules.length - 1, 1);
            modNodes.forEach((n, ni) => {
                n.x = x;
                n.y = padding + ni * 50;
            });
        });
        // Dependencies on the right
        const deps = nodes.filter(n => n.type === 'dependency');
        deps.forEach((n, i) => {
            n.x = width - padding;
            n.y = padding + i * 40;
        });
    } else if (layout === 'vertical') {
        // Modules at top, functions below, dependencies at bottom
        const modNodes = nodes.filter(n => n.type === 'module');
        const funcNodes = nodes.filter(n => n.type === 'function' || n.type === 'async_function' || n.type === 'class');
        const depNodes = nodes.filter(n => n.type === 'dependency');
        
        modNodes.forEach((n, i) => {
            n.x = padding + i * 150;
            n.y = padding;
        });
        funcNodes.forEach((n, i) => {
            n.x = padding + (i % 6) * 130;
            n.y = 120 + Math.floor(i / 6) * 60;
        });
        depNodes.forEach((n, i) => {
            n.x = padding + (i % 8) * 100;
            n.y = height - padding - 50;
        });
    }
    
    // Update positions
    node.transition().duration(500).attr("transform", d => `translate(${d.x},${d.y})`);
    edge.transition().duration(500).attr("d", d => {
        if (!d.source || !d.target) return "";
        const dx = d.target.x - d.source.x;
        const dy = d.target.y - d.source.y;
        const dr = Math.sqrt(dx * dx + dy * dy) * 1.5;
        return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
    });
}

// Edge type toggle
function toggleEdgeType(type) {
    edgeVisibility[type] = !edgeVisibility[type];
    document.getElementById(`btn-${type}`).classList.toggle('active', edgeVisibility[type]);
    edge.style("display", d => edgeVisibility[d.type || 'internal'] ? null : "none");
}

// View controls
function resetView() {
    svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity);
}

function fitToView() {
    const bounds = g.node().getBBox();
    const scale = Math.min(width / bounds.width, height / bounds.height) * 0.9;
    const tx = (width - bounds.width * scale) / 2 - bounds.x * scale;
    const ty = (height - bounds.height * scale) / 2 - bounds.y * scale;
    svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
}

// Initial fit
setTimeout(fitToView, 1000);
</script>
</body>
</html>