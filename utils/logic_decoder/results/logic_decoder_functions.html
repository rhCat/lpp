<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<title>Function Graph: logic_decoder</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
body { font-family: 'Segoe UI', Arial, sans-serif; margin: 0; padding: 20px; background: #0f0f23; color: #eee; }
h1 { color: #00d4ff; margin-bottom: 5px; font-size: 24px; }
.subtitle { color: #888; margin-bottom: 15px; font-size: 14px; }
#container { display: flex; gap: 20px; height: calc(100vh - 120px); }
#graph { flex: 1; position: relative; }
#sidebar { width: 350px; background: #1a1a2e; padding: 15px; border-radius: 8px; overflow-y: auto; }
svg { background: #16213e; border-radius: 8px; width: 100%; height: 100%; }

/* Node styles */
.node { cursor: pointer; }
.node-module { fill: #2a2a4a; stroke-width: 3; }
.node-function { fill: #3a3a5a; stroke-width: 2; }
.node-dependency { fill: #1a1a3a; stroke: #666; stroke-width: 1; stroke-dasharray: 4; }
.node-label { font-size: 11px; fill: #fff; pointer-events: none; font-weight: 500; }
.node-sublabel { font-size: 9px; fill: #888; pointer-events: none; }

/* Edge styles */
.edge { fill: none; stroke-opacity: 0.6; }
.edge-internal { stroke: #4ecdc4; stroke-width: 2; }
.edge-external { stroke: #f39c12; stroke-width: 1.5; stroke-dasharray: 4; }
.edge-local { stroke: #9b59b6; stroke-width: 2; }
.edge-label { font-size: 8px; fill: #666; pointer-events: none; }

/* Highlight styles */
.highlight { stroke-width: 3 !important; stroke-opacity: 1 !important; }
.dim { opacity: 0.2; }

/* Controls */
.controls { display: flex; gap: 8px; margin-bottom: 10px; flex-wrap: wrap; }
.controls button { background: #3a3a5a; color: #fff; border: 1px solid #555; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; }
.controls button:hover { background: #4a4a6a; }
.controls button.active { background: #00d4ff; color: #000; border-color: #00d4ff; }

/* Module legend */
.module-legend { margin-top: 15px; }
.module-item { display: flex; align-items: center; gap: 8px; padding: 5px 0; cursor: pointer; }
.module-item:hover { background: #2a2a4a; }
.module-dot { width: 12px; height: 12px; border-radius: 3px; }
.module-name { font-size: 12px; }

/* Info panel */
h3 { color: #00d4ff; margin: 15px 0 8px 0; font-size: 14px; border-bottom: 1px solid #333; padding-bottom: 5px; }
.info-section { font-size: 12px; line-height: 1.6; }
.info-label { color: #888; }
.info-value { color: #fff; }

/* Source code panel */
.source-panel { margin-top: 10px; }
.source-code { background: #0d0d1a; border: 1px solid #333; border-radius: 4px; padding: 10px; font-family: 'Consolas', 'Monaco', monospace; font-size: 11px; line-height: 1.4; overflow-x: auto; max-height: 300px; overflow-y: auto; white-space: pre; color: #b8b8b8; }
.source-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
.source-toggle { background: #3a3a5a; color: #fff; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 10px; }
.source-toggle:hover { background: #4a4a6a; }
.docstring { color: #6a9955; font-style: italic; }
.metric { display: flex; justify-content: space-between; padding: 3px 0; }
.metric-bar { height: 4px; background: #333; border-radius: 2px; margin-top: 2px; }
.metric-fill { height: 100%; border-radius: 2px; }

/* Edge list */
.edge-list { max-height: 200px; overflow-y: auto; }
.edge-item { padding: 4px 0; border-bottom: 1px solid #333; font-size: 11px; }
.edge-item .from { color: #4ecdc4; }
.edge-item .to { color: #f39c12; }
.edge-item .type { color: #666; font-size: 10px; }

/* Tooltip */
#tooltip { position: absolute; background: #1a1a2e; border: 1px solid #00d4ff; padding: 10px; border-radius: 4px; pointer-events: none; display: none; max-width: 300px; z-index: 100; font-size: 11px; }
</style>
</head>
<body>
<h1>Function Graph: logic_decoder</h1>
<div class="subtitle">Stackable function dependency visualization • Drag nodes to rearrange • Click to inspect</div>

<div class="controls">
  <button onclick="resetView()">Reset View</button>
  <button onclick="fitToView()">Fit</button>
  <button onclick="toggleLayout('force')" id="btn-force" class="active">Force</button>
  <button onclick="toggleLayout('horizontal')" id="btn-horizontal">Horizontal</button>
  <button onclick="toggleLayout('vertical')" id="btn-vertical">Vertical</button>
  <span style="margin-left: 10px; color: #666">|</span>
  <button onclick="toggleEdgeType('internal')" id="btn-internal" class="active">Internal</button>
  <button onclick="toggleEdgeType('external')" id="btn-external" class="active">External</button>
  <button onclick="toggleEdgeType('local')" id="btn-local" class="active">Local</button>
</div>

<div id="container">
  <div id="graph"><svg></svg></div>
  <div id="sidebar">
    <h3>Modules</h3>
    <div class="module-legend" id="module-legend"></div>

    <h3>Selected Node</h3>
    <div class="info-section" id="node-info">Click a node to see details</div>

    <h3>Source Code</h3>
    <div class="source-panel" id="source-panel">
      <div id="source-content" style="color:#666;font-size:11px">Click a function to view source</div>
    </div>

    <h3>Connections</h3>
    <div class="edge-list" id="edge-list"></div>
  </div>
</div>
<div id="tooltip"></div>

<script>
const nodes = [{"id": "decoder_compute", "type": "module", "label": "decoder_compute", "metrics": {"fanIn": 19, "fanOut": 4, "instability": 0.174, "internalEdges": 44, "externalCallCount": 4, "localCallCount": 0, "callsByCategory": {"stdlib": 4}, "localDependencies": []}, "moduleColor": "#00d4ff", "moduleName": "decoder_compute"}, {"id": "decoder_compute.hasValue", "type": "function", "label": "hasValue", "direction": "inbound", "parent": "decoder_compute", "line": 70, "endLine": 74, "signature": "(params) -> dict", "docstring": "Gate: check if context field has non-null value.", "source": "def hasValue(params: dict) -> dict:\n    \"\"\"Gate: check if context field has non-null value.\"\"\"\n    field = params.get(\"field\", \"\").strip(\"'\\\"\")\n    val = params.get(field)\n    return {\"result\": val is not None and val != \"\" and val != []}", "args": ["params"], "returns": "dict", "moduleColor": "#00d4ff", "moduleName": "decoder_compute"}, {"id": "decoder_compute.loadFile", "type": "function", "label": "loadFile", "direction": "inbound", "parent": "decoder_compute", "line": 77, "endLine": 88, "signature": "(params) -> dict", "docstring": "Load Python source file from disk.", "source": "def loadFile(params: dict) -> dict:\n    \"\"\"Load Python source file from disk.\"\"\"\n    filePath = params.get(\"filePath\")\n    if not filePath:\n        return {\"sourceCode\": None, \"error\": \"No file path provided\"}\n    try:\n        with open(filePath, \"r\", encoding=\"utf-8\") as f:\n            return {\"sourceCode\": f.read(), \"error\": None}\n    except FileNotFoundError:\n        return {\"sourceCode\": None, \"error\": f\"File not found: {filePath}\"}\n    except Exception as e:\n        return {\"sourceCode\": None, \"error\": str(e)}", "args": ["params"], "returns": "dict", "moduleColor": "#00d4ff", "moduleName": "decoder_compute"}, {"id": "decoder_compute.parseAst", "type": "function", "label": "parseAst", "direction": "inbound", "parent": "decoder_compute", "line": 91, "endLine": 101, "signature": "(params) -> dict", "docstring": "Parse Python source into AST.", "source": "def parseAst(params: dict) -> dict:\n    \"\"\"Parse Python source into AST.\"\"\"\n    source = params.get(\"sourceCode\")\n    if not source:\n        return {\"ast\": None, \"error\": \"No source code\"}\n    try:\n        tree = ast.parse(source)\n        astDict = _astToDict(tree)\n        return {\"ast\": astDict, \"error\": None}\n    except SyntaxError as e:\n        return {\"ast\": None, \"error\": f\"Syntax error: {e}\"}", "args": ["params"], "returns": "dict", "moduleColor": "#00d4ff", "moduleName": "decoder_compute"}, {"id": "decoder_compute.analyzeImports", "type": "function", "label": "analyzeImports", "direction": "inbound", "parent": "decoder_compute", "line": 119, "endLine": 161, "signature": "(params) -> dict", "docstring": "Extract and resolve import semantics.", "source": "def analyzeImports(params: dict) -> dict:\n    \"\"\"Extract and resolve import semantics.\"\"\"\n    astDict = params.get(\"ast\", {})\n    imports = []\n\n    def walk(node):\n        if isinstance(node, dict):\n            ntype = node.get(\"_type\")\n            if ntype == \"Import\":\n                for alias in node.get(\"names\", []):\n                    name = alias.get(\"name\", \"\")\n                    modName = name.split(\".\")[0]\n                    imports.append({\n                        \"module\": name,\n                        \"alias\": alias.get(\"asname\"),\n                        \"semantic\": IMPORT_SEMANTICS.get(modName, {\n                            \"category\": \"unknown\",\n                            \"actions\": []\n                        }),\n                        \"line\": node.get(\"lineno\")\n                    })\n            elif ntype == \"ImportFrom\":\n                mod = node.get(\"module\", \"\")\n                modName = mod.split(\".\")[0] if mod else \"\"\n                for alias in node.get(\"names\", []):\n                    imports.append({\n                        \"module\": mod,\n                        \"name\": alias.get(\"name\"),\n                        \"alias\": alias.get(\"asname\"),\n                        \"semantic\": IMPORT_SEMANTICS.get(modName, {\n                            \"category\": \"unknown\",\n                            \"actions\": []\n                        }),\n                        \"line\": node.get(\"lineno\")\n                    })\n            for v in node.values():\n                walk(v)\n        elif isinstance(node, list):\n            for item in node:\n                walk(item)\n\n    walk(astDict)\n    return {\"imports\": imports}", "args": ["params"], "returns": "dict", "moduleColor": "#00d4ff", "moduleName": "decoder_compute"}, {"id": "decoder_compute.analyzeFunctions", "type": "function", "label": "analyzeFunctions", "direction": "inbound", "parent": "decoder_compute", "line": 164, "endLine": 222, "signature": "(params) -> dict", "docstring": "Extract function and class definitions.", "source": "def analyzeFunctions(params: dict) -> dict:\n    \"\"\"Extract function and class definitions.\"\"\"\n    astDict = params.get(\"ast\", {})\n    imports = params.get(\"imports\", [])\n    functions = []\n    classes = []\n\n    importedNames = {i.get(\"alias\") or i.get(\"name\") or i.get(\"module\", \"\")\n                     .split(\".\")[-1] for i in imports}\n\n    def extractFn(node, className=None):\n        if node.get(\"_type\") in (\"FunctionDef\", \"AsyncFunctionDef\"):\n            args = []\n            for arg in node.get(\"args\", {}).get(\"args\", []):\n                args.append(arg.get(\"arg\"))\n            returns = _extractType(node.get(\"returns\"))\n            decorators = [_extractName(d) for d in node.get(\"decorator_list\",\n                                                            [])]\n            # Analyze body for side effects\n            sideEffects = _findSideEffects(node.get(\"body\", []), importedNames)\n            fnData = {\n                \"name\": node.get(\"name\"),\n                \"args\": args,\n                \"returns\": returns,\n                \"decorators\": decorators,\n                \"isAsync\": node.get(\"_type\") == \"AsyncFunctionDef\",\n                \"line\": node.get(\"lineno\"),\n                \"sideEffects\": sideEffects,\n                \"className\": className,\n                \"docstring\": _extractDocstring(node)\n            }\n            functions.append(fnData)\n\n    def walk(node, className=None):\n        if isinstance(node, dict):\n            ntype = node.get(\"_type\")\n            if ntype == \"ClassDef\":\n                bases = [_extractName(b) for b in node.get(\"bases\", [])]\n                classes.append({\n                    \"name\": node.get(\"name\"),\n                    \"bases\": bases,\n                    \"line\": node.get(\"lineno\"),\n                    \"docstring\": _extractDocstring(node)\n                })\n                for item in node.get(\"body\", []):\n                    walk(item, className=node.get(\"name\"))\n            elif ntype in (\"FunctionDef\", \"AsyncFunctionDef\"):\n                extractFn(node, className)\n                for item in node.get(\"body\", []):\n                    walk(item, className)\n            else:\n                for v in node.values():\n                    walk(v, className)\n        elif isinstance(node, list):\n            for item in node:\n                walk(item, className)\n\n    walk(astDict)\n    return {\"functions\": functions, \"classes\": classes}", "args": ["params"], "returns": "dict", "moduleColor": "#00d4ff", "moduleName": "decoder_compute"}, {"id": "decoder_compute.analyzeControlFlow", "type": "function", "label": "analyzeControlFlow", "direction": "inbound", "parent": "decoder_compute", "line": 306, "endLine": 431, "signature": "(params) -> dict", "docstring": "Build control flow graph from AST.", "source": "def analyzeControlFlow(params: dict) -> dict:\n    \"\"\"Build control flow graph from AST.\"\"\"\n    astDict = params.get(\"ast\", {})\n    functions = params.get(\"functions\", [])\n    cfg = {\"nodes\": [], \"edges\": [], \"patterns\": {}}\n\n    nodeId = [0]\n\n    def addNode(label, ntype, line=None):\n        nid = f\"n{nodeId[0]}\"\n        nodeId[0] += 1\n        cfg[\"nodes\"].append({\n            \"id\": nid,\n            \"label\": label,\n            \"type\": ntype,\n            \"line\": line\n        })\n        return nid\n\n    def addEdge(src, dst, label=\"\"):\n        cfg[\"edges\"].append({\"from\": src, \"to\": dst, \"label\": label})\n\n    def walkBody(body, prevId=None):\n        lastId = prevId\n        for node in body:\n            if isinstance(node, dict):\n                ntype = node.get(\"_type\")\n                line = node.get(\"lineno\")\n\n                if ntype == \"If\":\n                    testStr = _exprToStr(node.get(\"test\", {}))\n                    ifId = addNode(f\"if {testStr}\", \"branch\", line)\n                    if lastId:\n                        addEdge(lastId, ifId)\n                    cfg[\"patterns\"][\"branch\"] = cfg[\"patterns\"].get(\"branch\",\n                                                                    0) + 1\n                    # True branch\n                    thenEnd = walkBody(node.get(\"body\", []), ifId)\n                    # False branch\n                    elseBody = node.get(\"orelse\", [])\n                    if elseBody:\n                        elseEnd = walkBody(elseBody, ifId)\n                        mergeId = addNode(\"merge\", \"merge\", line)\n                        if thenEnd:\n                            addEdge(thenEnd, mergeId, \"then\")\n                        if elseEnd:\n                            addEdge(elseEnd, mergeId, \"else\")\n                        lastId = mergeId\n                    else:\n                        lastId = thenEnd or ifId\n\n                elif ntype == \"For\":\n                    iterStr = _exprToStr(node.get(\"iter\", {}))\n                    forId = addNode(f\"for {iterStr}\", \"loop\", line)\n                    if lastId:\n                        addEdge(lastId, forId)\n                    cfg[\"patterns\"][\"loop\"] = cfg[\"patterns\"].get(\"loop\", 0)+1\n                    bodyEnd = walkBody(node.get(\"body\", []), forId)\n                    if bodyEnd:\n                        addEdge(bodyEnd, forId, \"next\")\n                    lastId = forId\n\n                elif ntype == \"While\":\n                    testStr = _exprToStr(node.get(\"test\", {}))\n                    whileId = addNode(f\"while {testStr}\", \"loop\", line)\n                    if lastId:\n                        addEdge(lastId, whileId)\n                    cfg[\"patterns\"][\"loop\"] = cfg[\"patterns\"].get(\"loop\", 0)+1\n                    bodyEnd = walkBody(node.get(\"body\", []), whileId)\n                    if bodyEnd:\n                        addEdge(bodyEnd, whileId, \"loop\")\n                    lastId = whileId\n\n                elif ntype == \"Try\":\n                    tryId = addNode(\"try\", \"errorHandling\", line)\n                    if lastId:\n                        addEdge(lastId, tryId)\n                    cfg[\"patterns\"][\"errorHandling\"] = cfg[\"patterns\"].get(\n                        \"errorHandling\", 0) + 1\n                    bodyEnd = walkBody(node.get(\"body\", []), tryId)\n                    handlers = node.get(\"handlers\", [])\n                    handlerEnds = []\n                    for h in handlers:\n                        htype = _extractName(h.get(\"type\"))\n                        hId = addNode(f\"except {htype}\", \"errorRecovery\", line)\n                        addEdge(tryId, hId, \"error\")\n                        hEnd = walkBody(h.get(\"body\", []), hId)\n                        if hEnd:\n                            handlerEnds.append(hEnd)\n                    finallyBody = node.get(\"finalbody\", [])\n                    if finallyBody:\n                        finId = addNode(\"finally\", \"cleanup\", line)\n                        if bodyEnd:\n                            addEdge(bodyEnd, finId, \"ok\")\n                        for he in handlerEnds:\n                            addEdge(he, finId)\n                        lastId = walkBody(finallyBody, finId) or finId\n                    else:\n                        lastId = bodyEnd\n\n                elif ntype == \"Return\":\n                    retId = addNode(\"return\", \"terminal\", line)\n                    if lastId:\n                        addEdge(lastId, retId)\n                    lastId = None\n\n                elif ntype in (\"Expr\", \"Assign\", \"AugAssign\"):\n                    label = _stmtLabel(node)\n                    stmtId = addNode(label, \"statement\", line)\n                    if lastId:\n                        addEdge(lastId, stmtId)\n                    lastId = stmtId\n\n        return lastId\n\n    # Process each function\n    for fn in functions:\n        fnName = fn.get(\"name\", \"main\")\n        entryId = addNode(f\"fn:{fnName}\", \"entry\", fn.get(\"line\"))\n        # Re-parse to get body (simplified: walk AST again)\n\n    # Walk module-level\n    moduleBody = astDict.get(\"body\", [])\n    walkBody(moduleBody)\n\n    return {\"controlFlow\": cfg}", "args": ["params"], "returns": "dict", "moduleColor": "#00d4ff", "moduleName": "decoder_compute"}, {"id": "decoder_compute.inferStates", "type": "function", "label": "inferStates", "direction": "inbound", "parent": "decoder_compute", "line": 479, "endLine": 694, "signature": "(params) -> dict", "docstring": "Infer state machine states from code structure.", "source": "def inferStates(params: dict) -> dict:\n    \"\"\"Infer state machine states from code structure.\"\"\"\n    functions = params.get(\"functions\", [])\n    classes = params.get(\"classes\", [])\n    controlFlow = params.get(\"controlFlow\", {})\n    imports = params.get(\"imports\", [])\n\n    states = []\n    stateId = 0\n\n    # Entry state\n    states.append({\n        \"id\": \"idle\",\n        \"name\": \"Idle\",\n        \"description\": \"Initial state\",\n        \"inferred_from\": \"entry_point\"\n    })\n\n    # Infer states from function names\n    for fn in functions:\n        name = fn.get(\"name\", \"\")\n        if name.startswith(\"_\"):\n            continue  # Skip private\n        \n        # Convert function name to readable state name\n        def to_state_name(fn_name):\n            \"\"\"Convert snake_case to Title Case\"\"\"\n            words = fn_name.replace(\"_\", \" \").split()\n            return \" \".join(w.capitalize() for w in words)\n        \n        # Common patterns -> grouped states\n        if any(kw in name.lower() for kw in [\"init\", \"setup\", \"start\"]):\n            states.append({\n                \"id\": f\"initializing\",\n                \"name\": \"Initializing\",\n                \"description\": f\"From function: {name}\",\n                \"inferred_from\": f\"function:{name}\"\n            })\n        elif any(kw in name.lower() for kw in [\"process\", \"handle\", \"run\", \"execute\"]):\n            states.append({\n                \"id\": f\"processing\",\n                \"name\": \"Processing\",\n                \"description\": f\"From function: {name}\",\n                \"inferred_from\": f\"function:{name}\"\n            })\n        elif any(kw in name.lower() for kw in [\"validate\", \"check\", \"verify\"]):\n            states.append({\n                \"id\": f\"validating\",\n                \"name\": \"Validating\",\n                \"description\": f\"From function: {name}\",\n                \"inferred_from\": f\"function:{name}\"\n            })\n        elif any(kw in name.lower() for kw in [\"load\", \"fetch\", \"get\", \"read\"]):\n            states.append({\n                \"id\": f\"loading\",\n                \"name\": \"Loading\",\n                \"description\": f\"From function: {name}\",\n                \"inferred_from\": f\"function:{name}\"\n            })\n        elif any(kw in name.lower() for kw in [\"save\", \"write\", \"store\"]):\n            states.append({\n                \"id\": f\"saving\",\n                \"name\": \"Saving\",\n                \"description\": f\"From function: {name}\",\n                \"inferred_from\": f\"function:{name}\"\n            })\n        elif any(kw in name.lower() for kw in [\"error\", \"fail\", \"except\"]):\n            states.append({\n                \"id\": f\"error\",\n                \"name\": \"Error\",\n                \"description\": f\"From function: {name}\",\n                \"inferred_from\": f\"function:{name}\"\n            })\n        elif any(kw in name.lower() for kw in [\"query\", \"search\", \"find\", \"lookup\"]):\n            states.append({\n                \"id\": f\"querying\",\n                \"name\": \"Querying\",\n                \"description\": f\"From function: {name}\",\n                \"inferred_from\": f\"function:{name}\"\n            })\n        elif any(kw in name.lower() for kw in [\"generate\", \"create\", \"build\", \"make\"]):\n            states.append({\n                \"id\": f\"generating\",\n                \"name\": \"Generating\",\n                \"description\": f\"From function: {name}\",\n                \"inferred_from\": f\"function:{name}\"\n            })\n        elif any(kw in name.lower() for kw in [\"analyze\", \"parse\", \"decode\", \"extract\"]):\n            states.append({\n                \"id\": f\"analyzing\",\n                \"name\": \"Analyzing\",\n                \"description\": f\"From function: {name}\",\n                \"inferred_from\": f\"function:{name}\"\n            })\n        elif any(kw in name.lower() for kw in [\"explain\", \"describe\", \"format\", \"render\"]):\n            states.append({\n                \"id\": f\"explaining\",\n                \"name\": \"Explaining\",\n                \"description\": f\"From function: {name}\",\n                \"inferred_from\": f\"function:{name}\"\n            })\n        elif any(kw in name.lower() for kw in [\"suggest\", \"recommend\", \"improve\"]):\n            states.append({\n                \"id\": f\"suggesting\",\n                \"name\": \"Suggesting\",\n                \"description\": f\"From function: {name}\",\n                \"inferred_from\": f\"function:{name}\"\n            })\n        elif any(kw in name.lower() for kw in [\"register\", \"add\", \"update\", \"set\"]):\n            states.append({\n                \"id\": f\"registering\",\n                \"name\": \"Registering\",\n                \"description\": f\"From function: {name}\",\n                \"inferred_from\": f\"function:{name}\"\n            })\n        elif any(kw in name.lower() for kw in [\"list\", \"show\", \"display\", \"print\"]):\n            states.append({\n                \"id\": f\"listing\",\n                \"name\": \"Listing\",\n                \"description\": f\"From function: {name}\",\n                \"inferred_from\": f\"function:{name}\"\n            })\n        elif any(kw in name.lower() for kw in [\"compile\", \"transform\", \"convert\"]):\n            states.append({\n                \"id\": f\"compiling\",\n                \"name\": \"Compiling\",\n                \"description\": f\"From function: {name}\",\n                \"inferred_from\": f\"function:{name}\"\n            })\n        elif any(kw in name.lower() for kw in [\"visualize\", \"graph\", \"draw\", \"plot\"]):\n            states.append({\n                \"id\": f\"visualizing\",\n                \"name\": \"Visualizing\",\n                \"description\": f\"From function: {name}\",\n                \"inferred_from\": f\"function:{name}\"\n            })\n        elif any(kw in name.lower() for kw in [\"orchestrate\", \"dispatch\", \"schedule\", \"route\"]):\n            states.append({\n                \"id\": f\"orchestrating\",\n                \"name\": \"Orchestrating\",\n                \"description\": f\"From function: {name}\",\n                \"inferred_from\": f\"function:{name}\"\n            })\n        elif any(kw in name.lower() for kw in [\"scrape\", \"crawl\", \"download\"]):\n            states.append({\n                \"id\": f\"scraping\",\n                \"name\": \"Scraping\",\n                \"description\": f\"From function: {name}\",\n                \"inferred_from\": f\"function:{name}\"\n            })\n        elif any(kw in name.lower() for kw in [\"seal\", \"sign\", \"verify\", \"proof\"]):\n            states.append({\n                \"id\": f\"sealing\",\n                \"name\": \"Sealing\",\n                \"description\": f\"From function: {name}\",\n                \"inferred_from\": f\"function:{name}\"\n            })\n        else:\n            # Fallback: create a unique state for each unmatched public function\n            state_id = name.lower().replace(\"_\", \"-\")\n            state_name = to_state_name(name)\n            states.append({\n                \"id\": state_id,\n                \"name\": state_name,\n                \"description\": f\"From function: {name}\",\n                \"inferred_from\": f\"function:{name}\"\n            })\n\n    # Infer from control flow patterns\n    patterns = controlFlow.get(\"patterns\", {})\n    if patterns.get(\"errorHandling\", 0) > 0:\n        if not any(s[\"id\"] == \"error\" for s in states):\n            states.append({\n                \"id\": \"error\",\n                \"name\": \"Error\",\n                \"description\": \"From try/except blocks\",\n                \"inferred_from\": \"pattern:errorHandling\"\n            })\n\n    # Infer from imports\n    for imp in imports:\n        cat = imp.get(\"semantic\", {}).get(\"category\")\n        if cat == \"http\":\n            if not any(s[\"id\"] == \"fetching\" for s in states):\n                states.append({\n                    \"id\": \"fetching\",\n                    \"name\": \"Fetching\",\n                    \"description\": f\"HTTP operations via {imp.get('module')}\",\n                    \"inferred_from\": f\"import:{imp.get('module')}\"\n                })\n        elif cat == \"database\":\n            if not any(s[\"id\"] == \"querying\" for s in states):\n                states.append({\n                    \"id\": \"querying\",\n                    \"name\": \"Querying\",\n                    \"description\": f\"Database ops via {imp.get('module')}\",\n                    \"inferred_from\": f\"import:{imp.get('module')}\"\n                })\n\n    # Terminal state\n    states.append({\n        \"id\": \"complete\",\n        \"name\": \"Complete\",\n        \"description\": \"Terminal state\",\n        \"inferred_from\": \"exit_point\"\n    })\n\n    # Deduplicate\n    seen = set()\n    unique = []\n    for s in states:\n        if s[\"id\"] not in seen:\n            seen.add(s[\"id\"])\n            unique.append(s)\n\n    return {\"states\": unique}", "args": ["params"], "returns": "dict", "moduleColor": "#00d4ff", "moduleName": "decoder_compute"}, {"id": "decoder_compute.inferTransitions", "type": "function", "label": "inferTransitions", "direction": "inbound", "parent": "decoder_compute", "line": 697, "endLine": 782, "signature": "(params) -> dict", "docstring": "Infer transitions and guards from control flow.", "source": "def inferTransitions(params: dict) -> dict:\n    \"\"\"Infer transitions and guards from control flow.\"\"\"\n    controlFlow = params.get(\"controlFlow\", {})\n    states = params.get(\"inferredStates\", [])\n    functions = params.get(\"functions\", [])\n\n    transitions = []\n    gates = []\n    tId = 0\n    gId = 0\n\n    stateIds = [s[\"id\"] for s in states]\n\n    # Infer gates from control flow branches first\n    nodes = controlFlow.get(\"nodes\", [])\n    gateConditions = []\n    for node in nodes:\n        if node.get(\"type\") == \"branch\":\n            label = node.get(\"label\", \"\")\n            if label.startswith(\"if \"):\n                cond = label[3:]\n                gateId = f\"g{gId}\"\n                gates.append({\n                    \"id\": gateId,\n                    \"type\": \"expression\",\n                    \"expression\": cond,\n                    \"inferred_from\": f\"line:{node.get('line')}\"\n                })\n                gateConditions.append(gateId)\n                gId += 1\n\n    # Build transitions from state pairs with optional gate associations\n    gateIdx = 0\n    for i, state in enumerate(states[:-1]):\n        nextState = states[i + 1] if i + 1 < len(states) else None\n        if nextState:\n            event = f\"{state['id'].upper()}_DONE\"\n            trans = {\n                \"id\": f\"t{tId}\",\n                \"from\": state[\"id\"],\n                \"to\": nextState[\"id\"],\n                \"on_event\": event,\n                \"inferred_from\": \"state_sequence\"\n            }\n            # Associate a gate with validation/check transitions\n            if any(kw in state[\"id\"] for kw in [\"validat\", \"check\", \"verify\"]):\n                if gateIdx < len(gateConditions):\n                    trans[\"gates\"] = [gateConditions[gateIdx]]\n                    gateIdx += 1\n            transitions.append(trans)\n            tId += 1\n\n    # Add error transition if error state exists\n    if \"error\" in stateIds:\n        # Add hasError gate\n        errorGateId = f\"g{gId}\"\n        gates.append({\n            \"id\": errorGateId,\n            \"type\": \"expression\",\n            \"expression\": \"error is not None\",\n            \"inferred_from\": \"error_pattern\"\n        })\n        gId += 1\n\n        for state in states:\n            if state[\"id\"] not in (\"error\", \"complete\"):\n                transitions.append({\n                    \"id\": f\"t{tId}\",\n                    \"from\": state[\"id\"],\n                    \"to\": \"error\",\n                    \"on_event\": \"ERROR\",\n                    \"gates\": [errorGateId],\n                    \"inferred_from\": \"error_pattern\"\n                })\n                tId += 1\n\n    # Reset transition\n    transitions.append({\n        \"id\": f\"t{tId}\",\n        \"from\": \"*\",\n        \"to\": \"idle\",\n        \"on_event\": \"RESET\",\n        \"inferred_from\": \"convention\"\n    })\n\n    return {\"transitions\": transitions, \"gates\": gates}", "args": ["params"], "returns": "dict", "moduleColor": "#00d4ff", "moduleName": "decoder_compute"}, {"id": "decoder_compute.inferActions", "type": "function", "label": "inferActions", "direction": "inbound", "parent": "decoder_compute", "line": 785, "endLine": 834, "signature": "(params) -> dict", "docstring": "Infer actions from function calls and side effects.", "source": "def inferActions(params: dict) -> dict:\n    \"\"\"Infer actions from function calls and side effects.\"\"\"\n    functions = params.get(\"functions\", [])\n    imports = params.get(\"imports\", [])\n    controlFlow = params.get(\"controlFlow\", {})\n\n    actions = []\n    aId = 0\n\n    importSemantics = {i.get(\"module\", \"\").split(\".\")[0]: i.get(\"semantic\", {})\n                       for i in imports if i.get(\"module\")}\n\n    for fn in functions:\n        name = fn.get(\"name\", \"\")\n        if name.startswith(\"_\"):\n            continue\n\n        effects = fn.get(\"sideEffects\", [])\n        for effect in effects:\n            if effect.get(\"type\") == \"call\":\n                callName = effect.get(\"name\", \"\")\n                root = callName.split(\".\")[0]\n                semantic = importSemantics.get(root, {})\n                cat = semantic.get(\"category\", \"compute\")\n\n                actionType = \"compute\"\n                if cat == \"observability\":\n                    actionType = \"emit\"\n                elif cat in (\"filesystem\", \"database\"):\n                    actionType = \"compute\"\n\n                actions.append({\n                    \"id\": f\"a{aId}\",\n                    \"name\": f\"call_{callName.replace('.', '_')}\",\n                    \"type\": actionType,\n                    \"compute_unit\": f\"impl:{callName}\",\n                    \"inferred_from\": f\"function:{name}\",\n                    \"line\": effect.get(\"line\")\n                })\n                aId += 1\n\n    # Deduplicate by name\n    seen = set()\n    unique = []\n    for a in actions:\n        if a[\"name\"] not in seen:\n            seen.add(a[\"name\"])\n            unique.append(a)\n\n    return {\"actions\": unique[:20]}  # Limit to 20 actions", "args": ["params"], "returns": "dict", "moduleColor": "#00d4ff", "moduleName": "decoder_compute"}, {"id": "decoder_compute.generateBlueprint", "type": "function", "label": "generateBlueprint", "direction": "inbound", "parent": "decoder_compute", "line": 837, "endLine": 929, "signature": "(params) -> dict", "docstring": "Assemble final L++ blueprint.", "source": "def generateBlueprint(params: dict) -> dict:\n    \"\"\"Assemble final L++ blueprint.\"\"\"\n    filePath = params.get(\"filePath\", \"decoded\")\n    states = params.get(\"inferredStates\", [])\n    transitions = params.get(\"inferredTransitions\", [])\n    gates = params.get(\"inferredGates\", [])\n    actions = params.get(\"inferredActions\", [])\n    imports = params.get(\"imports\", [])\n\n    baseName = os.path.basename(filePath).replace(\".py\", \"\") if filePath else \\\n        \"decoded\"\n\n    # Build context schema from function args\n    contextProps = {}\n    for imp in imports:\n        cat = imp.get(\"semantic\", {}).get(\"category\")\n        if cat == \"http\":\n            contextProps[\"response\"] = {\"type\": \"object\"}\n        elif cat == \"database\":\n            contextProps[\"queryResult\"] = {\"type\": \"array\"}\n    contextProps[\"error\"] = {\"type\": \"string\"}\n    contextProps[\"result\"] = {\"type\": \"object\"}\n\n    # Build states dict\n    statesDict = {}\n    for s in states:\n        statesDict[s[\"id\"]] = {\n            \"name\": s.get(\"name\", s[\"id\"]),\n            \"description\": s.get(\"description\", \"\")\n        }\n\n    # Build gates dict\n    gatesDict = {}\n    for g in gates:\n        gatesDict[g[\"id\"]] = {\n            \"type\": g.get(\"type\", \"expression\"),\n            \"expression\": g.get(\"expression\", \"true\")\n        }\n\n    # Build actions dict\n    actionsDict = {}\n    for a in actions:\n        actionsDict[a[\"id\"]] = {\n            \"type\": a.get(\"type\", \"compute\"),\n            \"compute_unit\": a.get(\"compute_unit\", \"\"),\n            \"description\": f\"Inferred from {a.get('inferred_from', 'code')}\"\n        }\n\n    # Build transitions array\n    transArr = []\n    for t in transitions:\n        trans = {\n            \"id\": t[\"id\"],\n            \"from\": t[\"from\"],\n            \"to\": t[\"to\"],\n            \"on_event\": t[\"on_event\"]\n        }\n        # Include gates if present\n        if t.get(\"gates\"):\n            trans[\"gates\"] = t[\"gates\"]\n        transArr.append(trans)\n\n    blueprint = {\n        \"$schema\": \"lpp/v0.1\",\n        \"id\": f\"decoded_{baseName}\",\n        \"name\": f\"Decoded: {baseName}\",\n        \"version\": \"1.0.0\",\n        \"description\": f\"Auto-decoded from {filePath}\",\n        \"context_schema\": {\"properties\": contextProps},\n        \"states\": statesDict,\n        \"transitions\": transArr,\n        \"gates\": gatesDict,\n        \"actions\": actionsDict,\n        \"entry_state\": states[0][\"id\"] if states else \"idle\",\n        \"terminal_states\": [\"complete\", \"error\"]\n    }\n\n    report = {\n        \"source\": filePath,\n        \"statesCount\": len(states),\n        \"transitionsCount\": len(transitions),\n        \"gatesCount\": len(gates),\n        \"actionsCount\": len(actions),\n        \"importsAnalyzed\": len(imports),\n        \"importCategories\": list(set(i.get(\"semantic\", {}).get(\"category\")\n                                     for i in imports))\n    }\n\n    return {\n        \"blueprint\": blueprint,\n        \"json\": json.dumps(blueprint, indent=2),\n        \"report\": report\n    }", "args": ["params"], "returns": "dict", "moduleColor": "#00d4ff", "moduleName": "decoder_compute"}, {"id": "decoder_compute.clearState", "type": "function", "label": "clearState", "direction": "inbound", "parent": "decoder_compute", "line": 932, "endLine": 948, "signature": "(params) -> dict", "docstring": "Reset all analysis state.", "source": "def clearState(params: dict) -> dict:\n    \"\"\"Reset all analysis state.\"\"\"\n    return {\n        \"ast\": None,\n        \"imports\": None,\n        \"functions\": None,\n        \"classes\": None,\n        \"controlFlow\": None,\n        \"inferredStates\": None,\n        \"inferredTransitions\": None,\n        \"inferredActions\": None,\n        \"inferredGates\": None,\n        \"blueprint\": None,\n        \"blueprintJson\": None,\n        \"analysisReport\": None,\n        \"error\": None\n    }", "args": ["params"], "returns": "dict", "moduleColor": "#00d4ff", "moduleName": "decoder_compute"}, {"id": "decoder_compute.walk", "type": "function", "label": "walk", "direction": "inbound", "parent": "decoder_compute", "line": 124, "endLine": 158, "signature": "(node)", "docstring": null, "source": "    def walk(node):\n        if isinstance(node, dict):\n            ntype = node.get(\"_type\")\n            if ntype == \"Import\":\n                for alias in node.get(\"names\", []):\n                    name = alias.get(\"name\", \"\")\n                    modName = name.split(\".\")[0]\n                    imports.append({\n                        \"module\": name,\n                        \"alias\": alias.get(\"asname\"),\n                        \"semantic\": IMPORT_SEMANTICS.get(modName, {\n                            \"category\": \"unknown\",\n                            \"actions\": []\n                        }),\n                        \"line\": node.get(\"lineno\")\n                    })\n            elif ntype == \"ImportFrom\":\n                mod = node.get(\"module\", \"\")\n                modName = mod.split(\".\")[0] if mod else \"\"\n                for alias in node.get(\"names\", []):\n                    imports.append({\n                        \"module\": mod,\n                        \"name\": alias.get(\"name\"),\n                        \"alias\": alias.get(\"asname\"),\n                        \"semantic\": IMPORT_SEMANTICS.get(modName, {\n                            \"category\": \"unknown\",\n                            \"actions\": []\n                        }),\n                        \"line\": node.get(\"lineno\")\n                    })\n            for v in node.values():\n                walk(v)\n        elif isinstance(node, list):\n            for item in node:\n                walk(item)", "args": ["node"], "returns": null, "moduleColor": "#00d4ff", "moduleName": "decoder_compute"}, {"id": "decoder_compute.extractFn", "type": "function", "label": "extractFn", "direction": "inbound", "parent": "decoder_compute", "line": 174, "endLine": 195, "signature": "(node, className)", "docstring": null, "source": "    def extractFn(node, className=None):\n        if node.get(\"_type\") in (\"FunctionDef\", \"AsyncFunctionDef\"):\n            args = []\n            for arg in node.get(\"args\", {}).get(\"args\", []):\n                args.append(arg.get(\"arg\"))\n            returns = _extractType(node.get(\"returns\"))\n            decorators = [_extractName(d) for d in node.get(\"decorator_list\",\n                                                            [])]\n            # Analyze body for side effects\n            sideEffects = _findSideEffects(node.get(\"body\", []), importedNames)\n            fnData = {\n                \"name\": node.get(\"name\"),\n                \"args\": args,\n                \"returns\": returns,\n                \"decorators\": decorators,\n                \"isAsync\": node.get(\"_type\") == \"AsyncFunctionDef\",\n                \"line\": node.get(\"lineno\"),\n                \"sideEffects\": sideEffects,\n                \"className\": className,\n                \"docstring\": _extractDocstring(node)\n            }\n            functions.append(fnData)", "args": ["node", "className"], "returns": null, "moduleColor": "#00d4ff", "moduleName": "decoder_compute"}, {"id": "decoder_compute.walk", "type": "function", "label": "walk", "direction": "inbound", "parent": "decoder_compute", "line": 197, "endLine": 219, "signature": "(node, className)", "docstring": null, "source": "    def walk(node, className=None):\n        if isinstance(node, dict):\n            ntype = node.get(\"_type\")\n            if ntype == \"ClassDef\":\n                bases = [_extractName(b) for b in node.get(\"bases\", [])]\n                classes.append({\n                    \"name\": node.get(\"name\"),\n                    \"bases\": bases,\n                    \"line\": node.get(\"lineno\"),\n                    \"docstring\": _extractDocstring(node)\n                })\n                for item in node.get(\"body\", []):\n                    walk(item, className=node.get(\"name\"))\n            elif ntype in (\"FunctionDef\", \"AsyncFunctionDef\"):\n                extractFn(node, className)\n                for item in node.get(\"body\", []):\n                    walk(item, className)\n            else:\n                for v in node.values():\n                    walk(v, className)\n        elif isinstance(node, list):\n            for item in node:\n                walk(item, className)", "args": ["node", "className"], "returns": null, "moduleColor": "#00d4ff", "moduleName": "decoder_compute"}, {"id": "decoder_compute.walk", "type": "function", "label": "walk", "direction": "inbound", "parent": "decoder_compute", "line": 275, "endLine": 299, "signature": "(node)", "docstring": null, "source": "    def walk(node):\n        if isinstance(node, dict):\n            ntype = node.get(\"_type\")\n            if ntype == \"Call\":\n                fname = _extractName(node.get(\"func\"))\n                root = fname.split(\".\")[0]\n                effects.append({\n                    \"type\": \"call\",\n                    \"name\": fname,\n                    \"isImported\": root in importedNames,\n                    \"line\": node.get(\"lineno\")\n                })\n            elif ntype == \"Assign\":\n                for t in node.get(\"targets\", []):\n                    tname = _extractName(t)\n                    effects.append({\n                        \"type\": \"assign\",\n                        \"target\": tname,\n                        \"line\": node.get(\"lineno\")\n                    })\n            for v in node.values():\n                walk(v)\n        elif isinstance(node, list):\n            for item in node:\n                walk(item)", "args": ["node"], "returns": null, "moduleColor": "#00d4ff", "moduleName": "decoder_compute"}, {"id": "decoder_compute.addNode", "type": "function", "label": "addNode", "direction": "inbound", "parent": "decoder_compute", "line": 314, "endLine": 323, "signature": "(label, ntype, line)", "docstring": null, "source": "    def addNode(label, ntype, line=None):\n        nid = f\"n{nodeId[0]}\"\n        nodeId[0] += 1\n        cfg[\"nodes\"].append({\n            \"id\": nid,\n            \"label\": label,\n            \"type\": ntype,\n            \"line\": line\n        })\n        return nid", "args": ["label", "ntype", "line"], "returns": null, "moduleColor": "#00d4ff", "moduleName": "decoder_compute"}, {"id": "decoder_compute.addEdge", "type": "function", "label": "addEdge", "direction": "inbound", "parent": "decoder_compute", "line": 325, "endLine": 326, "signature": "(src, dst, label)", "docstring": null, "source": "    def addEdge(src, dst, label=\"\"):\n        cfg[\"edges\"].append({\"from\": src, \"to\": dst, \"label\": label})", "args": ["src", "dst", "label"], "returns": null, "moduleColor": "#00d4ff", "moduleName": "decoder_compute"}, {"id": "decoder_compute.walkBody", "type": "function", "label": "walkBody", "direction": "inbound", "parent": "decoder_compute", "line": 328, "endLine": 419, "signature": "(body, prevId)", "docstring": null, "source": "    def walkBody(body, prevId=None):\n        lastId = prevId\n        for node in body:\n            if isinstance(node, dict):\n                ntype = node.get(\"_type\")\n                line = node.get(\"lineno\")\n\n                if ntype == \"If\":\n                    testStr = _exprToStr(node.get(\"test\", {}))\n                    ifId = addNode(f\"if {testStr}\", \"branch\", line)\n                    if lastId:\n                        addEdge(lastId, ifId)\n                    cfg[\"patterns\"][\"branch\"] = cfg[\"patterns\"].get(\"branch\",\n                                                                    0) + 1\n                    # True branch\n                    thenEnd = walkBody(node.get(\"body\", []), ifId)\n                    # False branch\n                    elseBody = node.get(\"orelse\", [])\n                    if elseBody:\n                        elseEnd = walkBody(elseBody, ifId)\n                        mergeId = addNode(\"merge\", \"merge\", line)\n                        if thenEnd:\n                            addEdge(thenEnd, mergeId, \"then\")\n                        if elseEnd:\n                            addEdge(elseEnd, mergeId, \"else\")\n                        lastId = mergeId\n                    else:\n                        lastId = thenEnd or ifId\n\n                elif ntype == \"For\":\n                    iterStr = _exprToStr(node.get(\"iter\", {}))\n                    forId = addNode(f\"for {iterStr}\", \"loop\", line)\n                    if lastId:\n                        addEdge(lastId, forId)\n                    cfg[\"patterns\"][\"loop\"] = cfg[\"patterns\"].get(\"loop\", 0)+1\n                    bodyEnd = walkBody(node.get(\"body\", []), forId)\n                    if bodyEnd:\n                        addEdge(bodyEnd, forId, \"next\")\n                    lastId = forId\n\n                elif ntype == \"While\":\n                    testStr = _exprToStr(node.get(\"test\", {}))\n                    whileId = addNode(f\"while {testStr}\", \"loop\", line)\n                    if lastId:\n                        addEdge(lastId, whileId)\n                    cfg[\"patterns\"][\"loop\"] = cfg[\"patterns\"].get(\"loop\", 0)+1\n                    bodyEnd = walkBody(node.get(\"body\", []), whileId)\n                    if bodyEnd:\n                        addEdge(bodyEnd, whileId, \"loop\")\n                    lastId = whileId\n\n                elif ntype == \"Try\":\n                    tryId = addNode(\"try\", \"errorHandling\", line)\n                    if lastId:\n                        addEdge(lastId, tryId)\n                    cfg[\"patterns\"][\"errorHandling\"] = cfg[\"patterns\"].get(\n                        \"errorHandling\", 0) + 1\n                    bodyEnd = walkBody(node.get(\"body\", []), tryId)\n                    handlers = node.get(\"handlers\", [])\n                    handlerEnds = []\n                    for h in handlers:\n                        htype = _extractName(h.get(\"type\"))\n                        hId = addNode(f\"except {htype}\", \"errorRecovery\", line)\n                        addEdge(tryId, hId, \"error\")\n                        hEnd = walkBody(h.get(\"body\", []), hId)\n                        if hEnd:\n                            handlerEnds.append(hEnd)\n                    finallyBody = node.get(\"finalbody\", [])\n                    if finallyBody:\n                        finId = addNode(\"finally\", \"cleanup\", line)\n                        if bodyEnd:\n                            addEdge(bodyEnd, finId, \"ok\")\n                        for he in handlerEnds:\n                            addEdge(he, finId)\n                        lastId = walkBody(finallyBody, finId) or finId\n                    else:\n                        lastId = bodyEnd\n\n                elif ntype == \"Return\":\n                    retId = addNode(\"return\", \"terminal\", line)\n                    if lastId:\n                        addEdge(lastId, retId)\n                    lastId = None\n\n                elif ntype in (\"Expr\", \"Assign\", \"AugAssign\"):\n                    label = _stmtLabel(node)\n                    stmtId = addNode(label, \"statement\", line)\n                    if lastId:\n                        addEdge(lastId, stmtId)\n                    lastId = stmtId\n\n        return lastId", "args": ["body", "prevId"], "returns": null, "moduleColor": "#00d4ff", "moduleName": "decoder_compute"}, {"id": "decoder_compute.to_state_name", "type": "function", "label": "to_state_name", "direction": "inbound", "parent": "decoder_compute", "line": 504, "endLine": 507, "signature": "(fn_name)", "docstring": "Convert snake_case to Title Case", "source": "        def to_state_name(fn_name):\n            \"\"\"Convert snake_case to Title Case\"\"\"\n            words = fn_name.replace(\"_\", \" \").split()\n            return \" \".join(w.capitalize() for w in words)", "args": ["fn_name"], "returns": null, "moduleColor": "#00d4ff", "moduleName": "decoder_compute"}, {"id": "ast", "type": "dependency", "label": "ast", "direction": "outbound", "category": "stdlib", "moduleColor": "#00d4ff", "moduleName": "decoder_compute"}, {"id": "json", "type": "dependency", "label": "json", "direction": "outbound", "category": "stdlib", "moduleColor": "#00d4ff", "moduleName": "decoder_compute"}, {"id": "os", "type": "dependency", "label": "os", "direction": "outbound", "category": "stdlib", "moduleColor": "#00d4ff", "moduleName": "decoder_compute"}, {"id": "typing", "type": "dependency", "label": "typing", "direction": "outbound", "category": "stdlib", "moduleColor": "#00d4ff", "moduleName": "decoder_compute"}];
const edges = [{"from": "decoder_compute.walk", "to": "decoder_compute.walk", "type": "internal", "line": 155}, {"from": "decoder_compute.walk", "to": "decoder_compute.walk", "type": "internal", "line": 158}, {"from": "decoder_compute.analyzeImports", "to": "decoder_compute.walk", "type": "internal", "line": 160}, {"from": "decoder_compute.walk", "to": "decoder_compute.walk", "type": "internal", "line": 209}, {"from": "decoder_compute.walk", "to": "decoder_compute.extractFn", "type": "internal", "line": 211}, {"from": "decoder_compute.walk", "to": "decoder_compute.walk", "type": "internal", "line": 213}, {"from": "decoder_compute.walk", "to": "decoder_compute.walk", "type": "internal", "line": 216}, {"from": "decoder_compute.walk", "to": "decoder_compute.walk", "type": "internal", "line": 219}, {"from": "decoder_compute.analyzeFunctions", "to": "decoder_compute.walk", "type": "internal", "line": 221}, {"from": "decoder_compute.walk", "to": "decoder_compute.walk", "type": "internal", "line": 296}, {"from": "decoder_compute.walk", "to": "decoder_compute.walk", "type": "internal", "line": 299}, {"from": "decoder_compute._findSideEffects", "to": "decoder_compute.walk", "type": "internal", "line": 302}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.addNode", "type": "internal", "line": 337}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.addEdge", "type": "internal", "line": 339}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.walkBody", "type": "internal", "line": 343}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.walkBody", "type": "internal", "line": 347}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.addNode", "type": "internal", "line": 348}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.addEdge", "type": "internal", "line": 350}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.addEdge", "type": "internal", "line": 352}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.addNode", "type": "internal", "line": 359}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.addEdge", "type": "internal", "line": 361}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.walkBody", "type": "internal", "line": 363}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.addEdge", "type": "internal", "line": 365}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.addNode", "type": "internal", "line": 370}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.addEdge", "type": "internal", "line": 372}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.walkBody", "type": "internal", "line": 374}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.addEdge", "type": "internal", "line": 376}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.addNode", "type": "internal", "line": 380}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.addEdge", "type": "internal", "line": 382}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.walkBody", "type": "internal", "line": 385}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.addNode", "type": "internal", "line": 390}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.addEdge", "type": "internal", "line": 391}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.walkBody", "type": "internal", "line": 392}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.addNode", "type": "internal", "line": 397}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.addEdge", "type": "internal", "line": 399}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.addEdge", "type": "internal", "line": 401}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.walkBody", "type": "internal", "line": 402}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.addNode", "type": "internal", "line": 407}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.addEdge", "type": "internal", "line": 409}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.addNode", "type": "internal", "line": 414}, {"from": "decoder_compute.walkBody", "to": "decoder_compute.addEdge", "type": "internal", "line": 416}, {"from": "decoder_compute.analyzeControlFlow", "to": "decoder_compute.addNode", "type": "internal", "line": 424}, {"from": "decoder_compute.analyzeControlFlow", "to": "decoder_compute.walkBody", "type": "internal", "line": 429}, {"from": "decoder_compute.inferStates", "to": "decoder_compute.to_state_name", "type": "internal", "line": 639}, {"from": "decoder_compute.parseAst", "to": "ast", "type": "external", "category": "stdlib", "line": 97}, {"from": "decoder_compute._astToDict", "to": "ast", "type": "external", "category": "stdlib", "line": 108}, {"from": "decoder_compute.generateBlueprint", "to": "os", "type": "external", "category": "stdlib", "line": 846}, {"from": "decoder_compute.generateBlueprint", "to": "json", "type": "external", "category": "stdlib", "line": 927}];
const moduleColors = {"decoder_compute": "#00d4ff"};

// Edge type visibility
const edgeVisibility = { internal: true, external: true, local: true };
let currentLayout = 'force';

// Create node lookup
const nodeById = {};
nodes.forEach(n => nodeById[n.id] = n);

// Setup SVG
const container = document.getElementById('graph');
const width = container.clientWidth;
const height = container.clientHeight || 600;

const svg = d3.select("svg").attr("viewBox", [0, 0, width, height]);
const g = svg.append("g");

// Zoom behavior
const zoom = d3.zoom()
    .scaleExtent([0.1, 4])
    .filter(e => !e.target.closest('.node'))
    .on("zoom", e => g.attr("transform", e.transform));
svg.call(zoom);

// Arrow markers
const defs = svg.append("defs");
["internal", "external", "local"].forEach(type => {
    const color = type === "internal" ? "#4ecdc4" : type === "external" ? "#f39c12" : "#9b59b6";
    defs.append("marker")
        .attr("id", `arrow-${type}`)
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 20)
        .attr("refY", 0)
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M0,-4L10,0L0,4")
        .attr("fill", color);
});

// Build module legend
const legendDiv = document.getElementById('module-legend');
Object.entries(moduleColors).forEach(([mod, color]) => {
    const item = document.createElement('div');
    item.className = 'module-item';
    item.innerHTML = `<div class="module-dot" style="background:${color}"></div><span class="module-name">${mod}</span>`;
    item.onclick = () => highlightModule(mod);
    legendDiv.appendChild(item);
});

// Process edges - resolve node references
const processedEdges = edges.map(e => ({
    ...e,
    source: nodeById[e.from] || { id: e.from, x: 0, y: 0 },
    target: nodeById[e.to] || { id: e.to, x: 0, y: 0 }
})).filter(e => e.source && e.target);

// Force simulation
const simulation = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(processedEdges).id(d => d.id).distance(80).strength(0.5))
    .force("charge", d3.forceManyBody().strength(-300))
    .force("center", d3.forceCenter(width / 2, height / 2))
    .force("collision", d3.forceCollide().radius(40));

// Draw edges
const edge = g.append("g").selectAll("path")
    .data(processedEdges)
    .join("path")
    .attr("class", d => `edge edge-${d.type || 'internal'}`)
    .attr("marker-end", d => `url(#arrow-${d.type || 'internal'})`);

// Node size based on type
function nodeSize(d) {
    if (d.type === 'module') return { w: 120, h: 40 };
    if (d.type === 'function' || d.type === 'async_function') return { w: 100, h: 30 };
    if (d.type === 'class') return { w: 110, h: 35 };
    return { w: 80, h: 25 };  // dependency
}

// Draw nodes
const node = g.append("g").selectAll("g")
    .data(nodes)
    .join("g")
    .attr("class", "node")
    .call(d3.drag()
        .on("start", dragStart)
        .on("drag", dragging)
        .on("end", dragEnd));

node.append("rect")
    .attr("class", d => `node-${d.type === 'dependency' ? 'dependency' : d.type === 'module' ? 'module' : 'function'}`)
    .attr("width", d => nodeSize(d).w)
    .attr("height", d => nodeSize(d).h)
    .attr("x", d => -nodeSize(d).w / 2)
    .attr("y", d => -nodeSize(d).h / 2)
    .attr("rx", 6)
    .attr("stroke", d => d.moduleColor || "#666");

node.append("text")
    .attr("class", "node-label")
    .attr("text-anchor", "middle")
    .attr("dy", d => d.signature ? -3 : 4)
    .text(d => d.label || d.id);

node.filter(d => d.signature).append("text")
    .attr("class", "node-sublabel")
    .attr("text-anchor", "middle")
    .attr("dy", 10)
    .text(d => d.signature.length > 20 ? d.signature.slice(0, 18) + ".." : d.signature);

// Tooltip
const tooltip = d3.select("#tooltip");
node.on("mouseover", (e, d) => {
    let html = `<b>${d.label || d.id}</b>`;
    if (d.type) html += `<br><span style="color:#888">${d.type}</span>`;
    if (d.signature) html += `<br><code>${d.signature}</code>`;
    if (d.direction) html += `<br>Direction: ${d.direction}`;
    tooltip.style("display", "block").html(html);
})
.on("mousemove", e => {
    tooltip.style("left", (e.pageX + 15) + "px").style("top", (e.pageY - 10) + "px");
})
.on("mouseout", () => tooltip.style("display", "none"));

// Click to select
node.on("click", (e, d) => {
    e.stopPropagation();
    selectNode(d);
});

svg.on("click", () => clearSelection());

// Update positions
simulation.on("tick", () => {
    edge.attr("d", d => {
        if (!d.source || !d.target) return "";
        const dx = d.target.x - d.source.x;
        const dy = d.target.y - d.source.y;
        const dr = Math.sqrt(dx * dx + dy * dy) * 1.5;
        return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
    });
    node.attr("transform", d => `translate(${d.x},${d.y})`);
});

// Drag functions
function dragStart(e, d) {
    if (!e.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
}
function dragging(e, d) {
    d.fx = e.x;
    d.fy = e.y;
}
function dragEnd(e, d) {
    if (!e.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
}

// Selection functions
let selectedNode = null;

function selectNode(d) {
    selectedNode = d;
    
    // Highlight node
    node.classed("dim", n => n.id !== d.id && !isConnected(d, n));
    node.select("rect").attr("stroke-width", n => n.id === d.id ? 4 : 2);
    
    // Highlight edges
    edge.classed("dim", e => e.source.id !== d.id && e.target.id !== d.id);
    edge.classed("highlight", e => e.source.id === d.id || e.target.id === d.id);
    
    // Update info panel
    updateNodeInfo(d);
    updateEdgeList(d);
}

function clearSelection() {
    selectedNode = null;
    node.classed("dim", false);
    node.select("rect").attr("stroke-width", 2);
    edge.classed("dim", false).classed("highlight", false);
    document.getElementById('node-info').innerHTML = 'Click a node to see details';
    document.getElementById('edge-list').innerHTML = '';
}

function isConnected(a, b) {
    return processedEdges.some(e => 
        (e.source.id === a.id && e.target.id === b.id) ||
        (e.source.id === b.id && e.target.id === a.id)
    );
}

function updateNodeInfo(d) {
    let html = `<div class="metric"><span class="info-label">ID:</span><span class="info-value">${d.id}</span></div>`;
    html += `<div class="metric"><span class="info-label">Type:</span><span class="info-value">${d.type}</span></div>`;
    if (d.moduleName) html += `<div class="metric"><span class="info-label">Module:</span><span class="info-value">${d.moduleName}</span></div>`;
    if (d.line) html += `<div class="metric"><span class="info-label">Line:</span><span class="info-value">${d.line}${d.endLine ? '-' + d.endLine : ''}</span></div>`;
    if (d.signature) html += `<div class="metric"><span class="info-label">Signature:</span><span class="info-value" style="font-family:monospace">${d.signature}</span></div>`;
    if (d.direction) html += `<div class="metric"><span class="info-label">Direction:</span><span class="info-value">${d.direction}</span></div>`;
    if (d.category) html += `<div class="metric"><span class="info-label">Category:</span><span class="info-value">${d.category}</span></div>`;

    if (d.metrics) {
        html += `<div style="margin-top:10px"><b>Coupling Metrics</b></div>`;
        html += `<div class="metric"><span class="info-label">Fan-In:</span><span class="info-value">${d.metrics.fanIn}</span></div>`;
        html += `<div class="metric"><span class="info-label">Fan-Out:</span><span class="info-value">${d.metrics.fanOut}</span></div>`;
        html += `<div class="metric"><span class="info-label">Instability:</span><span class="info-value">${(d.metrics.instability * 100).toFixed(1)}%</span></div>`;
        html += `<div class="metric-bar"><div class="metric-fill" style="width:${d.metrics.instability * 100}%;background:${d.metrics.instability > 0.5 ? '#ff6b6b' : '#4ecdc4'}"></div></div>`;
        html += `<div class="metric"><span class="info-label">Internal Edges:</span><span class="info-value">${d.metrics.internalEdges}</span></div>`;
    }

    document.getElementById('node-info').innerHTML = html;

    // Update source code panel
    updateSourcePanel(d);
}

function escapeHtml(str) {
    if (!str) return '';
    return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function updateSourcePanel(d) {
    const panel = document.getElementById('source-content');

    if (d.source) {
        let sourceHtml = '';
        if (d.docstring) {
            sourceHtml += `<div class="docstring" style="margin-bottom:8px;padding:5px;background:#1a1a2a;border-radius:3px">${escapeHtml(d.docstring)}</div>`;
        }
        sourceHtml += `<div class="source-code">${escapeHtml(d.source)}</div>`;
        panel.innerHTML = sourceHtml;
    } else if (d.type === 'module') {
        panel.innerHTML = `<div style="color:#888;font-size:11px">Module: ${d.label}<br>Click a function to view its source code.</div>`;
    } else if (d.type === 'dependency') {
        panel.innerHTML = `<div style="color:#888;font-size:11px">External dependency: ${d.label}<br>Category: ${d.category || 'unknown'}</div>`;
    } else {
        panel.innerHTML = `<div style="color:#666;font-size:11px">No source available for this node</div>`;
    }
}

function updateEdgeList(d) {
    const outgoing = processedEdges.filter(e => e.source.id === d.id);
    const incoming = processedEdges.filter(e => e.target.id === d.id);
    
    let html = '';
    if (outgoing.length) {
        html += '<div style="color:#4ecdc4;font-weight:bold;margin-bottom:5px">Outgoing →</div>';
        outgoing.forEach(e => {
            html += `<div class="edge-item">→ <span class="to">${e.target.id || e.to}</span> <span class="type">[${e.type}]</span></div>`;
        });
    }
    if (incoming.length) {
        html += '<div style="color:#f39c12;font-weight:bold;margin:10px 0 5px 0">← Incoming</div>';
        incoming.forEach(e => {
            html += `<div class="edge-item">← <span class="from">${e.source.id || e.from}</span> <span class="type">[${e.type}]</span></div>`;
        });
    }
    if (!outgoing.length && !incoming.length) {
        html = '<div style="color:#666">No connections</div>';
    }
    
    document.getElementById('edge-list').innerHTML = html;
}

function highlightModule(modName) {
    node.classed("dim", n => n.moduleName !== modName && n.type !== 'dependency');
    edge.classed("dim", e => {
        const srcMod = nodeById[e.source.id]?.moduleName;
        const tgtMod = nodeById[e.target.id]?.moduleName;
        return srcMod !== modName && tgtMod !== modName;
    });
}

// Layout functions
function toggleLayout(layout) {
    currentLayout = layout;
    document.querySelectorAll('.controls button').forEach(b => {
        if (b.id.startsWith('btn-') && ['force', 'horizontal', 'vertical'].includes(b.id.replace('btn-', ''))) {
            b.classList.toggle('active', b.id === `btn-${layout}`);
        }
    });
    
    if (layout === 'force') {
        simulation.alpha(1).restart();
    } else {
        simulation.stop();
        layoutNodes(layout);
    }
}

function layoutNodes(layout) {
    const modules = [...new Set(nodes.filter(n => n.type === 'module').map(n => n.id))];
    const padding = 50;
    
    if (layout === 'horizontal') {
        // Group by module, spread horizontally
        modules.forEach((mod, mi) => {
            const modNodes = nodes.filter(n => n.moduleName === mod || n.id === mod);
            const x = padding + mi * (width - padding * 2) / Math.max(modules.length - 1, 1);
            modNodes.forEach((n, ni) => {
                n.x = x;
                n.y = padding + ni * 50;
            });
        });
        // Dependencies on the right
        const deps = nodes.filter(n => n.type === 'dependency');
        deps.forEach((n, i) => {
            n.x = width - padding;
            n.y = padding + i * 40;
        });
    } else if (layout === 'vertical') {
        // Modules at top, functions below, dependencies at bottom
        const modNodes = nodes.filter(n => n.type === 'module');
        const funcNodes = nodes.filter(n => n.type === 'function' || n.type === 'async_function' || n.type === 'class');
        const depNodes = nodes.filter(n => n.type === 'dependency');
        
        modNodes.forEach((n, i) => {
            n.x = padding + i * 150;
            n.y = padding;
        });
        funcNodes.forEach((n, i) => {
            n.x = padding + (i % 6) * 130;
            n.y = 120 + Math.floor(i / 6) * 60;
        });
        depNodes.forEach((n, i) => {
            n.x = padding + (i % 8) * 100;
            n.y = height - padding - 50;
        });
    }
    
    // Update positions
    node.transition().duration(500).attr("transform", d => `translate(${d.x},${d.y})`);
    edge.transition().duration(500).attr("d", d => {
        if (!d.source || !d.target) return "";
        const dx = d.target.x - d.source.x;
        const dy = d.target.y - d.source.y;
        const dr = Math.sqrt(dx * dx + dy * dy) * 1.5;
        return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
    });
}

// Edge type toggle
function toggleEdgeType(type) {
    edgeVisibility[type] = !edgeVisibility[type];
    document.getElementById(`btn-${type}`).classList.toggle('active', edgeVisibility[type]);
    edge.style("display", d => edgeVisibility[d.type || 'internal'] ? null : "none");
}

// View controls
function resetView() {
    svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity);
}

function fitToView() {
    const bounds = g.node().getBBox();
    const scale = Math.min(width / bounds.width, height / bounds.height) * 0.9;
    const tx = (width - bounds.width * scale) / 2 - bounds.x * scale;
    const ty = (height - bounds.height * scale) / 2 - bounds.y * scale;
    svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
}

// Initial fit
setTimeout(fitToView, 1000);
</script>
</body>
</html>