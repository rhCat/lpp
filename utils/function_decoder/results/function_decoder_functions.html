<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<title>function_decoder - Function Dependencies</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
body { font-family: 'Segoe UI', Arial, sans-serif; margin: 0; padding: 20px; background: #0f0f23; color: #eee; }
h1 { color: #00d4ff; margin-bottom: 5px; font-size: 24px; }
.subtitle { color: #888; margin-bottom: 15px; font-size: 14px; }
#container { display: flex; gap: 20px; height: calc(100vh - 120px); }
#graph { flex: 1; position: relative; }
#sidebar { width: 420px; background: #1a1a2e; padding: 15px; border-radius: 8px; overflow-y: auto; }
svg { background: #16213e; border-radius: 8px; width: 100%; height: 100%; }

/* Search box */
.search-box { margin-bottom: 10px; }
.search-box input { width: 100%; padding: 8px 12px; background: #0d0d1a; border: 1px solid #333; border-radius: 4px; color: #fff; font-size: 12px; }
.search-box input:focus { outline: none; border-color: #00d4ff; }
.search-box input::placeholder { color: #666; }

/* Node styles */
.node { cursor: pointer; }
.node-module { fill: #2a2a4a; stroke-width: 3; }
.node-function { fill: #3a3a5a; stroke-width: 2; }
.node-dependency { fill: #2a2a4a; stroke: #f39c12; stroke-width: 2; stroke-dasharray: 5,3; }
.node-collapsed { fill: #4a4a7a; stroke-width: 3; }
.node-label { font-size: 13px; fill: #fff; pointer-events: none; font-weight: 500; }
.node-sublabel { font-size: 10px; fill: #888; pointer-events: none; }
.node-badge { font-size: 10px; fill: #fff; pointer-events: none; }
.node-hidden { display: none; }

/* Edge styles */
.edge { fill: none; stroke-opacity: 0.6; }
.edge-internal { stroke: #4ecdc4; stroke-width: 2; }
.edge-external { stroke: #f39c12; stroke-width: 1.5; stroke-dasharray: 4; }
.edge-local { stroke: #9b59b6; stroke-width: 2; }
.edge-label { font-size: 8px; fill: #666; pointer-events: none; }
.edge-hidden { display: none; }

/* Highlight styles */
.highlight { stroke-width: 3 !important; stroke-opacity: 1 !important; }
.dim { opacity: 0.2; }

/* Controls */
.controls { display: flex; gap: 8px; margin-bottom: 10px; flex-wrap: wrap; align-items: center; }
.controls button { background: #3a3a5a; color: #fff; border: 1px solid #555; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; }
.controls button:hover { background: #4a4a6a; }
.controls button.active { background: #00d4ff; color: #000; border-color: #00d4ff; }
.controls .separator { color: #444; margin: 0 5px; }

/* Category groups */
.category-group { margin-bottom: 8px; border: 1px solid #333; border-radius: 6px; overflow: hidden; }
.category-header { display: flex; align-items: center; padding: 8px 10px; background: #252540; cursor: pointer; user-select: none; }
.category-header:hover { background: #2a2a4a; }
.category-toggle { margin-right: 8px; font-size: 11px; color: #888; transition: transform 0.2s; }
.category-toggle.collapsed { transform: rotate(-90deg); }
.category-name { font-size: 14px; font-weight: 600; color: #00d4ff; flex: 1; }
.category-count { font-size: 11px; color: #666; background: #1a1a2e; padding: 2px 8px; border-radius: 10px; }
.category-content { max-height: 500px; overflow: hidden; transition: max-height 0.3s ease; }
.category-content.collapsed { max-height: 0; }

/* Module items in sidebar */
.module-item { display: flex; align-items: center; gap: 8px; padding: 6px 10px; cursor: pointer; border-bottom: 1px solid #222; }
.module-item:hover { background: #2a2a4a; }
.module-item.hidden { display: none; }
.module-dot { width: 10px; height: 10px; border-radius: 3px; flex-shrink: 0; }
.module-name { font-size: 13px; flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.module-expand { font-size: 11px; color: #888; padding: 3px 8px; background: #1a1a2e; border-radius: 3px; cursor: pointer; }
.module-expand:hover { background: #3a3a5a; color: #fff; }
.module-expand.collapsed { color: #f39c12; }
.module-metrics { font-size: 10px; color: #666; }

/* Info panel */
h3 { color: #00d4ff; margin: 15px 0 8px 0; font-size: 15px; border-bottom: 1px solid #333; padding-bottom: 5px; }
.info-section { font-size: 13px; line-height: 1.6; }
.info-label { color: #888; }
.info-value { color: #fff; }

/* Source code panel */
.source-panel { margin-top: 10px; }
.source-code { background: #0d0d1a; border: 1px solid #333; border-radius: 4px; padding: 10px; font-family: 'Consolas', 'Monaco', monospace; font-size: 11px; line-height: 1.4; overflow-x: auto; max-height: 250px; overflow-y: auto; white-space: pre; color: #b8b8b8; }
.docstring { color: #6a9955; font-style: italic; }
.metric { display: flex; justify-content: space-between; padding: 3px 0; }
.metric-bar { height: 4px; background: #333; border-radius: 2px; margin-top: 2px; }
.metric-fill { height: 100%; border-radius: 2px; }

/* Edge list */
.edge-list { max-height: 150px; overflow-y: auto; }
.edge-item { padding: 4px 0; border-bottom: 1px solid #333; font-size: 11px; }
.edge-item .from { color: #4ecdc4; }
.edge-item .to { color: #f39c12; }
.edge-item .type { color: #666; font-size: 10px; }

/* Tooltip */
#tooltip { position: absolute; background: #1a1a2e; border: 1px solid #00d4ff; padding: 10px; border-radius: 4px; pointer-events: none; display: none; max-width: 300px; z-index: 100; font-size: 11px; }

/* Stats bar */
.stats-bar { display: flex; gap: 18px; padding: 10px 15px; background: #1a1a2e; border-radius: 4px; margin-bottom: 10px; font-size: 13px; }
.stat { color: #888; }
.stat span { color: #00d4ff; font-weight: 600; }
</style>
</head>
<body>
<h1>function_decoder - Function Dependencies</h1>
<div class="subtitle">Collapsible function graph • Click module ▼ to collapse • Double-click to focus</div>

<div class="stats-bar">
  <div class="stat">Modules: <span id="stat-modules">0</span></div>
  <div class="stat">Functions: <span id="stat-functions">0</span></div>
  <div class="stat">Dependencies: <span id="stat-deps">0</span></div>
  <div class="stat">Edges: <span id="stat-edges">0</span></div>
  <div class="stat">Visible: <span id="stat-visible">0</span></div>
</div>

<div class="controls">
  <button onclick="collapseAll()">Collapse All</button>
  <button onclick="expandAll()">Expand All</button>
  <button onclick="resetView()">Reset</button>
  <button onclick="fitToView()">Fit</button>
  <span class="separator">|</span>
  <button onclick="toggleLayout('force')" id="btn-force" class="active">Force</button>
  <button onclick="toggleLayout('cluster')" id="btn-cluster">Cluster</button>
  <button onclick="toggleLayout('tree')" id="btn-tree">Tree</button>
  <span class="separator">|</span>
  <button onclick="toggleEdgeType('internal')" id="btn-internal" class="active">Internal</button>
  <button onclick="toggleEdgeType('external')" id="btn-external" class="active">External</button>
  <button onclick="toggleEdgeType('local')" id="btn-local" class="active">Local</button>
</div>

<div id="container">
  <div id="graph"><svg></svg></div>
  <div id="sidebar">
    <div class="search-box">
      <input type="text" id="search-input" placeholder="Search modules, functions..." oninput="filterModules(this.value)">
      <div style="display:flex;gap:5px;margin-top:5px">
        <button onclick="selectSearchResults()" style="flex:1;font-size:10px;padding:4px 8px;background:#3a3a5a;border:1px solid #555;color:#fff;border-radius:3px;cursor:pointer">Select Matches</button>
        <button onclick="addSearchToSelection()" style="flex:1;font-size:10px;padding:4px 8px;background:#3a3a5a;border:1px solid #555;color:#fff;border-radius:3px;cursor:pointer">Add to Selection</button>
      </div>
    </div>

    <h3>Modules <span style="font-weight:normal;font-size:11px;color:#666" id="module-count"></span></h3>
    <div id="module-legend"></div>

    <h3>Selected <span id="selection-count" style="font-weight:normal;color:#888">(0)</span> <button onclick="clearSelection()" style="float:right;font-size:10px;padding:2px 8px;background:#3a3a5a;border:1px solid #555;color:#fff;border-radius:3px;cursor:pointer">Clear</button></h3>
    <div style="font-size:11px;color:#666;margin-bottom:8px">Click to select • Ctrl+click for multi-select</div>
    <div class="info-section" id="node-info">Click a node to see details</div>

    <h3>Source Code</h3>
    <div class="source-panel" id="source-panel">
      <div id="source-content" style="color:#666;font-size:13px">Click a function to view source</div>
    </div>

    <h3>Connections <span id="connection-summary" style="font-weight:normal;color:#888"></span></h3>
    <div style="display:flex;gap:5px;margin-bottom:8px">
      <button onclick="selectAllIncoming()" style="flex:1;font-size:10px;padding:4px;background:#2a4a4a;border:1px solid #4ecdc4;color:#4ecdc4;border-radius:3px;cursor:pointer">+ Incoming</button>
      <button onclick="selectAllOutgoing()" style="flex:1;font-size:10px;padding:4px;background:#4a3a2a;border:1px solid #f39c12;color:#f39c12;border-radius:3px;cursor:pointer">+ Outgoing</button>
    </div>
    <div class="edge-list" id="edge-list"></div>
  </div>
</div>
<div id="tooltip"></div>

<script>
const nodes = [{"id": "function_decoder_compute", "type": "module", "label": "function_decoder_compute", "metrics": {"fanIn": 18, "fanOut": 5, "instability": 0.217, "internalEdges": 5, "externalCallCount": 14, "localCallCount": 0, "callsByCategory": {"stdlib": 14}, "localDependencies": []}, "moduleColor": "#00d4ff", "moduleName": "function_decoder_compute"}, {"id": "function_decoder_compute.loadFile", "type": "function", "label": "loadFile", "direction": "inbound", "parent": "function_decoder_compute", "line": 45, "endLine": 54, "signature": "(params) -> dict", "docstring": "Load Python file from disk.", "source": "def loadFile(params: dict) -> dict:\n    \"\"\"Load Python file from disk.\"\"\"\n    filePath = params.get(\"filePath\", \"\")\n    if not filePath:\n        return {\"sourceCode\": None, \"error\": \"No file path provided\"}\n    try:\n        with open(filePath, \"r\", encoding=\"utf-8\") as f:\n            return {\"sourceCode\": f.read(), \"error\": None}\n    except Exception as e:\n        return {\"sourceCode\": None, \"error\": str(e)}", "args": ["params"], "returns": "dict", "moduleColor": "#00d4ff", "moduleName": "function_decoder_compute"}, {"id": "function_decoder_compute.parseAst", "type": "function", "label": "parseAst", "direction": "inbound", "parent": "function_decoder_compute", "line": 57, "endLine": 66, "signature": "(params) -> dict", "docstring": "Parse source code into AST.", "source": "def parseAst(params: dict) -> dict:\n    \"\"\"Parse source code into AST.\"\"\"\n    sourceCode = params.get(\"sourceCode\")\n    if not sourceCode:\n        return {\"ast\": None, \"error\": \"No source code\"}\n    try:\n        tree = ast.parse(sourceCode)\n        return {\"ast\": tree, \"error\": None}\n    except SyntaxError as e:\n        return {\"ast\": None, \"error\": f\"Syntax error: {e}\"}", "args": ["params"], "returns": "dict", "moduleColor": "#00d4ff", "moduleName": "function_decoder_compute"}, {"id": "function_decoder_compute.extractExports", "type": "function", "label": "extractExports", "direction": "inbound", "parent": "function_decoder_compute", "line": 69, "endLine": 155, "signature": "(params) -> dict", "docstring": "Extract public functions and classes (inbound interface).", "source": "def extractExports(params: dict) -> dict:\n    \"\"\"Extract public functions and classes (inbound interface).\"\"\"\n    tree = params.get(\"ast\")\n    filePath = params.get(\"filePath\", \"\")\n    sourceCode = params.get(\"sourceCode\", \"\")\n    if not tree:\n        return {\"exports\": []}\n\n    moduleName = Path(filePath).stem if filePath else \"unknown\"\n    exports = []\n    sourceLines = sourceCode.split('\\n') if sourceCode else []\n\n    def get_source(node):\n        \"\"\"Extract source code for a node using line numbers.\"\"\"\n        if not sourceLines or not hasattr(node, 'lineno'):\n            return None\n        start = node.lineno - 1\n        end = getattr(node, 'end_lineno', start + 1)\n        if start < len(sourceLines) and end <= len(sourceLines):\n            return '\\n'.join(sourceLines[start:end])\n        return None\n\n    for node in ast.walk(tree):\n        if isinstance(node, ast.FunctionDef):\n            if not node.name.startswith(\"_\"):\n                exports.append({\n                    \"type\": \"function\",\n                    \"name\": node.name,\n                    \"module\": moduleName,\n                    \"line\": node.lineno,\n                    \"endLine\": getattr(node, 'end_lineno', node.lineno),\n                    \"args\": [a.arg for a in node.args.args],\n                    \"returns\": _get_annotation(node.returns),\n                    \"docstring\": ast.get_docstring(node),\n                    \"decorators\": [_get_decorator_name(d) for d in node.decorator_list],\n                    \"source\": get_source(node)\n                })\n        elif isinstance(node, ast.AsyncFunctionDef):\n            if not node.name.startswith(\"_\"):\n                exports.append({\n                    \"type\": \"async_function\",\n                    \"name\": node.name,\n                    \"module\": moduleName,\n                    \"line\": node.lineno,\n                    \"endLine\": getattr(node, 'end_lineno', node.lineno),\n                    \"args\": [a.arg for a in node.args.args],\n                    \"returns\": _get_annotation(node.returns),\n                    \"docstring\": ast.get_docstring(node),\n                    \"decorators\": [_get_decorator_name(d) for d in node.decorator_list],\n                    \"source\": get_source(node)\n                })\n        elif isinstance(node, ast.ClassDef):\n            if not node.name.startswith(\"_\"):\n                methods = []\n                for item in node.body:\n                    if isinstance(item, (ast.FunctionDef, ast.AsyncFunctionDef)):\n                        if not item.name.startswith(\"_\") or item.name in (\n                            \"__init__\", \"__call__\", \"__enter__\", \"__exit__\"\n                        ):\n                            methods.append(item.name)\n                exports.append({\n                    \"type\": \"class\",\n                    \"name\": node.name,\n                    \"module\": moduleName,\n                    \"line\": node.lineno,\n                    \"endLine\": getattr(node, 'end_lineno', node.lineno),\n                    \"bases\": [_get_name(b) for b in node.bases],\n                    \"methods\": methods,\n                    \"docstring\": ast.get_docstring(node),\n                    \"source\": get_source(node)\n                })\n\n    # Check for module-level __all__\n    for node in ast.iter_child_nodes(tree):\n        if isinstance(node, ast.Assign):\n            for target in node.targets:\n                if isinstance(target, ast.Name) and target.id == \"__all__\":\n                    if isinstance(node.value, (ast.List, ast.Tuple)):\n                        explicit = [\n                            elt.value for elt in node.value.elts\n                            if isinstance(elt, ast.Constant)\n                        ]\n                        # Filter exports to only __all__ members\n                        exports = [e for e in exports if e[\"name\"] in explicit]\n                        break\n\n    return {\"exports\": exports}", "args": ["params"], "returns": "dict", "moduleColor": "#00d4ff", "moduleName": "function_decoder_compute"}, {"id": "function_decoder_compute.extractImports", "type": "function", "label": "extractImports", "direction": "inbound", "parent": "function_decoder_compute", "line": 158, "endLine": 194, "signature": "(params) -> dict", "docstring": "Extract import statements with aliases and classify them.", "source": "def extractImports(params: dict) -> dict:\n    \"\"\"Extract import statements with aliases and classify them.\"\"\"\n    tree = params.get(\"ast\")\n    if not tree:\n        return {\"imports\": []}\n\n    imports = []\n    for node in ast.walk(tree):\n        if isinstance(node, ast.Import):\n            for alias in node.names:\n                mod = alias.name.split(\".\")[0]\n                imports.append({\n                    \"type\": \"import\",\n                    \"module\": alias.name,\n                    \"alias\": alias.asname or alias.name,\n                    \"line\": node.lineno,\n                    \"category\": _classify_module(mod),\n                    \"names\": []\n                })\n        elif isinstance(node, ast.ImportFrom):\n            mod = node.module or \"\"\n            baseMod = mod.split(\".\")[0] if mod else \"\"\n            isRelative = node.level > 0\n            imports.append({\n                \"type\": \"from_import\",\n                \"module\": mod,\n                \"level\": node.level,\n                \"alias\": None,\n                \"line\": node.lineno,\n                \"category\": \"local\" if isRelative else _classify_module(baseMod),\n                \"names\": [\n                    {\"name\": a.name, \"alias\": a.asname or a.name}\n                    for a in node.names\n                ]\n            })\n\n    return {\"imports\": imports}", "args": ["params"], "returns": "dict", "moduleColor": "#00d4ff", "moduleName": "function_decoder_compute"}, {"id": "function_decoder_compute.traceInternalCalls", "type": "function", "label": "traceInternalCalls", "direction": "inbound", "parent": "function_decoder_compute", "line": 197, "endLine": 236, "signature": "(params) -> dict", "docstring": "Trace function-to-function calls within the script.", "source": "def traceInternalCalls(params: dict) -> dict:\n    \"\"\"Trace function-to-function calls within the script.\"\"\"\n    tree = params.get(\"ast\")\n    exports = params.get(\"exports\", [])\n    if not tree:\n        return {\"internalCalls\": []}\n\n    exportNames = {e[\"name\"] for e in exports}\n    calls = []\n\n    class CallVisitor(ast.NodeVisitor):\n        def __init__(self):\n            self.currentFunc = None\n\n        def visit_FunctionDef(self, node):\n            prevFunc = self.currentFunc\n            self.currentFunc = node.name\n            self.generic_visit(node)\n            self.currentFunc = prevFunc\n\n        def visit_AsyncFunctionDef(self, node):\n            prevFunc = self.currentFunc\n            self.currentFunc = node.name\n            self.generic_visit(node)\n            self.currentFunc = prevFunc\n\n        def visit_Call(self, node):\n            if self.currentFunc:\n                callee = _get_call_name(node)\n                if callee and callee in exportNames:\n                    calls.append({\n                        \"from\": self.currentFunc,\n                        \"to\": callee,\n                        \"line\": node.lineno,\n                        \"type\": \"internal\"\n                    })\n            self.generic_visit(node)\n\n    CallVisitor().visit(tree)\n    return {\"internalCalls\": calls}", "args": ["params"], "returns": "dict", "moduleColor": "#00d4ff", "moduleName": "function_decoder_compute"}, {"id": "function_decoder_compute.traceExternalCalls", "type": "function", "label": "traceExternalCalls", "direction": "inbound", "parent": "function_decoder_compute", "line": 239, "endLine": 323, "signature": "(params) -> dict", "docstring": "Trace calls to imported modules, separating external and local.", "source": "def traceExternalCalls(params: dict) -> dict:\n    \"\"\"Trace calls to imported modules, separating external and local.\"\"\"\n    tree = params.get(\"ast\")\n    imports = params.get(\"imports\", [])\n    if not tree:\n        return {\"externalCalls\": [], \"localCalls\": []}\n\n    # Build alias -> (module, category) mapping\n    aliasMap = {}\n    for imp in imports:\n        if imp[\"type\"] == \"import\":\n            aliasMap[imp[\"alias\"]] = (imp[\"module\"], imp[\"category\"])\n        elif imp[\"type\"] == \"from_import\":\n            for n in imp[\"names\"]:\n                aliasMap[n[\"alias\"]] = (\n                    f\"{imp['module']}.{n['name']}\" if imp[\"module\"] else n[\"name\"],\n                    imp[\"category\"]\n                )\n\n    externalCalls = []\n    localCalls = []\n\n    class ExternalCallVisitor(ast.NodeVisitor):\n        def __init__(self):\n            self.currentFunc = None\n\n        def visit_FunctionDef(self, node):\n            prevFunc = self.currentFunc\n            self.currentFunc = node.name\n            self.generic_visit(node)\n            self.currentFunc = prevFunc\n\n        def visit_AsyncFunctionDef(self, node):\n            prevFunc = self.currentFunc\n            self.currentFunc = node.name\n            self.generic_visit(node)\n            self.currentFunc = prevFunc\n\n        def visit_Call(self, node):\n            caller = self.currentFunc or \"<module>\"\n            # Handle attribute calls like requests.get()\n            if isinstance(node.func, ast.Attribute):\n                parts = []\n                n = node.func\n                while isinstance(n, ast.Attribute):\n                    parts.append(n.attr)\n                    n = n.value\n                if isinstance(n, ast.Name):\n                    parts.append(n.id)\n                parts.reverse()\n                root = parts[0] if parts else None\n                if root and root in aliasMap:\n                    mod, cat = aliasMap[root]\n                    fullCall = \".\".join(parts)\n                    entry = {\n                        \"from\": caller,\n                        \"to\": fullCall,\n                        \"module\": mod,\n                        \"line\": node.lineno\n                    }\n                    if cat == \"local\":\n                        localCalls.append(entry)\n                    else:\n                        entry[\"category\"] = cat\n                        externalCalls.append(entry)\n            # Handle direct calls like json_loads()\n            elif isinstance(node.func, ast.Name):\n                name = node.func.id\n                if name in aliasMap:\n                    mod, cat = aliasMap[name]\n                    entry = {\n                        \"from\": caller,\n                        \"to\": name,\n                        \"module\": mod,\n                        \"line\": node.lineno\n                    }\n                    if cat == \"local\":\n                        localCalls.append(entry)\n                    else:\n                        entry[\"category\"] = cat\n                        externalCalls.append(entry)\n            self.generic_visit(node)\n\n    ExternalCallVisitor().visit(tree)\n    return {\"externalCalls\": externalCalls, \"localCalls\": localCalls}", "args": ["params"], "returns": "dict", "moduleColor": "#00d4ff", "moduleName": "function_decoder_compute"}, {"id": "function_decoder_compute.computeCoupling", "type": "function", "label": "computeCoupling", "direction": "inbound", "parent": "function_decoder_compute", "line": 326, "endLine": 371, "signature": "(params) -> dict", "docstring": "Compute coupling metrics: fan-in, fan-out, afferent/efferent.", "source": "def computeCoupling(params: dict) -> dict:\n    \"\"\"Compute coupling metrics: fan-in, fan-out, afferent/efferent.\"\"\"\n    exports = params.get(\"exports\", [])\n    imports = params.get(\"imports\", [])\n    internalCalls = params.get(\"internalCalls\", [])\n    externalCalls = params.get(\"externalCalls\", [])\n    localCalls = params.get(\"localCalls\", [])\n\n    # Fan-out: number of external dependencies\n    fanOut = len(set(imp[\"module\"]\n                 for imp in imports if imp[\"category\"] != \"local\"))\n\n    # Fan-in: number of exports (potential inbound callers)\n    fanIn = len(exports)\n\n    # Internal complexity: number of internal call edges\n    internalEdges = len(internalCalls)\n\n    # External call count by category\n    callsByCategory = defaultdict(int)\n    for call in externalCalls:\n        callsByCategory[call.get(\"category\", \"unknown\")] += 1\n\n    # Local coupling: connections to other local scripts\n    localDeps = set()\n    for call in localCalls:\n        localDeps.add(call[\"module\"].split(\".\")[0])\n    for imp in imports:\n        if imp[\"category\"] == \"local\":\n            localDeps.add(imp[\"module\"].split(\".\")[0] if imp[\"module\"] else \"\")\n\n    # Instability: I = Ce / (Ca + Ce) where Ce = fan-out, Ca = fan-in\n    instability = fanOut / (fanIn + fanOut) if (fanIn + fanOut) > 0 else 0\n\n    return {\n        \"coupling\": {\n            \"fanIn\": fanIn,\n            \"fanOut\": fanOut,\n            \"instability\": round(instability, 3),\n            \"internalEdges\": internalEdges,\n            \"externalCallCount\": len(externalCalls),\n            \"localCallCount\": len(localCalls),\n            \"callsByCategory\": dict(callsByCategory),\n            \"localDependencies\": list(localDeps)\n        }\n    }", "args": ["params"], "returns": "dict", "moduleColor": "#00d4ff", "moduleName": "function_decoder_compute"}, {"id": "function_decoder_compute.generateModuleGraph", "type": "function", "label": "generateModuleGraph", "direction": "inbound", "parent": "function_decoder_compute", "line": 374, "endLine": 475, "signature": "(params) -> dict", "docstring": "Generate final linkable module graph JSON.", "source": "def generateModuleGraph(params: dict) -> dict:\n    \"\"\"Generate final linkable module graph JSON.\"\"\"\n    filePath = params.get(\"filePath\", \"\")\n    exports = params.get(\"exports\", [])\n    imports = params.get(\"imports\", [])\n    internalCalls = params.get(\"internalCalls\", [])\n    externalCalls = params.get(\"externalCalls\", [])\n    localCalls = params.get(\"localCalls\", [])\n    coupling = params.get(\"coupling\", {})\n\n    moduleName = Path(filePath).stem if filePath else \"unknown\"\n\n    # Build nodes\n    nodes = []\n\n    # Module node (central)\n    nodes.append({\n        \"id\": moduleName,\n        \"type\": \"module\",\n        \"label\": moduleName,\n        \"metrics\": coupling\n    })\n\n    # Export nodes (inbound interface)\n    for exp in exports:\n        nodes.append({\n            \"id\": f\"{moduleName}.{exp['name']}\",\n            \"type\": exp[\"type\"],\n            \"label\": exp[\"name\"],\n            \"direction\": \"inbound\",\n            \"parent\": moduleName,\n            \"line\": exp.get(\"line\"),\n            \"endLine\": exp.get(\"endLine\"),\n            \"signature\": _build_signature(exp),\n            \"docstring\": exp.get(\"docstring\"),\n            \"source\": exp.get(\"source\"),\n            \"args\": exp.get(\"args\"),\n            \"returns\": exp.get(\"returns\")\n        })\n\n    # Import nodes (outbound dependencies)\n    seenMods = set()\n    for imp in imports:\n        mod = imp[\"module\"] or f\"relative.level{imp.get('level', 1)}\"\n        if mod not in seenMods:\n            seenMods.add(mod)\n            nodes.append({\n                \"id\": mod,\n                \"type\": \"dependency\",\n                \"label\": mod.split(\".\")[-1],\n                \"direction\": \"outbound\",\n                \"category\": imp[\"category\"]\n            })\n\n    # Build edges\n    edges = []\n\n    # Internal call edges\n    for call in internalCalls:\n        edges.append({\n            \"from\": f\"{moduleName}.{call['from']}\",\n            \"to\": f\"{moduleName}.{call['to']}\",\n            \"type\": \"internal\",\n            \"line\": call.get(\"line\")\n        })\n\n    # External call edges\n    for call in externalCalls:\n        mod = call[\"module\"].split(\".\")[0]\n        edges.append({\n            \"from\": f\"{moduleName}.{call['from']}\" if call[\"from\"] != \"<module>\" else moduleName,\n            \"to\": mod,\n            \"type\": \"external\",\n            \"category\": call.get(\"category\"),\n            \"line\": call.get(\"line\")\n        })\n\n    # Local call edges (to other scripts)\n    for call in localCalls:\n        mod = call[\"module\"].split(\".\")[0]\n        edges.append({\n            \"from\": f\"{moduleName}.{call['from']}\" if call[\"from\"] != \"<module>\" else moduleName,\n            \"to\": mod,\n            \"type\": \"local\",\n            \"line\": call.get(\"line\")\n        })\n\n    return {\n        \"moduleGraph\": {\n            \"module\": moduleName,\n            \"filePath\": filePath,\n            \"inbound\": [e for e in exports],\n            \"outbound\": [\n                {\"module\": imp[\"module\"],\n                    \"category\": imp[\"category\"], \"names\": imp[\"names\"]}\n                for imp in imports\n            ],\n            \"nodes\": nodes,\n            \"edges\": edges,\n            \"coupling\": coupling\n        }\n    }", "args": ["params"], "returns": "dict", "moduleColor": "#00d4ff", "moduleName": "function_decoder_compute"}, {"id": "function_decoder_compute.visualizeModuleGraph", "type": "function", "label": "visualizeModuleGraph", "direction": "inbound", "parent": "function_decoder_compute", "line": 547, "endLine": 611, "signature": "(params) -> dict", "docstring": "Generate stackable HTML visualization for module graph(s).\n\nArgs:\n    params: dict with 'moduleGraphs' (list of moduleGraph dicts or single),\n            'outputPath' (HTML file path), 'title' (optional)\n\nReturns:\n    dict with 'htmlPath', 'error'", "source": "def visualizeModuleGraph(params: dict) -> dict:\n    \"\"\"Generate stackable HTML visualization for module graph(s).\n\n    Args:\n        params: dict with 'moduleGraphs' (list of moduleGraph dicts or single),\n                'outputPath' (HTML file path), 'title' (optional)\n\n    Returns:\n        dict with 'htmlPath', 'error'\n    \"\"\"\n    import json as json_mod\n\n    graphs = params.get(\"moduleGraphs\", [])\n    if not isinstance(graphs, list):\n        graphs = [graphs]\n\n    outputPath = params.get(\"outputPath\", \"function_graph.html\")\n    title = params.get(\"title\", \"Function Module Graph\")\n\n    if not graphs:\n        return {\"htmlPath\": None, \"error\": \"No module graphs provided\"}\n\n    # Merge all graphs into combined nodes/edges\n    all_nodes = []\n    all_edges = []\n    module_colors = {}\n    color_palette = [\n        \"#00d4ff\", \"#ff6b6b\", \"#4ecdc4\", \"#f39c12\", \"#9b59b6\",\n        \"#1abc9c\", \"#e74c3c\", \"#3498db\", \"#2ecc71\", \"#e67e22\"\n    ]\n\n    for idx, graph in enumerate(graphs):\n        if not graph:\n            continue\n        mod_name = graph.get(\"module\", f\"module_{idx}\")\n        module_colors[mod_name] = color_palette[idx % len(color_palette)]\n\n        for node in graph.get(\"nodes\", []):\n            node_copy = dict(node)\n            node_copy[\"moduleColor\"] = module_colors[mod_name]\n            node_copy[\"moduleName\"] = mod_name\n            all_nodes.append(node_copy)\n\n        for edge in graph.get(\"edges\", []):\n            all_edges.append(edge)\n\n    # Deduplicate dependency nodes\n    seen_deps = set()\n    deduped_nodes = []\n    for node in all_nodes:\n        if node.get(\"type\") == \"dependency\":\n            if node[\"id\"] not in seen_deps:\n                seen_deps.add(node[\"id\"])\n                deduped_nodes.append(node)\n        else:\n            deduped_nodes.append(node)\n\n    html = _build_function_html(title, deduped_nodes, all_edges, module_colors)\n\n    try:\n        with open(outputPath, \"w\", encoding=\"utf-8\") as f:\n            f.write(html)\n        return {\"htmlPath\": outputPath, \"error\": None}\n    except Exception as e:\n        return {\"htmlPath\": None, \"error\": str(e)}", "args": ["params"], "returns": "dict", "moduleColor": "#00d4ff", "moduleName": "function_decoder_compute"}, {"id": "function_decoder_compute.get_source", "type": "function", "label": "get_source", "direction": "inbound", "parent": "function_decoder_compute", "line": 81, "endLine": 89, "signature": "(node)", "docstring": "Extract source code for a node using line numbers.", "source": "    def get_source(node):\n        \"\"\"Extract source code for a node using line numbers.\"\"\"\n        if not sourceLines or not hasattr(node, 'lineno'):\n            return None\n        start = node.lineno - 1\n        end = getattr(node, 'end_lineno', start + 1)\n        if start < len(sourceLines) and end <= len(sourceLines):\n            return '\\n'.join(sourceLines[start:end])\n        return None", "args": ["node"], "returns": null, "moduleColor": "#00d4ff", "moduleName": "function_decoder_compute"}, {"id": "function_decoder_compute.CallVisitor", "type": "class", "label": "CallVisitor", "direction": "inbound", "parent": "function_decoder_compute", "line": 207, "endLine": 233, "signature": null, "docstring": null, "source": "    class CallVisitor(ast.NodeVisitor):\n        def __init__(self):\n            self.currentFunc = None\n\n        def visit_FunctionDef(self, node):\n            prevFunc = self.currentFunc\n            self.currentFunc = node.name\n            self.generic_visit(node)\n            self.currentFunc = prevFunc\n\n        def visit_AsyncFunctionDef(self, node):\n            prevFunc = self.currentFunc\n            self.currentFunc = node.name\n            self.generic_visit(node)\n            self.currentFunc = prevFunc\n\n        def visit_Call(self, node):\n            if self.currentFunc:\n                callee = _get_call_name(node)\n                if callee and callee in exportNames:\n                    calls.append({\n                        \"from\": self.currentFunc,\n                        \"to\": callee,\n                        \"line\": node.lineno,\n                        \"type\": \"internal\"\n                    })\n            self.generic_visit(node)", "args": null, "returns": null, "moduleColor": "#00d4ff", "moduleName": "function_decoder_compute"}, {"id": "function_decoder_compute.ExternalCallVisitor", "type": "class", "label": "ExternalCallVisitor", "direction": "inbound", "parent": "function_decoder_compute", "line": 261, "endLine": 320, "signature": null, "docstring": null, "source": "    class ExternalCallVisitor(ast.NodeVisitor):\n        def __init__(self):\n            self.currentFunc = None\n\n        def visit_FunctionDef(self, node):\n            prevFunc = self.currentFunc\n            self.currentFunc = node.name\n            self.generic_visit(node)\n            self.currentFunc = prevFunc\n\n        def visit_AsyncFunctionDef(self, node):\n            prevFunc = self.currentFunc\n            self.currentFunc = node.name\n            self.generic_visit(node)\n            self.currentFunc = prevFunc\n\n        def visit_Call(self, node):\n            caller = self.currentFunc or \"<module>\"\n            # Handle attribute calls like requests.get()\n            if isinstance(node.func, ast.Attribute):\n                parts = []\n                n = node.func\n                while isinstance(n, ast.Attribute):\n                    parts.append(n.attr)\n                    n = n.value\n                if isinstance(n, ast.Name):\n                    parts.append(n.id)\n                parts.reverse()\n                root = parts[0] if parts else None\n                if root and root in aliasMap:\n                    mod, cat = aliasMap[root]\n                    fullCall = \".\".join(parts)\n                    entry = {\n                        \"from\": caller,\n                        \"to\": fullCall,\n                        \"module\": mod,\n                        \"line\": node.lineno\n                    }\n                    if cat == \"local\":\n                        localCalls.append(entry)\n                    else:\n                        entry[\"category\"] = cat\n                        externalCalls.append(entry)\n            # Handle direct calls like json_loads()\n            elif isinstance(node.func, ast.Name):\n                name = node.func.id\n                if name in aliasMap:\n                    mod, cat = aliasMap[name]\n                    entry = {\n                        \"from\": caller,\n                        \"to\": name,\n                        \"module\": mod,\n                        \"line\": node.lineno\n                    }\n                    if cat == \"local\":\n                        localCalls.append(entry)\n                    else:\n                        entry[\"category\"] = cat\n                        externalCalls.append(entry)\n            self.generic_visit(node)", "args": null, "returns": null, "moduleColor": "#00d4ff", "moduleName": "function_decoder_compute"}, {"id": "function_decoder_compute.visit_FunctionDef", "type": "function", "label": "visit_FunctionDef", "direction": "inbound", "parent": "function_decoder_compute", "line": 211, "endLine": 215, "signature": "(self, node)", "docstring": null, "source": "        def visit_FunctionDef(self, node):\n            prevFunc = self.currentFunc\n            self.currentFunc = node.name\n            self.generic_visit(node)\n            self.currentFunc = prevFunc", "args": ["self", "node"], "returns": null, "moduleColor": "#00d4ff", "moduleName": "function_decoder_compute"}, {"id": "function_decoder_compute.visit_AsyncFunctionDef", "type": "function", "label": "visit_AsyncFunctionDef", "direction": "inbound", "parent": "function_decoder_compute", "line": 217, "endLine": 221, "signature": "(self, node)", "docstring": null, "source": "        def visit_AsyncFunctionDef(self, node):\n            prevFunc = self.currentFunc\n            self.currentFunc = node.name\n            self.generic_visit(node)\n            self.currentFunc = prevFunc", "args": ["self", "node"], "returns": null, "moduleColor": "#00d4ff", "moduleName": "function_decoder_compute"}, {"id": "function_decoder_compute.visit_Call", "type": "function", "label": "visit_Call", "direction": "inbound", "parent": "function_decoder_compute", "line": 223, "endLine": 233, "signature": "(self, node)", "docstring": null, "source": "        def visit_Call(self, node):\n            if self.currentFunc:\n                callee = _get_call_name(node)\n                if callee and callee in exportNames:\n                    calls.append({\n                        \"from\": self.currentFunc,\n                        \"to\": callee,\n                        \"line\": node.lineno,\n                        \"type\": \"internal\"\n                    })\n            self.generic_visit(node)", "args": ["self", "node"], "returns": null, "moduleColor": "#00d4ff", "moduleName": "function_decoder_compute"}, {"id": "function_decoder_compute.visit_FunctionDef", "type": "function", "label": "visit_FunctionDef", "direction": "inbound", "parent": "function_decoder_compute", "line": 265, "endLine": 269, "signature": "(self, node)", "docstring": null, "source": "        def visit_FunctionDef(self, node):\n            prevFunc = self.currentFunc\n            self.currentFunc = node.name\n            self.generic_visit(node)\n            self.currentFunc = prevFunc", "args": ["self", "node"], "returns": null, "moduleColor": "#00d4ff", "moduleName": "function_decoder_compute"}, {"id": "function_decoder_compute.visit_AsyncFunctionDef", "type": "function", "label": "visit_AsyncFunctionDef", "direction": "inbound", "parent": "function_decoder_compute", "line": 271, "endLine": 275, "signature": "(self, node)", "docstring": null, "source": "        def visit_AsyncFunctionDef(self, node):\n            prevFunc = self.currentFunc\n            self.currentFunc = node.name\n            self.generic_visit(node)\n            self.currentFunc = prevFunc", "args": ["self", "node"], "returns": null, "moduleColor": "#00d4ff", "moduleName": "function_decoder_compute"}, {"id": "function_decoder_compute.visit_Call", "type": "function", "label": "visit_Call", "direction": "inbound", "parent": "function_decoder_compute", "line": 277, "endLine": 320, "signature": "(self, node)", "docstring": null, "source": "        def visit_Call(self, node):\n            caller = self.currentFunc or \"<module>\"\n            # Handle attribute calls like requests.get()\n            if isinstance(node.func, ast.Attribute):\n                parts = []\n                n = node.func\n                while isinstance(n, ast.Attribute):\n                    parts.append(n.attr)\n                    n = n.value\n                if isinstance(n, ast.Name):\n                    parts.append(n.id)\n                parts.reverse()\n                root = parts[0] if parts else None\n                if root and root in aliasMap:\n                    mod, cat = aliasMap[root]\n                    fullCall = \".\".join(parts)\n                    entry = {\n                        \"from\": caller,\n                        \"to\": fullCall,\n                        \"module\": mod,\n                        \"line\": node.lineno\n                    }\n                    if cat == \"local\":\n                        localCalls.append(entry)\n                    else:\n                        entry[\"category\"] = cat\n                        externalCalls.append(entry)\n            # Handle direct calls like json_loads()\n            elif isinstance(node.func, ast.Name):\n                name = node.func.id\n                if name in aliasMap:\n                    mod, cat = aliasMap[name]\n                    entry = {\n                        \"from\": caller,\n                        \"to\": name,\n                        \"module\": mod,\n                        \"line\": node.lineno\n                    }\n                    if cat == \"local\":\n                        localCalls.append(entry)\n                    else:\n                        entry[\"category\"] = cat\n                        externalCalls.append(entry)\n            self.generic_visit(node)", "args": ["self", "node"], "returns": null, "moduleColor": "#00d4ff", "moduleName": "function_decoder_compute"}, {"id": "ast", "type": "dependency", "label": "ast", "direction": "outbound", "category": "stdlib", "moduleColor": "#00d4ff", "moduleName": "function_decoder_compute"}, {"id": "os", "type": "dependency", "label": "os", "direction": "outbound", "category": "stdlib", "moduleColor": "#00d4ff", "moduleName": "function_decoder_compute"}, {"id": "collections", "type": "dependency", "label": "collections", "direction": "outbound", "category": "stdlib", "moduleColor": "#00d4ff", "moduleName": "function_decoder_compute"}, {"id": "pathlib", "type": "dependency", "label": "pathlib", "direction": "outbound", "category": "stdlib", "moduleColor": "#00d4ff", "moduleName": "function_decoder_compute"}, {"id": "json", "type": "dependency", "label": "json", "direction": "outbound", "category": "stdlib", "moduleColor": "#00d4ff", "moduleName": "function_decoder_compute"}];
const edges = [{"from": "function_decoder_compute.extractExports", "to": "function_decoder_compute.get_source", "type": "internal", "line": 104}, {"from": "function_decoder_compute.extractExports", "to": "function_decoder_compute.get_source", "type": "internal", "line": 118}, {"from": "function_decoder_compute.extractExports", "to": "function_decoder_compute.get_source", "type": "internal", "line": 138}, {"from": "function_decoder_compute.traceInternalCalls", "to": "function_decoder_compute.CallVisitor", "type": "internal", "line": 235}, {"from": "function_decoder_compute.traceExternalCalls", "to": "function_decoder_compute.ExternalCallVisitor", "type": "internal", "line": 322}, {"from": "function_decoder_compute.parseAst", "to": "ast", "type": "external", "category": "stdlib", "line": 63}, {"from": "function_decoder_compute.extractExports", "to": "pathlib", "type": "external", "category": "stdlib", "line": 77}, {"from": "function_decoder_compute.extractExports", "to": "ast", "type": "external", "category": "stdlib", "line": 91}, {"from": "function_decoder_compute.extractExports", "to": "ast", "type": "external", "category": "stdlib", "line": 102}, {"from": "function_decoder_compute.extractExports", "to": "ast", "type": "external", "category": "stdlib", "line": 116}, {"from": "function_decoder_compute.extractExports", "to": "ast", "type": "external", "category": "stdlib", "line": 137}, {"from": "function_decoder_compute.extractExports", "to": "ast", "type": "external", "category": "stdlib", "line": 142}, {"from": "function_decoder_compute.extractImports", "to": "ast", "type": "external", "category": "stdlib", "line": 165}, {"from": "function_decoder_compute.computeCoupling", "to": "collections", "type": "external", "category": "stdlib", "line": 345}, {"from": "function_decoder_compute.generateModuleGraph", "to": "pathlib", "type": "external", "category": "stdlib", "line": 384}, {"from": "function_decoder_compute._get_annotation", "to": "ast", "type": "external", "category": "stdlib", "line": 490}, {"from": "function_decoder_compute._build_function_html", "to": "json", "type": "external", "category": "stdlib", "line": 618}, {"from": "function_decoder_compute._build_function_html", "to": "json", "type": "external", "category": "stdlib", "line": 619}, {"from": "function_decoder_compute._build_function_html", "to": "json", "type": "external", "category": "stdlib", "line": 620}];
const moduleColors = {"function_decoder_compute": "#00d4ff"};

// State management
const collapsedModules = new Set();
const edgeVisibility = { internal: true, external: true, local: true };
let currentLayout = 'force';
let searchQuery = '';

// Create node lookup
const nodeById = {};
nodes.forEach(n => nodeById[n.id] = n);

// Group nodes by module
const moduleGroups = {};
nodes.forEach(n => {
    const mod = n.moduleName || (n.type === 'module' ? n.id : 'dependencies');
    if (!moduleGroups[mod]) moduleGroups[mod] = [];
    moduleGroups[mod].push(n);
});

// Group modules by category (folder path)
const categoryGroups = {};
Object.keys(moduleColors).forEach(mod => {
    const parts = mod.split(/[_\/]/);
    const category = parts.length > 1 ? parts[0] : 'root';
    if (!categoryGroups[category]) categoryGroups[category] = [];
    categoryGroups[category].push(mod);
});

// Setup SVG - use explicit width/height like working graph_visualizer
const container = document.getElementById('graph');
const width = container.clientWidth || 1200;
const height = container.clientHeight || 600;

const svg = d3.select("svg").attr("width", width).attr("height", height);
const g = svg.append("g");

// Zoom behavior - filter prevents zoom when clicking nodes
const zoom = d3.zoom()
    .scaleExtent([0.1, 4])
    .filter(e => !e.target.closest('.node'))
    .on("zoom", e => g.attr("transform", e.transform));
svg.call(zoom);

// Arrow markers
const defs = svg.append("defs");
["internal", "external", "local"].forEach(type => {
    const color = type === "internal" ? "#4ecdc4" : type === "external" ? "#f39c12" : "#9b59b6";
    defs.append("marker")
        .attr("id", `arrow-${type}`)
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 25)
        .attr("refY", 0)
        .attr("markerWidth", 6)
        .attr("markerHeight", 6)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M0,-4L10,0L0,4")
        .attr("fill", color);
});

// Build sidebar with categories
const legendDiv = document.getElementById('module-legend');
Object.entries(categoryGroups).sort().forEach(([category, mods]) => {
    const group = document.createElement('div');
    group.className = 'category-group';
    group.id = `cat-${category}`;

    const header = document.createElement('div');
    header.className = 'category-header';
    header.innerHTML = `
        <span class="category-toggle">▼</span>
        <span class="category-name">${category}</span>
        <span class="category-count">${mods.length}</span>
    `;
    header.onclick = () => toggleCategory(category);

    const content = document.createElement('div');
    content.className = 'category-content';
    content.id = `cat-content-${category}`;

    mods.sort().forEach(mod => {
        const moduleNodes = moduleGroups[mod] || [];
        const funcCount = moduleNodes.filter(n => n.type === 'function' || n.type === 'async_function').length;

        const item = document.createElement('div');
        item.className = 'module-item';
        item.id = `mod-item-${mod}`;
        item.innerHTML = `
            <div class="module-dot" style="background:${moduleColors[mod]}"></div>
            <span class="module-name" title="${mod}">${mod}</span>
            <span class="module-metrics">${funcCount}fn</span>
            <span class="module-expand" onclick="event.stopPropagation(); toggleModule('${mod}')" title="Collapse/Expand">▼</span>
        `;
        item.onclick = () => highlightModule(mod);
        item.ondblclick = () => focusModule(mod);
        content.appendChild(item);
    });

    group.appendChild(header);
    group.appendChild(content);
    legendDiv.appendChild(group);
});

// Update module count
document.getElementById('module-count').textContent = `(${Object.keys(moduleColors).length})`;

// Process edges - ONLY include edges where both source and target exist
const processedEdges = edges
    .filter(e => nodeById[e.from] && nodeById[e.to])  // Filter out edges with missing nodes
    .map(e => ({
        ...e,
        source: nodeById[e.from],
        target: nodeById[e.to]
    }));

// Force simulation - with proper decay settings for dynamic movement
const simulation = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(processedEdges).id(d => d.id).distance(120).strength(0.4))
    .force("charge", d3.forceManyBody().strength(-500).distanceMax(400))
    .force("center", d3.forceCenter(width / 2, height / 2))
    .force("collision", d3.forceCollide().radius(d => nodeSize(d).w / 2 + 15))
    .force("x", d3.forceX(width / 2).strength(0.03))
    .force("y", d3.forceY(height / 2).strength(0.03))
    .alphaDecay(0.01)
    .velocityDecay(0.3)
    .alpha(1);

// Draw edges
const edge = g.append("g").selectAll("path")
    .data(processedEdges)
    .join("path")
    .attr("class", d => `edge edge-${d.type || 'internal'}`)
    .attr("marker-end", d => `url(#arrow-${d.type || 'internal'})`);

// Node size based on type and collapsed state
function nodeSize(d) {
    if (d.type === 'module') {
        const isCollapsed = collapsedModules.has(d.id);
        return isCollapsed ? { w: 160, h: 55 } : { w: 140, h: 45 };
    }
    if (d.type === 'function' || d.type === 'async_function') return { w: 120, h: 35 };
    if (d.type === 'class') return { w: 130, h: 40 };
    if (d.type === 'dependency') return { w: 140, h: 40 };  // Larger for packages/imports
    return { w: 100, h: 30 };
}

// Drag behavior - matches working graph_visualizer pattern
let dragStartPos = null;
let isDragging = false;
const DRAG_THRESHOLD = 5;

const drag = d3.drag()
    .on("start", function(e, d) {
        e.sourceEvent.stopPropagation();
        dragStartPos = { x: e.x, y: e.y };
        isDragging = false;
    })
    .on("drag", function(e, d) {
        const dx = e.x - dragStartPos.x;
        const dy = e.y - dragStartPos.y;
        if (Math.sqrt(dx*dx + dy*dy) > DRAG_THRESHOLD) {
            isDragging = true;
            d3.select(this).raise().select("rect").attr("stroke", "#ff0").attr("stroke-width", 4);
            d.x = e.x;
            d.y = e.y;
            d.fx = e.x;
            d.fy = e.y;
            d3.select(this).attr("transform", `translate(${e.x},${e.y})`);
            if (!e.active) simulation.alphaTarget(0.3).restart();
        }
    })
    .on("end", function(e, d) {
        if (isDragging) {
            d3.select(this).select("rect").attr("stroke", d.moduleColor || "#666").attr("stroke-width", d.type === 'module' ? 3 : 2);
            if (!e.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
        dragStartPos = null;
        isDragging = false;
    });

// Draw nodes
const node = g.append("g").selectAll("g")
    .data(nodes)
    .join("g")
    .attr("class", "node")
    .call(drag);

node.append("rect")
    .attr("class", d => `node-${d.type === 'dependency' ? 'dependency' : d.type === 'module' ? 'module' : 'function'}`)
    .attr("width", d => nodeSize(d).w)
    .attr("height", d => nodeSize(d).h)
    .attr("x", d => -nodeSize(d).w / 2)
    .attr("y", d => -nodeSize(d).h / 2)
    .attr("rx", 6)
    .attr("stroke", d => d.moduleColor || "#666");

node.append("text")
    .attr("class", "node-label")
    .attr("text-anchor", "middle")
    .attr("dy", d => d.signature ? -3 : 5)
    .text(d => {
        const label = d.label || d.id;
        return label.length > 18 ? label.slice(0, 16) + '..' : label;
    });

node.filter(d => d.signature).append("text")
    .attr("class", "node-sublabel")
    .attr("text-anchor", "middle")
    .attr("dy", 10)
    .text(d => d.signature.length > 20 ? d.signature.slice(0, 18) + ".." : d.signature);

// Add collapse indicator for modules
node.filter(d => d.type === 'module').append("text")
    .attr("class", "node-badge collapse-indicator")
    .attr("x", d => nodeSize(d).w / 2 - 15)
    .attr("y", -nodeSize(d).h / 2 + 12)
    .attr("font-size", "10px")
    .attr("fill", "#888")
    .text("▼")
    .style("cursor", "pointer");

// Tooltip
const tooltip = d3.select("#tooltip");
node.on("mouseover", (e, d) => {
    let html = `<b>${d.label || d.id}</b>`;
    if (d.type) html += `<br><span style="color:#888">${d.type}</span>`;
    if (d.signature) html += `<br><code>${d.signature}</code>`;
    if (collapsedModules.has(d.moduleName || d.id)) html += `<br><span style="color:#f39c12">[collapsed]</span>`;
    tooltip.style("display", "block").html(html);
})
.on("mousemove", e => {
    tooltip.style("left", (e.pageX + 15) + "px").style("top", (e.pageY - 10) + "px");
})
.on("mouseout", () => tooltip.style("display", "none"));

// Click to select (Ctrl/Cmd for multi-select), double-click to collapse
node.on("click", (e, d) => {
    if (isDragging) return;  // Skip if this was a drag
    e.stopPropagation();
    selectNode(d, e);
});

node.on("dblclick", (e, d) => {
    if (isDragging) return;
    if (d.type === 'module') {
        toggleModule(d.id);
    } else if (d.moduleName) {
        toggleModule(d.moduleName);
    }
});

svg.on("click", () => clearSelection());

// Update positions
simulation.on("tick", () => {
    edge.attr("d", d => {
        if (!d.source || !d.target) return "";
        const dx = d.target.x - d.source.x;
        const dy = d.target.y - d.source.y;
        const dr = Math.sqrt(dx * dx + dy * dy) * 1.5;
        return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
    });
    node.attr("transform", d => `translate(${d.x},${d.y})`);
});


// === COLLAPSE/EXPAND FUNCTIONS ===

function toggleModule(modName) {
    if (collapsedModules.has(modName)) {
        collapsedModules.delete(modName);
    } else {
        collapsedModules.add(modName);
    }
    updateVisibility();
    updateSidebarState(modName);
}

function collapseAll() {
    Object.keys(moduleColors).forEach(mod => collapsedModules.add(mod));
    updateVisibility();
    updateAllSidebarStates();
}

function expandAll() {
    collapsedModules.clear();
    updateVisibility();
    updateAllSidebarStates();
}

function updateVisibility() {
    // Hide/show nodes based on collapsed state
    node.classed("node-hidden", d => {
        if (d.type === 'module') return false;  // Always show module nodes
        if (d.type === 'dependency') return false;  // Always show dependencies
        return collapsedModules.has(d.moduleName);  // Hide children of collapsed modules
    });

    // Update module node appearance when collapsed
    node.select("rect").classed("node-collapsed", d => d.type === 'module' && collapsedModules.has(d.id));
    node.select(".collapse-indicator").text(d => collapsedModules.has(d.id) ? "►" : "▼");

    // Hide edges connected to hidden nodes
    edge.classed("edge-hidden", d => {
        const srcHidden = d.source.type !== 'module' && d.source.type !== 'dependency' && collapsedModules.has(d.source.moduleName);
        const tgtHidden = d.target.type !== 'module' && d.target.type !== 'dependency' && collapsedModules.has(d.target.moduleName);
        return srcHidden || tgtHidden;
    });

    updateStats();

    // Restart simulation to reposition with higher alpha for visible movement
    if (currentLayout === 'force') {
        simulation.alpha(0.8).restart();
    }
}

function updateSidebarState(modName) {
    const item = document.getElementById(`mod-item-${modName}`);
    if (item) {
        const expand = item.querySelector('.module-expand');
        if (expand) {
            expand.classList.toggle('collapsed', collapsedModules.has(modName));
            expand.textContent = collapsedModules.has(modName) ? '►' : '▼';
        }
    }
}

function updateAllSidebarStates() {
    Object.keys(moduleColors).forEach(mod => updateSidebarState(mod));
}

function updateStats() {
    const modCount = nodes.filter(n => n.type === 'module').length;
    const funcCount = nodes.filter(n => n.type === 'function' || n.type === 'async_function').length;
    const depCount = nodes.filter(n => n.type === 'dependency').length;
    const visibleCount = nodes.filter(n => {
        if (n.type === 'module' || n.type === 'dependency') return true;
        return !collapsedModules.has(n.moduleName);
    }).length;

    document.getElementById('stat-modules').textContent = modCount;
    document.getElementById('stat-functions').textContent = funcCount;
    document.getElementById('stat-deps').textContent = depCount;
    document.getElementById('stat-edges').textContent = processedEdges.length;
    document.getElementById('stat-visible').textContent = visibleCount;
}

// === CATEGORY TOGGLE ===

function toggleCategory(category) {
    const content = document.getElementById(`cat-content-${category}`);
    const toggle = document.querySelector(`#cat-${category} .category-toggle`);
    if (content && toggle) {
        content.classList.toggle('collapsed');
        toggle.classList.toggle('collapsed');
    }
}

// === SEARCH/FILTER ===

function filterModules(query) {
    searchQuery = query.toLowerCase();
    document.querySelectorAll('.module-item').forEach(item => {
        const name = item.querySelector('.module-name').textContent.toLowerCase();
        item.classList.toggle('hidden', query && !name.includes(searchQuery));
    });

    // Also filter nodes visually
    if (query) {
        node.classed("dim", d => {
            const label = (d.label || d.id || '').toLowerCase();
            const modName = (d.moduleName || '').toLowerCase();
            return !label.includes(searchQuery) && !modName.includes(searchQuery);
        });
    } else {
        node.classed("dim", false);
    }
}

function getSearchMatches() {
    if (!searchQuery) return [];
    return nodes.filter(d => {
        const label = (d.label || d.id || '').toLowerCase();
        const modName = (d.moduleName || '').toLowerCase();
        return label.includes(searchQuery) || modName.includes(searchQuery);
    });
}

function selectSearchResults() {
    const matches = getSearchMatches();
    if (matches.length === 0) return;
    selectedNodes.clear();
    matches.forEach(d => selectedNodes.add(d.id));
    updateSelectionDisplay();
}

function addSearchToSelection() {
    const matches = getSearchMatches();
    if (matches.length === 0) return;
    matches.forEach(d => selectedNodes.add(d.id));
    updateSelectionDisplay();
}

function selectAllIncoming() {
    if (selectedNodes.size === 0) return;
    const currentSelected = [...selectedNodes];
    processedEdges.forEach(e => {
        if (currentSelected.includes(e.target.id)) {
            selectedNodes.add(e.source.id);
        }
    });
    updateSelectionDisplay();
}

function selectAllOutgoing() {
    if (selectedNodes.size === 0) return;
    const currentSelected = [...selectedNodes];
    processedEdges.forEach(e => {
        if (currentSelected.includes(e.source.id)) {
            selectedNodes.add(e.target.id);
        }
    });
    updateSelectionDisplay();
}

// === FOCUS MODULE ===

function focusModule(modName) {
    // Expand this module if collapsed
    if (collapsedModules.has(modName)) {
        collapsedModules.delete(modName);
        updateVisibility();
        updateSidebarState(modName);
    }

    // Center on module node
    const modNode = nodes.find(n => n.id === modName || n.moduleName === modName);
    if (modNode && modNode.x && modNode.y) {
        svg.transition().duration(500).call(
            zoom.transform,
            d3.zoomIdentity.translate(width / 2 - modNode.x, height / 2 - modNode.y).scale(1.5)
        );
    }

    // Highlight module
    highlightModule(modName);
}

// Selection functions - Multi-select support
const selectedNodes = new Set();

function selectNode(d, event) {
    const isMultiSelect = event && (event.ctrlKey || event.metaKey || event.shiftKey);

    if (isMultiSelect) {
        // Toggle selection
        if (selectedNodes.has(d.id)) {
            selectedNodes.delete(d.id);
        } else {
            selectedNodes.add(d.id);
        }
    } else {
        // Single select - clear others
        selectedNodes.clear();
        selectedNodes.add(d.id);
    }

    updateSelectionDisplay();
}

function updateSelectionDisplay() {
    const selectedIds = [...selectedNodes];
    const selectedData = selectedIds.map(id => nodeById[id]).filter(Boolean);

    // Update selection count
    document.getElementById('selection-count').textContent = `(${selectedNodes.size})`;

    if (selectedNodes.size === 0) {
        node.classed("dim", false);
        node.select("rect").attr("stroke-width", d => d.type === 'module' ? 3 : 2);
        edge.classed("dim", false).classed("highlight", false);
        document.getElementById('node-info').innerHTML = 'Click a node to see details';
        document.getElementById('edge-list').innerHTML = '';
        document.getElementById('connection-summary').textContent = '';
        return;
    }

    // Highlight selected nodes and their connections
    const connectedIds = new Set(selectedIds);
    processedEdges.forEach(e => {
        if (selectedNodes.has(e.source.id)) connectedIds.add(e.target.id);
        if (selectedNodes.has(e.target.id)) connectedIds.add(e.source.id);
    });

    node.classed("dim", n => !connectedIds.has(n.id));
    node.select("rect").attr("stroke-width", n => selectedNodes.has(n.id) ? 4 : 2);

    // Highlight edges connected to any selected node
    edge.classed("dim", e => !selectedNodes.has(e.source.id) && !selectedNodes.has(e.target.id));
    edge.classed("highlight", e => selectedNodes.has(e.source.id) || selectedNodes.has(e.target.id));

    // Update info panel for single or multiple selection
    if (selectedNodes.size === 1) {
        updateNodeInfo(selectedData[0]);
    } else {
        updateMultiNodeInfo(selectedData);
    }
    updateCombinedEdgeList(selectedData);
}

function clearSelection() {
    selectedNodes.clear();
    updateSelectionDisplay();
}

function isConnected(a, b) {
    return processedEdges.some(e =>
        (e.source.id === a.id && e.target.id === b.id) ||
        (e.source.id === b.id && e.target.id === a.id)
    );
}

function updateMultiNodeInfo(nodes) {
    let html = `<div style="color:#00d4ff;font-weight:bold;margin-bottom:10px">${nodes.length} items selected</div>`;
    html += '<div style="max-height:150px;overflow-y:auto">';
    nodes.forEach(d => {
        const color = d.moduleColor || moduleColors[d.moduleName] || '#666';
        html += `<div style="display:flex;align-items:center;gap:8px;padding:4px 0;border-bottom:1px solid #333">`;
        html += `<span style="width:8px;height:8px;background:${color};border-radius:2px"></span>`;
        html += `<span style="flex:1">${d.label || d.id}</span>`;
        html += `<span style="color:#666;font-size:10px">${d.type}</span>`;
        html += `</div>`;
    });
    html += '</div>';
    document.getElementById('node-info').innerHTML = html;
    document.getElementById('source-content').innerHTML = '<div style="color:#666;font-size:13px">Select a single node to view source</div>';
}

function updateCombinedEdgeList(selectedData) {
    const selectedIds = new Set(selectedData.map(d => d.id));

    // Collect all outgoing and incoming edges for selected nodes
    const outgoing = [];
    const incoming = [];

    processedEdges.forEach(e => {
        if (selectedIds.has(e.source.id) && !selectedIds.has(e.target.id)) {
            outgoing.push(e);
        }
        if (selectedIds.has(e.target.id) && !selectedIds.has(e.source.id)) {
            incoming.push(e);
        }
    });

    // Deduplicate by target/source
    const uniqueOutgoing = [...new Map(outgoing.map(e => [e.target.id, e])).values()];
    const uniqueIncoming = [...new Map(incoming.map(e => [e.source.id, e])).values()];

    // Update summary
    document.getElementById('connection-summary').textContent = `(${uniqueIncoming.length} in, ${uniqueOutgoing.length} out)`;

    let html = '';
    if (uniqueOutgoing.length) {
        html += `<div style="color:#4ecdc4;font-weight:bold;margin-bottom:5px">Outgoing (${uniqueOutgoing.length}) →</div>`;
        uniqueOutgoing.slice(0, 20).forEach(e => {
            const fromLabel = e.source.label || e.source.id;
            html += `<div class="edge-item" style="cursor:pointer" onclick="selectNodeById('${e.target.id}')">`;
            html += `<span style="color:#666;font-size:10px">from ${fromLabel.slice(0,15)}</span> → `;
            html += `<span class="to">${e.target.label || e.target.id}</span>`;
            html += `</div>`;
        });
        if (uniqueOutgoing.length > 20) html += `<div style="color:#666;font-size:10px">...and ${uniqueOutgoing.length - 20} more</div>`;
    }
    if (uniqueIncoming.length) {
        html += `<div style="color:#f39c12;font-weight:bold;margin:10px 0 5px 0">← Incoming (${uniqueIncoming.length})</div>`;
        uniqueIncoming.slice(0, 20).forEach(e => {
            const toLabel = e.target.label || e.target.id;
            html += `<div class="edge-item" style="cursor:pointer" onclick="selectNodeById('${e.source.id}')">`;
            html += `<span class="from">${e.source.label || e.source.id}</span>`;
            html += ` → <span style="color:#666;font-size:10px">to ${toLabel.slice(0,15)}</span>`;
            html += `</div>`;
        });
        if (uniqueIncoming.length > 20) html += `<div style="color:#666;font-size:10px">...and ${uniqueIncoming.length - 20} more</div>`;
    }
    if (!uniqueOutgoing.length && !uniqueIncoming.length) {
        html = '<div style="color:#666">No external connections</div>';
    }

    document.getElementById('edge-list').innerHTML = html;
}

function selectNodeById(id) {
    const d = nodeById[id];
    if (d) {
        selectedNodes.clear();
        selectedNodes.add(id);
        updateSelectionDisplay();
        focusOnNode(d);
    }
}

function focusOnNode(d) {
    if (d.x && d.y) {
        svg.transition().duration(300).call(
            zoom.transform,
            d3.zoomIdentity.translate(width / 2 - d.x, height / 2 - d.y).scale(1.2)
        );
    }
}

function updateNodeInfo(d) {
    let html = `<div class="metric"><span class="info-label">ID:</span><span class="info-value">${d.id}</span></div>`;
    html += `<div class="metric"><span class="info-label">Type:</span><span class="info-value">${d.type}</span></div>`;
    if (d.moduleName) html += `<div class="metric"><span class="info-label">Module:</span><span class="info-value">${d.moduleName}</span></div>`;
    if (d.line) html += `<div class="metric"><span class="info-label">Line:</span><span class="info-value">${d.line}${d.endLine ? '-' + d.endLine : ''}</span></div>`;
    if (d.signature) html += `<div class="metric"><span class="info-label">Signature:</span><span class="info-value" style="font-family:monospace">${d.signature}</span></div>`;
    if (d.direction) html += `<div class="metric"><span class="info-label">Direction:</span><span class="info-value">${d.direction}</span></div>`;
    if (d.category) html += `<div class="metric"><span class="info-label">Category:</span><span class="info-value">${d.category}</span></div>`;

    if (d.metrics) {
        html += `<div style="margin-top:10px"><b>Coupling Metrics</b></div>`;
        html += `<div class="metric"><span class="info-label">Fan-In:</span><span class="info-value">${d.metrics.fanIn}</span></div>`;
        html += `<div class="metric"><span class="info-label">Fan-Out:</span><span class="info-value">${d.metrics.fanOut}</span></div>`;
        html += `<div class="metric"><span class="info-label">Instability:</span><span class="info-value">${(d.metrics.instability * 100).toFixed(1)}%</span></div>`;
        html += `<div class="metric-bar"><div class="metric-fill" style="width:${d.metrics.instability * 100}%;background:${d.metrics.instability > 0.5 ? '#ff6b6b' : '#4ecdc4'}"></div></div>`;
        html += `<div class="metric"><span class="info-label">Internal Edges:</span><span class="info-value">${d.metrics.internalEdges}</span></div>`;
    }

    document.getElementById('node-info').innerHTML = html;
    updateSourcePanel(d);
}

function escapeHtml(str) {
    if (!str) return '';
    return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function updateSourcePanel(d) {
    const panel = document.getElementById('source-content');

    if (d.source) {
        let sourceHtml = '';
        if (d.docstring) {
            sourceHtml += `<div class="docstring" style="margin-bottom:8px;padding:5px;background:#1a1a2a;border-radius:3px">${escapeHtml(d.docstring)}</div>`;
        }
        sourceHtml += `<div class="source-code">${escapeHtml(d.source)}</div>`;
        panel.innerHTML = sourceHtml;
    } else if (d.type === 'module') {
        const funcCount = (moduleGroups[d.id] || []).filter(n => n.type === 'function').length;
        panel.innerHTML = `<div style="color:#888;font-size:11px">Module: ${d.label}<br>Functions: ${funcCount}<br><br>Double-click to collapse/expand</div>`;
    } else if (d.type === 'dependency') {
        panel.innerHTML = `<div style="color:#888;font-size:11px">External dependency: ${d.label}<br>Category: ${d.category || 'unknown'}</div>`;
    } else {
        panel.innerHTML = `<div style="color:#666;font-size:11px">No source available</div>`;
    }
}

function highlightModule(modName) {
    clearSelection();
    node.classed("dim", n => n.moduleName !== modName && n.id !== modName && n.type !== 'dependency');
    edge.classed("dim", e => {
        const srcMod = e.source.moduleName || e.source.id;
        const tgtMod = e.target.moduleName || e.target.id;
        return srcMod !== modName && tgtMod !== modName;
    });
}

// Layout functions
function toggleLayout(layout) {
    currentLayout = layout;
    document.querySelectorAll('.controls button').forEach(b => {
        if (b.id.startsWith('btn-') && ['force', 'cluster', 'tree'].includes(b.id.replace('btn-', ''))) {
            b.classList.toggle('active', b.id === `btn-${layout}`);
        }
    });

    if (layout === 'force') {
        simulation.alpha(1).restart();
    } else {
        simulation.stop();
        layoutNodes(layout);
    }
}

function layoutNodes(layout) {
    const modules = [...new Set(nodes.filter(n => n.type === 'module').map(n => n.id))];
    const padding = 80;

    if (layout === 'cluster') {
        // Cluster layout - modules in grid, functions around them
        const cols = Math.ceil(Math.sqrt(modules.length));
        const cellW = (width - padding * 2) / cols;
        const cellH = (height - padding * 2) / Math.ceil(modules.length / cols);

        modules.forEach((mod, mi) => {
            const col = mi % cols;
            const row = Math.floor(mi / cols);
            const cx = padding + col * cellW + cellW / 2;
            const cy = padding + row * cellH + cellH / 2;

            // Module at center
            const modNode = nodes.find(n => n.id === mod);
            if (modNode) { modNode.x = cx; modNode.y = cy; }

            // Functions around it
            const funcs = nodes.filter(n => n.moduleName === mod && n.type !== 'module');
            const radius = Math.min(cellW, cellH) * 0.35;
            funcs.forEach((n, fi) => {
                const angle = (2 * Math.PI * fi) / funcs.length;
                n.x = cx + radius * Math.cos(angle);
                n.y = cy + radius * Math.sin(angle);
            });
        });

        // Dependencies at bottom
        const deps = nodes.filter(n => n.type === 'dependency');
        deps.forEach((n, i) => {
            n.x = padding + (i % 10) * 90;
            n.y = height - padding;
        });
    } else if (layout === 'tree') {
        // Tree layout - modules at top, functions below
        const modNodes = nodes.filter(n => n.type === 'module');
        const funcNodes = nodes.filter(n => n.type === 'function' || n.type === 'async_function' || n.type === 'class');
        const depNodes = nodes.filter(n => n.type === 'dependency');

        modNodes.forEach((n, i) => {
            n.x = padding + (i % 8) * 120;
            n.y = padding + Math.floor(i / 8) * 60;
        });

        funcNodes.forEach((n, i) => {
            n.x = padding + (i % 10) * 100;
            n.y = 200 + Math.floor(i / 10) * 50;
        });

        depNodes.forEach((n, i) => {
            n.x = padding + (i % 12) * 80;
            n.y = height - padding - 30;
        });
    }

    // Animate transition
    node.transition().duration(500).attr("transform", d => `translate(${d.x},${d.y})`);
    edge.transition().duration(500).attr("d", d => {
        if (!d.source || !d.target) return "";
        const dx = d.target.x - d.source.x;
        const dy = d.target.y - d.source.y;
        const dr = Math.sqrt(dx * dx + dy * dy) * 1.5;
        return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
    });
}

// Edge type toggle
function toggleEdgeType(type) {
    edgeVisibility[type] = !edgeVisibility[type];
    document.getElementById(`btn-${type}`).classList.toggle('active', edgeVisibility[type]);
    edge.style("display", d => {
        if (!edgeVisibility[d.type || 'internal']) return "none";
        // Also respect collapse state
        const srcHidden = d.source.type !== 'module' && d.source.type !== 'dependency' && collapsedModules.has(d.source.moduleName);
        const tgtHidden = d.target.type !== 'module' && d.target.type !== 'dependency' && collapsedModules.has(d.target.moduleName);
        return (srcHidden || tgtHidden) ? "none" : null;
    });
}

// View controls
function resetView() {
    svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity);
    clearSelection();
}

function fitToView() {
    const bounds = g.node().getBBox();
    if (bounds.width === 0 || bounds.height === 0) return;
    const scale = Math.min(width / bounds.width, height / bounds.height) * 0.85;
    const tx = (width - bounds.width * scale) / 2 - bounds.x * scale;
    const ty = (height - bounds.height * scale) / 2 - bounds.y * scale;
    svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
}

// Initialize
updateStats();
setTimeout(fitToView, 1000);
</script>
</body>
</html>